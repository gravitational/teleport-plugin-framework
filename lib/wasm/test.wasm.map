{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","boilerplate/vendor/teleport/google/protobuf.ts","boilerplate/vendor/teleport/types.ts","boilerplate/vendor/teleport/events.ts","boilerplate/vendor/teleport/plugin.ts","assembly/lib_wasm_test.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/shared/runtime.ts","~lib/util/sort.ts","~lib/string.ts","~lib/date.ts","~lib/as-sleep/assembly/index.ts","~lib/dataview.ts","~lib/arraybuffer.ts","~lib/util/error.ts","~lib/rt.ts","boilerplate/vendor/teleport/__proto.ts","~lib/number.ts","~lib/staticarray.ts","~lib/array.ts","~lib/util/hash.ts","~lib/map.ts","boilerplate/vendor/teleport/wrappers.ts"],"names":[],"mappings":"mpFQUI,KAIgB,oBMoChB,AAAO,AAAmB,EAA0B,MAA0B,SH+iBhF,AAAW,EAA2B,EAAU,MAChD,AAAW,EAA2B,EAAU,MAC5C,EAAmB,IAAG,AACpB,EAAO,KAAK,AAAE,AAAC,EAAO,GAAM,EAAO,WACrC,IACE,AAAI,AAAU,KAAS,AAAU,QAAO,GACxC,EAAQ,KACR,EAAQ,KACR,EAAQ,KACD,EAAO,QAGpB,IAAO,oBACL,AAAQ,AAAe,OACvB,AAAQ,AAAe,OACvB,AAAI,EAAK,KAAG,AAAO,EAAI,KACvB,EAAQ,KACR,EAAQ,UAEV,OGvgBE,AAAI,EAA2B,KAA0B,AAAO,IAChE,AAAI,EAA2B,QAAK,EAA4B,MAAG,AAAO,IAC1E,AAAiB,MACjB,AAAI,EAAc,OAAkC,AAAO,IAE3D,AAAQ,AAAY,EAAM,EAAG,EAAO,EAAG,cN3FjC,QAAE,cQnBV,AAAe,OAAa,KAE5B,IAAO,EAAS,ED6Bd,oBPRA,AAAM,QAIN,KAIA,KUyBA,AAAO,AAAmB,EAA0B,Sf2CpD,AAAW,KAAqB,MAVhC,AAA0B,KAAqB,AAAC,6BAKhD,EAAqB,EAA0B,KAAqB,WA0BpE,AAAW,MACX,AAAI,EAAQ,KACN,GAAO,AAAO,KAAa,KAAQ,EAA0B,2BACjE,EAEF,AAAW,OACP,GAAO,AAAO,qBAClB,EAAY,IACZ,EAAY,OA9Ed,EAAsB,IACtB,EAAa,IACb,OiBpCA,AAAU,KACV,AAAI,EAAK,AAAU,QAAM,EAAgB,oBACzC,AAAO,AAAqB,EAAM,GAAgB,EAAK,YjBgGrD,AAAW,OACX,AAAO,EAAQ,QAAkB,AAAC,AAAW,IAAQ,GAA8B,SAkBnF,AAAW,OACX,EAAqB,EAA0B,KAC/C,EAAY,IACZ,EAAY,IACZ,EAAY,SAKZ,AAAI,EAAQ,MAAM,AAAO,AAAO,iCAChC,IACA,EAAY,GAAS,MAAqB,AAAK,KAAS,UAgJ1D,AAAI,AAAC,KAAU,EACX,GAAO,AAAO,qBAClB,AAAY,AAAmB,EAAW,KAC1C,AAAI,IAAe,MACjB,AAAa,AAAmB,EAAY,KAC5C,AAAkB,MAClB,AAAI,EAAe,AAAK,OAEtB,AAAI,IAGF,KAGA,MAEG,AAAI,EAAe,KAAe,GAAS,SAEhD,kDA5JJ,AAAgB,KAChB,AAAS,KACT,AAAW,MACX,IAAO,EAAQ,SACT,GAAO,AAAO,IAAc,sBAChC,AAAgB,EAA0B,GAAgB,KAC1D,AAAO,cApDP,EAAqB,AAAC,KAAqB,AAAC,MAAc,UAqN5D,AAAI,AAAC,KAAK,EACV,AAAU,AAAmB,EAAM,KACnC,AAAI,GACJ,AAAI,IAAa,MACf,IACA,AAAE,eAhKJ,AAAU,KACV,IAAO,EAAM,UACX,AAAQ,AAAY,KAAM,IAC1B,EAAO,aAxDP,AAAO,EAAkB,KAAc,AAAC,qDFyJ1C,AAAgB,OACZ,GAAO,AAAO,EAAY,sBAC9B,AAAW,EAAY,AAAC,QACpB,GAAO,AAAO,EAAQ,sBAI1B,AAAI,EAAO,MACT,AAAK,IACL,AAAK,AAAM,EAAQ,MAGnB,AAAkB,AAAI,IAAM,gBAC5B,AAAK,EAAM,AAAW,MACtB,AAAK,AAAO,EAAgB,EAAK,IAAa,EAAK,MACnD,EAAM,EAAU,OAEd,GAAO,AAAO,EAAK,KAAW,EAAK,0BAGvC,AAAW,OACX,AAAW,OACX,AAAI,IAAM,EAAY,KACtB,AAAI,IAAM,EAAY,KAGtB,AAAI,EAAS,EAAQ,IAAM,IAAI,IAjI/B,AACE,EAA2B,AAAC,AAAC,EAAM,GAAW,GAAc,WAiI5D,EAAQ,IAAM,IAAI,IAAI,IAzHxB,AACE,EAA2B,AAAC,AAAC,EAAM,GAAW,GAAc,IAC5D,MA0HA,AAAI,AAAC,KACH,AAAY,EAAM,IAAM,IAzJ5B,AACE,EAA2B,EAAM,UAyJ/B,EAAM,IAAM,IAAI,EAAS,AAAE,EAAK,WAjJpC,AACE,EAA2B,EAAM,IACjC,MAkJE,AAAI,AAAC,KAAO,OAAc,AAAE,EAAK,kBArGjC,GAAO,AAAO,qBAClB,AAAgB,OACZ,GAAO,AAAO,EAAY,sBAE9B,AAAY,EAAS,wBACrB,AAAgB,OAGhB,AAAI,EAAY,KACd,AAAY,EAAM,IAClB,EAAe,AAAY,EAAY,GAAkB,EAAY,AAAC,WACtE,AAAQ,EAAS,IAnHnB,AAAyB,EAA2B,GAAkB,KAAe,AAAC,UAoHpF,AAAY,QAKd,AAAI,EAAY,KACd,AAAW,EAAY,IAhIzB,AAAmB,EAA2B,SAiI5C,AAAe,OACX,GAAO,AAAO,EAAW,sBAC7B,AAAY,EAAM,IAClB,AAAQ,IACR,EAAe,AAAY,EAAW,GAAkB,EAAY,AAAC,YAIvE,EAAe,EAAY,KAI3B,AAAW,EAAY,AAAC,QACpB,GAAO,AAAO,EAAQ,sBACtB,GAAO,AAAO,EAA2B,GAAiB,GAAQ,sBAGtE,AAAa,EAA2B,GAAiB,KAIzD,AAAI,EAAO,MACT,AAAK,IACL,AAAK,AAAM,EAAQ,MAGnB,AAAkB,AAAI,IAAM,gBAC5B,AAAK,EAAM,AAAW,MACtB,AAAK,AAAO,EAAgB,EAAK,IAAa,EAAK,MACnD,EAAM,EAAU,OAEd,GAAO,AAAO,EAAK,KAAW,EAAK,0BAGvC,AAAW,EAAQ,IAAM,IAAI,IA1F7B,AACE,EAA2B,AAAC,AAAC,EAAM,GAAW,GAAc,UA0F9D,EAAa,IACb,EAAa,IACb,AAAI,IAAM,EAAY,KACtB,EAAQ,IAAM,IAAI,IAAI,IArFtB,AACE,EAA2B,AAAC,AAAC,EAAM,GAAW,GAAc,IAC5D,MAsFF,OAAe,EAAK,MACpB,EAAM,IAAM,IAAI,EAAM,IAAM,IArH5B,AACE,EAA2B,EAAM,QAoHA,EAAK,MA5GxC,AACE,EAA2B,EAAM,IACjC,YA6NE,GAAO,AAAO,EAAS,sBAC3B,AAAQ,AAAC,AAAC,EAAQ,GAAiB,GAAW,AAAC,MAAW,KAC1D,EAAO,AAAC,QAER,AAAW,EAAQ,IAtMnB,AACE,SAsMF,AAAsB,IACtB,AAAI,IACE,GAAO,AAAO,EAAS,EAA0B,uBAIrD,AAAI,EAAQ,GAAgB,KAC1B,EAAS,KACT,AAAW,WAMJ,GAAO,AACT,EAAS,EAA0B,yBAI5C,AAAW,EAAM,KACjB,AAAI,EAAO,EAAiB,GAAgB,MAC1C,AAAO,IAIT,AAAe,EAAO,EAAI,MAC1B,AAAW,IACX,EAAc,EAAW,GAAQ,EAAW,MAC5C,EAAY,IACZ,EAAY,IAGZ,AAAO,AAAkB,EAAQ,GAAiB,KAClD,EAAc,EAAI,KAClB,EAAQ,IAAM,IAhOd,AACE,EACA,OAgOF,AAAY,EAAM,IAElB,QA4CA,AAAI,GACJ,AAAiB,AAAC,GAAc,GAAW,AAAC,QAC5C,AAAkB,IAClB,AAAkB,AAAO,AAAC,AAAC,EAAa,IAAa,KAAU,AAAC,QAAY,KAC5E,AAAI,EAAc,KAAe,AAAY,EAAc,KAAe,SAAG,EAC7E,AAAW,IACX,EAAa,IACb,EAAQ,IAAM,aACT,AAAgB,QAAG,EAAK,aACrB,IAAM,IAAI,kBACX,AAAc,QAAG,EAAK,aACjB,IAAM,IAAI,IAAI,yBADY,AAAE,aAFF,AAAE,YAMxC,AAAe,EAAa,MACxB,GAIG,AACK,EAAM,EAAU,EAAiB,MAE7C,AAAO,UAwEP,AAAY,AAAkB,EAAM,KACpC,AACE,EAAO,KAAK,AAAE,EAAM,UACpB,AAAE,KAAe,2BAEnB,KAZA,AAAI,GACJ,EAAe,KAAe,KAC9B,AAAY,EAAM,OAiClB,AAAI,EAAM,MAAa,EACvB,AAAI,AAAC,MAAM,GACX,AAAU,GAAM,AAAe,SEzV/B,AAAI,EAAyB,MAC3B,EAAoB,IACpB,EAAW,KAEX,GAAS,QACT,AAAI,GAGJ,AAAO,EAAyB,YAtElC,QAAQ,OACD,OAOA,OAmCA,QA1CY,EACf,AAAQ,KACR,AAAa,KACb,AAAW,IACX,AAAO,MACP,AAAO,GAAa,OAEL,EACf,AAAY,AAAK,MACjB,AAAM,OACN,IAAO,EAAO,UACZ,AAAO,KACP,AAAI,IAAa,KACf,EAAY,IACZ,AAAa,KACb,AAAgB,EAAyB,GAAgB,KACzD,AAAO,GAAa,KAEtB,AAAM,WAER,AAAa,KACb,AAAW,IACX,AAAM,OACN,AAAI,EAAO,MACT,AAAW,IACX,AAAM,OACN,IAAO,EAAO,UACZ,AAAI,IAAa,KACf,EAAY,IACZ,AAAgB,EAAyB,GAAgB,MAE3D,AAAM,WAER,AAAW,KACX,AAAY,MACZ,AAAU,KACV,AAAQ,KACR,AAAO,OACP,AAAQ,MAEV,AAAO,GAAa,OAEJ,EAChB,AAAM,KACN,AAAI,EAAO,MACT,AAAO,OACH,GAAO,AAAO,IAAa,AAAK,wBACpC,AAAK,IACL,AAAO,IAET,GAAwB,KACxB,GAAe,KACf,AAAQ,KACR,KAGJ,OAgKA,AAAI,GACJ,AAAI,GACJ,AAAoB,GAAc,IAAa,MAC/C,IACE,EAAU,KACV,AAAI,GAAS,KACX,AAAI,GACJ,AAAY,AAAQ,IAAa,KAAa,KAAO,OACrD,AAAI,GACJ,EAEK,EAAS,OAClB,AAAI,GACJ,AAAY,GAAQ,GAAc,AAAM,GAAQ,IAAY,SAC5D,AAAI,MFuCJ,AAAO,EAAQ,KACX,GACA,AAAC,AAAC,EAAO,GAAiB,GAAW,AAAC,MAAW,OAKrD,AAAI,EAAO,SAAe,EAAgB,qBAC1C,AAAmB,UA/InB,AAAI,EAAO,MACT,AAAK,IACL,AAAK,AAAM,EAAQ,MAKnB,AAAkB,EAAO,SACrB,EAAQ,EAAM,EAAW,AAAW,MAAU,IAC9C,KACJ,AAAK,EAAM,AAAW,MACtB,AAAK,AAAO,EAAgB,EAAK,IAAa,EAAK,MACnD,EAAM,EAAU,OAEd,GAAO,AAAO,EAAK,KAAW,EAAK,0BAGvC,AAAY,EAAM,IAAM,gBAAO,AAAC,KAAK,MACrC,AAAyB,IACzB,AAAI,AAAC,KAEH,AAAY,KAAc,AAAC,KAAM,EAAK,OACtC,AAAI,AAAC,KACH,AAAO,KAEP,AAAK,AAAW,KAChB,AAAQ,EAAM,IAAM,IArMxB,AACE,EAA2B,EAAM,UAqM3B,GAAO,AAAO,qBAClB,AAAO,EAAQ,IAAM,IAAI,AAAS,2BAGpC,AAAO,EAAQ,IAAM,IAAI,AAAS,KAvLpC,AACE,EAA2B,AAAC,AAAC,EAAM,GAAW,GAAc,WAwL9D,QA4EA,AAAI,GAMJ,AAAI,EAAO,SAET,EAAQ,AAAC,EAAM,EAAW,AAAW,KAAU,OAIjD,AAAkB,IAClB,EAAQ,EAAkB,AAAM,AAAC,EAAsB,GAAM,GAAkB,EAA0B,IA/PzG,AACE,YA+PF,AAAkB,AAAO,AAAC,EAAO,KAAU,AAAC,QAAY,KACxD,AAAkB,AAAI,IAAa,YACnC,AAAI,AAAY,IAAe,KAC7B,AAAI,AAAY,IAAe,KAAG,GAEpC,AAAiB,IACjB,AAAU,EAAM,EAAsB,GAAI,EAAqB,YAzF/D,AAAgB,OACZ,GAAO,AAAO,AAAE,AAAC,EAAO,GAAkB,uBAG9C,AAAgB,AAAC,EAAY,AAAC,MAAa,KAC3C,AAAI,EAAa,EAAiB,MAChC,EAAe,EAAQ,EAAY,MAEnC,AAAY,AAAkB,EAA2B,GAAiB,KAC1E,EAAe,AAAC,EAAY,GAAkB,KAC9C,AAAY,EAAM,KAIlB,EAAe,EAAY,AAAC,QAC5B,EAAS,IAlRX,AAAyB,EAA2B,GAAkB,KAAe,AAAC,QAkRpF,2BAA0B,AAAC,cAwH7B,AAAkB,AAAY,MAC9B,AAAY,AAAY,EAAM,MAC9B,AAAI,AAAC,KACH,AAAW,EAAM,IACjB,AAAQ,AAA8B,EAAM,MACxC,GAAO,AAAO,sBAEhB,GAAO,AAAO,AAAC,KAAe,AAAC,MAAc,sBACjD,AAAY,EAAM,IAClB,AAAa,EAAM,EAAc,IACjC,AAAI,GACJ,KAmEA,AAAI,AAAC,MAAM,GACX,AAAO,AAAgC,GAAM,IAAS,4BEtTtD,AAAI,EAAQ,SAAgB,EAAgB,qBAC5C,AAAI,GAAS,MAAW,GACxB,AAAU,AAAmB,AAAQ,EAAkB,KAAQ,KAC/D,EAAW,IACX,EAAa,IACb,EAAW,GAAW,KACtB,GAAS,QACT,AAAU,EAAyB,KAEnC,AAAY,EAAK,EAAG,KACpB,4Bc3PoB,KACA,+hDAoDlB,AAAI,EAAmB,AAAK,QAAiB,EAAqB,qBAClE,AAAgB,KAAiB,SR6DnC,AAAI,EAAQ,OACV,AAAI,EAAQ,MACV,AAAO,EAAI,AAAI,EAAS,MAExB,AAAO,EAAI,AAAI,EAAS,MAAS,AAAI,EAAS,SAGhD,AAAI,EAAQ,QACV,AAAO,EAAI,AAAI,EAAS,QAExB,AAAO,EAAI,AAAI,EAAS,QAAc,AAAI,EAAS,oBAyCvD,IAAO,EAAO,WAEZ,AAAQ,EAAM,OACd,AAAQ,EAAM,OACd,AAAM,IAEN,AAAS,EAAI,MACb,AAAS,EAAI,MAEb,AAAc,AAAe,KAAU,EAAa,SACpD,AAAc,AAAe,KAAU,EAAa,SAEpD,EAAU,KACV,AAAW,EAAU,EAAU,IAAI,EAAW,EAAW,YAG3D,AAAI,EAAO,MACT,AAAS,EAAM,MACf,AAAS,EAAM,MACf,AAAM,IACN,EAAU,KACV,AAAa,AAAU,KAAU,EAAa,SAC9C,AAAW,EAAU,EAAU,IAAI,MAGrC,AAAI,EAAO,KACT,EAAU,KACV,AAAa,AAAU,KAAU,EAAc,SAC/C,AAAW,EAAU,EAAU,IAAI,MAEnC,EAAU,KACV,AAAY,EAAc,KAC1B,AAAW,EAAU,EAAU,IAAI,WAoCrC,IAAO,EAAU,SACf,EAAU,KACV,AACE,EAAU,EAAU,IACpB,AAAU,KAAO,AAAC,GAAa,IAAS,UAE1C,EAAQ,UAEV,AAAI,EAAS,KACX,AAAW,EAAQ,AAAU,KAAO,GAAc,mBA9FpD,AAAI,EAAW,IAxCf,AAAO,AAAU,GAAU,MAyCzB,AAAO,AAAC,EAAK,AAAS,KAAS,EAAK,AAAS,KAAS,KAE9C,KAAe,IAAc,IACvC,IAAO,EAAO,SACZ,EAAO,KACP,EAAK,KACL,EAAM,UAER,IAAO,EAAO,SACZ,EAAO,KACP,YAEF,AAAO,EAAI,SAoJX,AAAW,KACX,AAAI,AAAC,EAAS,EAAQ,IAAO,KAC3B,AAAY,AAAI,AAAI,GAAS,MAC7B,AAAW,EAAO,KAClB,IACE,OACA,AAAW,EAAU,EAAU,IAAI,AAAU,KAAO,AAAM,EAAM,IAAS,UACzE,EAAQ,KACD,YAGP,OACA,AAAQ,EAAM,KACd,AAAW,EAAU,EAAU,IAAI,AAAU,KAAO,AAAM,EAAM,EAAI,KAAS,UAC7E,AAAM,IACC,Ya5QT,AAAc,EAAM,QC8DpB,AAAS,EAA2B,EAAgB,IAAe,KAC/D,GAAgB,AACX,EAAyB,EAA0B,OAvC5D,AAAO,AAAmB,EAA0B,MAA2B,MA0Q/E,AAAI,GACJ,AAAI,GACJ,AAAI,GACA,EAAmB,IAAG,EACpB,GAAgB,AAAO,AAAgB,EAAyB,KAAa,WNrWnF,AAAa,KAAiB,AAAkB,2jBdsQlD,AAAa,AAAmB,EAAS,KAEzC,AAAI,EAAQ,AAAC,KAAgB,AAAC,MAAK,MACjC,EAAgB,IAChB,AAAO,IAIT,AAAa,AAAM,EAAM,SACzB,AAAY,EAAQ,EAAQ,AAAI,IAAM,iBACtC,KW2dI,AAAoB,EAAwB,IAAgB,QQrkB9D,AAAc,EAAM,WEnKtB,AAAkB,AAAO,OACzB,AAAI,EAAU,EAAgB,MAC5B,AAAI,EAAU,MAAkB,MAAW,EAAqB,oBAChE,AAAc,AAAkB,OAGhC,AAAkB,AAAI,IAAS,UAAa,KAC5C,AAAI,IAAS,AAAc,AAAI,AAAI,EAAe,KAAG,gBAAgB,aACrE,AAAc,AAAQ,EAAS,OAG/B,AAAI,EAAe,KAGnB,AAAI,EAAW,KACb,AAAa,EAAO,KACpB,AAAa,EAAO,KACpB,AAAO,EAAO,EAA4B,KAE5C,AAAW,EAAO,WA+LlB,AAAa,OACb,AAAU,EAAS,KACnB,AAAe,EAAyB,EAAK,EAtNqC,KAuN9E,GAAgB,EAClB,AAAa,KAAkB,EAAiB,IAAe,KAC/D,AAAO,EAAyB,EAA0B,KAI5D,EAAe,KACf,yLAVA,AAAa,OACb,AAAU,EAAS,KACnB,AAAe,EAAyB,EAAK,EAtNqC,KAuN9E,GAAgB,EAClB,AAAa,KAAkB,EAAiB,IAAe,KAC/D,AAAO,EAAyB,EAA0B,KAI5D,EAAe,KACf,QC3OE,GAAe,AACV,EAAQ,IAqEjB,AAAI,EAA0B,KAAG,AAAO,KAExC,AAAa,IAAc,KAC3B,AAAiB,IACjB,AAAU,IAEV,AAAI,EAAO,KACT,AAAS,EAAa,OAAW,SACjC,AAAS,EAAa,SACtB,AAAS,IACT,AAAS,EAAa,SAEtB,AAAU,EAAM,GAAM,KACtB,IAAO,EAAO,SACZ,AAAK,EAAI,IAAI,AAAU,gCACvB,AAAK,EAAI,IAAI,AAAU,gCACvB,AAAK,EAAI,IAAI,AAAU,gCACvB,AAAK,EAAI,IAAI,AAAU,OAvB3B,AAAO,AAAK,EAAI,EAAM,QAAU,GAAM,UAwBlC,EAAO,UAET,EAAK,AAAK,EAAI,GAAK,AAAK,EAAI,IAAK,AAAK,EAAI,IAAM,AAAK,EAAI,QAEzD,EAAK,EAAa,WAGpB,AAAU,EAAyB,GAAM,KACzC,IAAO,EAAO,SACZ,EAAK,AAAU,KAAO,UACtB,AAAI,AAAK,EAAG,GAAM,SAClB,EAAO,UAGT,AAAM,EAAyB,KAC/B,IAAO,EAAM,SACX,EAAK,AAAc,KAAO,UAC1B,AAAI,AAAK,EAAG,GAAM,SAClB,YAGF,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,yEC+CE,AAAyB,AAAM,EAAiB,QAC/B,EAAgB,EAAqB,WACtD,AAAyB,EAAqB,GAAgB,QAC7C,EAAgB,EAAqB,cAGtD,AAAa,AAAkB,OAC/B,AAAa,EAAS,AAAO,KAAqB,SAClD,AAAa,IACb,IAAO,EAAU,SACf,AAAe,IACf,AAAI,AAAE,KAAsB,MAC1B,AAAe,OACG,UAClB,EAAe,KACf,EAAiB,QACjB,AAAqB,AAAQ,KAAe,KAC5C,AAAuB,EAAgC,EAAwB,MAC/E,EAAsB,AAAY,QAClC,AAAa,EAAkB,KAC/B,EAAU,SAEZ,EAAU,EAnId,WAsIE,EAAe,KACf,EAAmB,KACnB,EAAe,KACf,EAAuB,KACvB,EAAqB,u5BA7BrB,AAAyB,AAAM,EAAiB,QAC/B,EAAgB,EAAqB,WACtD,AAAyB,EAAqB,GAAgB,QAC7C,EAAgB,EAAqB,cAGtD,AAAa,AAAkB,OAC/B,AAAa,EAAS,AAAO,KAAqB,SAClD,AAAa,IACb,IAAO,EAAU,SACf,AAAe,IACf,AAAI,AAAE,KAAsB,MAC1B,AAAe,OACG,UAClB,EAAe,KACf,EAAiB,QACjB,AAAqB,AAAQ,KAAe,KAC5C,AAAuB,EAAgC,EAAwB,MAC/E,EAAsB,AAAY,QAClC,AAAa,EAAkB,KAC/B,EAAU,SAEZ,EAAU,EAnId,WAsIE,EAAe,KACf,EAAmB,KACnB,EAAe,KACf,EAAuB,KACvB,EAAqB,6PFtDrB,AAAS,KAAkB,EAAgB,IAAe,KAC1D,AAAI,MAVJ,AAAI,EAAc,AAAK,QACrB,AAAI,EAAQ,KAAG,EAAqB,qBACpC,AAAe,EAAyB,EAAQ,GAAG,EApH6B,KAqHhF,EAAe,EAAQ,OAEzB,EAAY,EAAO,s9ME6BnB,AAAyB,AAAM,EAAiB,QAC/B,EAAgB,EAAqB,WACtD,AAAyB,EAAqB,GAAgB,QAC7C,EAAgB,EAAqB,cAGtD,AAAa,AAAkB,OAC/B,AAAa,EAAS,AAAO,KAAqB,SAClD,AAAa,IACb,IAAO,EAAU,SACf,AAAe,IACf,AAAI,AAAE,KAAsB,MAC1B,AAAe,OACG,UAClB,EAAe,KACf,EAAiB,QACjB,AAAqB,AAAQ,KAAe,KAC5C,AAAuB,EAAgC,EAAwB,MAC/E,EAAsB,AAAY,QAClC,AAAa,EAAkB,KAC/B,EAAU,SAEZ,EAAU,EAnId,WAsIE,EAAe,KACf,EAAmB,KACnB,EAAe,KACf,EAAuB,KACvB,EAAqB,oiCLoNrB,AAAO,EAAQ,MACX,GACA,EAAQ,OACR,GACA,EAAQ,QACR,GACA,EAAQ,SACR,GACA,EAAQ,UACR,GACA,EAAQ,WACR,GACA,EAAQ,YACR,GACA,EAAQ,aACR,GACA,EAAQ,cACR,GACA,kBjBtRJ,AAAgB,IAEhB,EAAQ,KAAgB,KAAI,GAAI,EAAI,EAAoB,OiB8RxD,AAAsB,WjB7RtB,EAAQ,KAAc,KAAI,GAAI,EAAI,EAAoB,OiBwRtD,AAAsB,YjBtRtB,KoBjEA,AAAO,QEVP,AAAO,QFgEP,AAAS,KAAkB,EAAgB,IAAe,KACtD,GAAgB,AACX,EAAyB,EAA0B,OAX5D,AAAI,EAAc,AAAK,QACrB,AAAI,EAAQ,KAAG,EAAqB,qBACpC,AAAe,EAAyB,EAAQ,GAAG,EApH6B,KAqHhF,EAAe,EAAQ,OAEzB,EAAY,EAAO,QA9CnB,AAAe,EAAyB,EAAW,EAAc,KACjE,EAAe,UEef,AAAY,EAAU,EAAK,AAAQ,UACnC,AAAI,AAAC,KAAO,EAAgB,qBAC5B,AAAO,QFtBP,AAAO,UpBgmBT,AACE,IAAa,KAAI,EAAI,AAAuB,SAAc,MAAa,KACzE,AAAkB,OAElB,AAAI,EAAa,KACf,AAAO,IAGT,AAAO,EAAU,GAAI,AAAuB,OAAa,MsBlnBvD,AAAO,UA8BP,AAAY,EAAU,EAAK,AAAQ,UACnC,AAAI,AAAC,KAAO,EAAgB,qBAC5B,AAAO,QpBkrsBT,AACG,IAAa,KAAI,EAAI,AAAuB,SAAc,MAAa,GACvE,IAAe,KACZ,EAAI,AAAuB,SAAgB,MAC3C,OkB5ssBJ,AAAO,QEVP,AAAO,UA8BP,AAAY,EAAU,EAAK,AAAQ,UACnC,AAAI,AAAC,KAAO,EAAgB,qBAC5B,AAAO,UCmIT,AACE,IAAa,KAAI,EAAI,AAAuB,SAAc,MAAa,KACzE,AAAkB,OAElB,AAAI,EAAa,KACf,AAAO,IAGT,AAAO,EAAU,GAAI,AAAuB,OAAa,QHlBvD,AAAa,OACb,AAAU,EAAS,KACnB,AAAe,EAAyB,EAAK,EAtNqC,KAuN9E,GAGG,AACI,KAAkB,EAAiB,IAAe,KAE7D,EAAe,KACf,QVkbE,AAAa,IACb,AAAa,EAAS,AAAO,AAAmB,EAAyB,SACzE,AAAa,OACb,IAAO,EAAS,SACd,AAAS,AAAe,OACxB,AAAI,EAAK,MAEP,AAAI,EAAiB,AAAC,MAAI,GAC1B,EAAU,MACL,AAAI,EAAK,MACd,EAAU,MAEV,AAAI,AAAC,EAAK,KAAW,OAAU,EAAS,GAAI,SAC1C,AAAI,AAAC,AAAe,KAAa,KAAW,OAC1C,EAAU,KAAG,EAAU,KACvB,IAGJ,EAAU,OAEZ,EAAU,UAEZ,QAYA,AAAa,EAAO,EAAc,MAClC,AAAa,IACb,IAAO,EAAM,SACX,AAAS,AAAe,OACxB,AAAI,EAAK,MACP,AAAU,EAAQ,KAClB,OAEA,AAAI,EAAiB,AAAC,MAAI,AAAO,EAAS,MACrC,AAAI,EAAK,MACd,AAAS,EAAM,GAAI,MACnB,AAAS,EAAK,GAAK,MACnB,AAAW,EAAQ,EAAM,GAAI,MAC7B,EAAU,MAQV,AAAI,AAAC,EAAK,KAAW,OACnB,AAAI,EAAK,OAAU,EAAM,GAAI,SAC3B,AAAS,AAAe,OACxB,AAAI,AAAC,EAAK,KAAW,OACnB,AAAK,IAAW,AAAC,EAAK,IAAW,IAAO,EAAK,OAC7C,AAAS,EAAM,GAAK,MACpB,AAAS,EAAM,GAAK,GAAK,MACzB,AAAS,EAAM,GAAK,GAAK,MACzB,AAAS,EAAW,GAAK,MACzB,AAAW,EAAQ,EAAM,GAAK,EAAM,IAAK,EAAM,IAAI,MACnD,EAAU,KAAG,EAAO,KACpB,IAGJ,AAAI,EAAa,KACf,AAAI,EAAa,KAAiB,EAAgB,qBAClD,AAAK,QAGT,AAAS,EAAM,GAAK,MACpB,AAAS,EAAM,GAAK,GAAK,MACzB,AAAS,EAAW,GAAK,MACzB,AAAW,EAAQ,EAAM,GAAI,MAC7B,AAAU,EAAQ,KAClB,EAAU,OAEZ,EAAO,UAET,AAAI,IACF,AAAU,cAAU,MAEtB,AAAO,EAAS,6BA7DyC,KAA8B,mBUtkBzF,AAAI,EAAc,AAAK,QAAc,EAAqB,qBAC1D,AAAY,AAAQ,KAAkB,EAAgB,SACtD,AAAI,GAKJ,uBhB/CA,AAAuB,SLoQzB,AAAI,IACF,AAAU,AAAmB,EAAM,KACnC,AAAI,IAAa,KACC,mBAElB,IACA,EAAW,GAAU,KAEvB,OAMA,AAAI,AAAC,KAAK,EACV,AAAU,AAAmB,EAAM,KACnC,AAAI,IAAa,KACC,mBAElB,AAAI,GAAS,KAIX,KAEA,IACA,EAAW,GAAW,WAOxB,AAAI,GACJ,AAAI,GAAQ,OAEH,GAAS,SAAY,QAG9B,GACA,IAAO,GAAS,SAAY,QAC5B,AAAY,AAAQ,IAAa,KAAa,KAAO,OACrD,AAAI,GACJ,AAAI,ktDqB8JE,GAAgB,EAClB,AAAU,OACV,AAAU,EAAO,AAAO,KAAgB,MACxC,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,KACtB,EAAO,WAGX,AAAQ,AAAkB,KAAc,uKATpC,GAAgB,EAClB,AAAU,OACV,AAAU,EAAO,AAAO,KAAgB,MACxC,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,KACtB,EAAO,WAGX,AAAQ,AAAkB,KAAc,oBEtTxC,AAAQ,AAAkB,KAAe,IACzC,AAAc,AAAkB,OAC5B,GAAkC,EACpC,AAAU,IACV,AAAU,EAAM,AAAO,KAAqB,SAC5C,IAAO,EAAM,SACX,AAAY,IACZ,AAAI,AAAE,KAAmB,MACnB,GAAgB,EAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,KAElB,GAAgB,EAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,MAGxB,EAAO,EAzMb,YA4ME,AAAQ,EAAS,6lBAxBjB,AAAQ,AAAkB,KAAe,IACzC,AAAc,AAAkB,OAC5B,GAAkC,EACpC,AAAU,IACV,AAAU,EAAM,AAAO,KAAqB,SAC5C,IAAO,EAAM,SACX,AAAY,IACZ,AAAI,AAAE,KAAmB,MACnB,GAAgB,EAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,KAElB,GAAgB,EAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,MAGxB,EAAO,EAzMb,YA4ME,AAAQ,EAAS,0VFqRjB,AAAI,GASJ,AAAQ,AAAkB,KAAc,kqLEtTxC,AAAQ,AAAkB,KAAe,IACzC,AAAc,AAAkB,OAC5B,GAAkC,EACpC,AAAU,IACV,AAAU,EAAM,AAAO,KAAqB,SAC5C,IAAO,EAAM,SACX,AAAY,IACZ,AAAI,AAAE,KAAmB,MACnB,GAAgB,EAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,KAElB,GAAgB,EAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,MAGxB,EAAO,EAzMb,YA4ME,AAAQ,EAAS,miCHoIb,GAAgB,EAClB,AAAU,IACV,AAAU,EAAM,AAAmB,EAA0B,SAC7D,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,KACtB,EAAO","sourceRoot":"./test","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\n// │                          size                             │L│F│ ◄─┐ info   overhead\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │ >= 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - 2 * BLOCK_OVERHEAD;\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  var root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  var memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n  var blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  var newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  var block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's μgc, see: https://github.com/bullno1/ugc\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unprocessed                                     │\n// │ BLACK*      │ Processed                                       │\n// │ GRAY        │ Processed with unprocessed children             │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy var white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy var total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy var state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var iter: Object; // null\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    var rtId = this.rtId;\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    var next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    var prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  var pn = pinSpace;\n  var iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  var ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  var obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  var ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  var newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  var child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy var threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  var budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\"└ GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\"└ GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","import * as __proto from \"../__proto\";\n\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n *  calendar, encoded as a count of seconds and fractions of seconds at\n *  nanosecond resolution. The count is relative to an epoch at UTC midnight on\n *  January 1, 1970, in the proleptic Gregorian calendar which extends the\n *  Gregorian calendar backwards to year one.\n *\n *  All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n *  second table is needed for interpretation, using a [24-hour linear\n *  smear](https://developers.google.com/time/smear).\n *\n *  The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n *  restricting to that range, we ensure that we can convert to and from [RFC\n *  3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n *  # Examples\n *\n *  Example 1: Compute Timestamp from POSIX `time()`.\n *\n *      Timestamp timestamp;\n *      timestamp.set_seconds(time(NULL));\n *      timestamp.set_nanos(0);\n *\n *  Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *      struct timeval tv;\n *      gettimeofday(&tv, NULL);\n *\n *      Timestamp timestamp;\n *      timestamp.set_seconds(tv.tv_sec);\n *      timestamp.set_nanos(tv.tv_usec * 1000);\n *\n *  Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *      FILETIME ft;\n *      GetSystemTimeAsFileTime(&ft);\n *      UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *      // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *      // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *      Timestamp timestamp;\n *      timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *      timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n *  Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *      long millis = System.currentTimeMillis();\n *\n *      Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *          .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n *\n *  Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *      Instant now = Instant.now();\n *\n *      Timestamp timestamp =\n *          Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *              .setNanos(now.getNano()).build();\n *\n *\n *  Example 6: Compute Timestamp from current time in Python.\n *\n *      timestamp = Timestamp()\n *      timestamp.GetCurrentTime()\n *\n *  # JSON Mapping\n *\n *  In JSON format, the Timestamp type is encoded as a string in the\n *  [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n *  format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n *  where {year} is always expressed using four digits while {month}, {day},\n *  {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n *  seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n *  are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n *  is required. A proto3 JSON serializer should always use UTC (as indicated by\n *  \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n *  able to accept both UTC and other timezones (as indicated by an offset).\n *\n *  For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n *  01:30 UTC on January 15, 2017.\n *\n *  In JavaScript, one can convert a Date object to this format using the\n *  standard\n *  [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n *  method. In Python, a standard `datetime.datetime` object can be converted\n *  to this format using\n *  [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n *  the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n *  the Joda Time's [`ISODateTimeFormat.dateTime()`](\n *  http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D\n *  ) to obtain a formatter capable of generating timestamps in this format.\n */\nexport class Timestamp {\n  /**\n   * Represents seconds of UTC time since Unix epoch\n   *  1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   *  9999-12-31T23:59:59Z inclusive.\n   */\n  public seconds: i64;\n  /**\n   * Non-negative fractions of a second at nanosecond resolution. Negative\n   *  second values with fractions must still have non-negative nanos values\n   *  that count forward in time. Must be from 0 to 999,999,999\n   *  inclusive.\n   */\n  public nanos: i32;\n\n  // Decodes Timestamp from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Timestamp {\n    return Timestamp.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Timestamp from a DataView\n  static decodeDataView(view: DataView): Timestamp {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Timestamp();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.seconds = decoder.int64();\n          break;\n        }\n        case 2: {\n          obj.nanos = decoder.int32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Timestamp\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.seconds == 0 ? 0 : 1 + __proto.Sizer.int64(this.seconds);\n    size += this.nanos == 0 ? 0 : 1 + __proto.Sizer.int32(this.nanos);\n\n    return size;\n  }\n\n  // Encodes Timestamp to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Timestamp to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.seconds != 0) {\n      encoder.uint32(0x8);\n      encoder.int64(this.seconds);\n    }\n    if (this.nanos != 0) {\n      encoder.uint32(0x10);\n      encoder.int32(this.nanos);\n    }\n\n    return buf;\n  } // encode Timestamp\n} // Timestamp\n\n/**\n * `NullValue` is a singleton enumeration to represent the null value for the\n *  `Value` type union.\n *\n *   The JSON representation for `NullValue` is JSON `null`.\n */\nexport enum NullValue {\n  // Null value.\n  NULL_VALUE = 0,\n} // NullValue\n/**\n * `Struct` represents a structured data value, consisting of fields\n *  which map to dynamically typed values. In some languages, `Struct`\n *  might be supported by a native representation. For example, in\n *  scripting languages like JS a struct is represented as an\n *  object. The details of that representation are described together\n *  with the proto support for the language.\n *\n *  The JSON representation for `Struct` is JSON object.\n */\nexport class Struct {\n  // Unordered map of dynamically typed values.\n  public fields: Map<string, Value> = new Map<string, Value>();\n\n  // Decodes Struct from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Struct {\n    return Struct.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Struct from a DataView\n  static decodeDataView(view: DataView): Struct {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Struct();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          __decodeMap_string_Value(decoder, length, obj.fields);\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Struct\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.fields.size > 0) {\n      const keys = this.fields.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.fields.get(key);\n        const itemSize = __sizeMapEntry_string_Value(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes Struct to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Struct to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.fields.size > 0) {\n      const keys = this.fields.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.fields.get(key);\n        const size = __sizeMapEntry_string_Value(key, value);\n        if (size > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n\n          const messageSize = value.size();\n\n          if (messageSize > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(messageSize);\n            value.encodeU8Array(encoder);\n          }\n        }\n      }\n    }\n\n    return buf;\n  } // encode Struct\n\n  // Returns struct field by name. If field does not exists, it gets created and added to the fields collection.\n  get(name: string): Value {\n    if (this.fields.has(name)) {\n      return this.fields.get(name);\n    }\n\n    const v = new Value();\n    v.setNull();\n    this.fields.set(name, v);\n    return v;\n  }\n} // Struct\n\n/**\n * `Value` represents a dynamically typed value which can be either\n *  null, a number, a string, a boolean, a recursive struct value, or a\n *  list of values. A producer of value is expected to set one of that\n *  variants, absence of any variant indicates an error.\n *\n *  The JSON representation for `Value` is JSON value.\n */\nexport class Value {\n  // Represents a null value.\n  public null_value: u32;\n  // Represents a double value.\n  public number_value: f64;\n  // Represents a string value.\n  public string_value: string = \"\";\n  // Represents a boolean value.\n  public bool_value: bool;\n  // Represents a structured value.\n  public struct_value: Struct | null;\n  // Represents a repeated `Value`.\n  public list_value: ListValue | null;\n\n  public __kind: string = \"\";\n  public __kind_index: u8 = 0;\n\n  static readonly KIND_NULL_VALUE_INDEX: u8 = 1;\n  static readonly KIND_NUMBER_VALUE_INDEX: u8 = 2;\n  static readonly KIND_STRING_VALUE_INDEX: u8 = 3;\n  static readonly KIND_BOOL_VALUE_INDEX: u8 = 4;\n  static readonly KIND_STRUCT_VALUE_INDEX: u8 = 5;\n  static readonly KIND_LIST_VALUE_INDEX: u8 = 6;\n\n  // Decodes Value from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Value {\n    return Value.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Value from a DataView\n  static decodeDataView(view: DataView): Value {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Value();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.null_value = decoder.uint32();\n          obj.__kind = \"null_value\";\n          obj.__kind_index = 1;\n          break;\n        }\n        case 2: {\n          obj.number_value = decoder.double();\n          obj.__kind = \"number_value\";\n          obj.__kind_index = 2;\n          break;\n        }\n        case 3: {\n          obj.string_value = decoder.string();\n          obj.__kind = \"string_value\";\n          obj.__kind_index = 3;\n          break;\n        }\n        case 4: {\n          obj.bool_value = decoder.bool();\n          obj.__kind = \"bool_value\";\n          obj.__kind_index = 4;\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.struct_value = Struct.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.__kind = \"struct_value\";\n          obj.__kind_index = 5;\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.list_value = ListValue.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.__kind = \"list_value\";\n          obj.__kind_index = 6;\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Value\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.null_value == 0 ? 0 : 1 + __proto.Sizer.uint32(this.null_value);\n    size += this.number_value == 0 ? 0 : 1 + 8;\n    size +=\n      this.string_value.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.string_value.length) +\n          this.string_value.length\n        : 0;\n    size += this.bool_value == 0 ? 0 : 1 + 1;\n\n    if (this.struct_value != null) {\n      const f: Struct = this.struct_value as Struct;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.list_value != null) {\n      const f: ListValue = this.list_value as ListValue;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes Value to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Value to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.null_value != 0) {\n      encoder.uint32(0x8);\n      encoder.uint32(this.null_value);\n    }\n    if (this.number_value != 0) {\n      encoder.uint32(0x11);\n      encoder.double(this.number_value);\n    }\n    if (this.string_value.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.string_value.length);\n      encoder.string(this.string_value);\n    }\n    if (this.bool_value != 0) {\n      encoder.uint32(0x20);\n      encoder.bool(this.bool_value);\n    }\n\n    if (this.struct_value != null) {\n      const f = this.struct_value as Struct;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.list_value != null) {\n      const f = this.list_value as ListValue;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode Value\n\n  // Sets field value\n  set<T>(value: T): Value {\n    this.setNull();\n    this.null_value = 0;\n\n    if (isBoolean<T>(value)) {\n      this.bool_value = value;\n    } else if (isInteger<T>(value) || isFloat<T>(value)) {\n      this.number_value = value;\n    } else if (isString<T>(value)) {\n      this.string_value = value;\n    } else if (value instanceof Struct) {\n      this.struct_value = value;\n    } else if (value instanceof Value) {\n      this.null_value = value.null_value;\n      this.number_value = value.number_value;\n      this.string_value = value.string_value;\n      this.struct_value = value.struct_value;\n      this.list_value = value.list_value;\n    } else if (isArray(value)) {\n      const v = new ListValue();\n      for (let i: i32 = 0; i < value.length; i++) {\n        v.values.push(new Value().set(value[i]));\n      }\n      this.list_value = v;\n    }\n\n    return this;\n  }\n\n  // Sets field value to null\n  setNull(): void {\n    this.null_value = 1;\n    this.bool_value = false;\n    this.string_value = \"\";\n    this.struct_value = null;\n    this.list_value = null;\n  }\n} // Value\n\n/**\n * `ListValue` is a wrapper around a repeated field of values.\n *\n *  The JSON representation for `ListValue` is JSON array.\n */\nexport class ListValue {\n  // Repeated field of dynamically typed values.\n  public values: Array<Value> = new Array<Value>();\n\n  // Decodes ListValue from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ListValue {\n    return ListValue.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ListValue from a DataView\n  static decodeDataView(view: DataView): ListValue {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ListValue();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.values.push(\n            Value.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ListValue\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.values.length; n++) {\n      const messageSize = this.values[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ListValue to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ListValue to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.values.length; n++) {\n      const messageSize = this.values[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.values[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ListValue\n} // ListValue\n\n// __decodeMap_string_Value\n\nfunction __decodeMap_string_Value(\n  parentDecoder: __proto.Decoder,\n  length: i32,\n  map: Map<string, Value>\n): void {\n  const decoder = new __proto.Decoder(\n    new DataView(\n      parentDecoder.view.buffer,\n      parentDecoder.pos + parentDecoder.view.byteOffset,\n      length\n    )\n  );\n\n  let key: string = \"\";\n  let value: Value = new Value();\n\n  while (!decoder.eof()) {\n    const tag = decoder.tag();\n    const number = tag >>> 3;\n\n    switch (number) {\n      case 1: {\n        key = decoder.string();\n        break;\n      }\n\n      case 2: {\n        const length = decoder.uint32();\n        value = Value.decodeDataView(\n          new DataView(\n            decoder.view.buffer,\n            decoder.pos + decoder.view.byteOffset,\n            length\n          )\n        );\n        decoder.skip(length);\n\n        break;\n      }\n\n      default:\n        decoder.skipType(tag & 7);\n        break;\n    }\n  }\n  map.set(key as string, value as Value);\n}\n\n// __sizeMapEntry_string_Value\n\nfunction __sizeMapEntry_string_Value(key: string, value: Value): u32 {\n  const keySize =\n    key.length > 0 ? 1 + __proto.Sizer.varint64(key.length) + key.length : 0;\n  const valueSize = value.size();\n\n  if (valueSize == 0) {\n    return keySize;\n  }\n\n  return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;\n}\n","import * as __proto from \"./__proto\";\n\nimport * as google from \"./google\";\nimport * as wrappers from \"./wrappers\";\n/**\n * DatabaseTLSMode represents the level of TLS verification performed by\n *  DB agent when connecting to a database.\n */\nexport enum DatabaseTLSMode {\n  // VERIFY_FULL performs full certificate validation.\n  VERIFY_FULL = 0,\n  // VERIFY_CA works the same as VERIFY_FULL, but it skips the hostname check.\n  VERIFY_CA = 1,\n  // INSECURE accepts any certificate provided by server. This is the least secure option.\n  INSECURE = 2,\n} // DatabaseTLSMode\n// PrivateKeyType is the storage type of a private key.\nexport enum PrivateKeyType {\n  // RAW is a plaintext private key.\n  RAW = 0,\n  // PKCS11 is a private key backed by a PKCS11 device such as HSM.\n  PKCS11 = 1,\n} // PrivateKeyType\n// ProxyListenerMode represents the cluster proxy listener mode.\nexport enum ProxyListenerMode {\n  /**\n   * Separate is the proxy listener mode indicating that proxies are running\n   *  in separate listener mode where Teleport Proxy services use different listeners.\n   */\n  Separate = 0,\n  /**\n   * Multiplex is the proxy listener mode indicating the proxy should use multiplex mode\n   *  where all proxy services are multiplexed on a single proxy port.\n   */\n  Multiplex = 1,\n} // ProxyListenerMode\n// RoutingStrategy determines the strategy used to route to nodes.\nexport enum RoutingStrategy {\n  // UnambiguousMatch only routes to distinct nodes.\n  UNAMBIGUOUS_MATCH = 0,\n  // MostRecent routes to the most recently heartbeated node if duplicates are present.\n  MOST_RECENT = 1,\n} // RoutingStrategy\n// UserTokenUsage contains additional information about the intended usage of a user token.\nexport enum UserTokenUsage {\n  // Default value that implies token usage was not set.\n  USER_TOKEN_USAGE_UNSPECIFIED = 0,\n  // USER_TOKEN_RECOVER_PASSWORD is a request to recover password.\n  USER_TOKEN_RECOVER_PASSWORD = 1,\n  // USER_TOKEN_RECOVER_MFA is a request to recover a MFA.\n  USER_TOKEN_RECOVER_MFA = 2,\n  /**\n   * USER_TOKEN_RENEWAL_BOT is a request to generate certificates\n   *  for a bot user.\n   */\n  USER_TOKEN_RENEWAL_BOT = 3,\n} // UserTokenUsage\n// RequestState represents the state of a request for escalated privilege.\nexport enum RequestState {\n  /**\n   * NONE variant exists to allow RequestState to be explicitly omitted\n   *  in certain circumstances (e.g. in an AccessRequestFilter).\n   */\n  NONE = 0,\n  // PENDING variant is the default for newly created requests.\n  PENDING = 1,\n  /**\n   * APPROVED variant indicates that a request has been accepted by\n   *  an administrating party.\n   */\n  APPROVED = 2,\n  /**\n   * DENIED variant indicates that a request has been rejected by\n   *  an administrating party.\n   */\n  DENIED = 3,\n} // RequestState\n// CertExtensionMode specifies the type of extension to use in the cert.\nexport enum CertExtensionMode {\n  /**\n   * EXTENSION represents a cert extension that may or may not be\n   *  honored by the server.\n   */\n  EXTENSION = 0,\n} // CertExtensionMode\n/**\n * CertExtensionType represents the certificate type the extension is for.\n *  Currently only ssh is supported.\n */\nexport enum CertExtensionType {\n  // SSH is used when extending an ssh certificate\n  SSH = 0,\n} // CertExtensionType\n// SessionState represents the state of a session.\nexport enum SessionState {\n  /**\n   * Pending variant represents a session that is waiting on participants to fulfill the criteria\n   *  to start the session.\n   */\n  SessionStatePending = 0,\n  /**\n   * Running variant represents a session that has had it's criteria for starting\n   *  fulfilled at least once and has transitioned to a RUNNING state.\n   */\n  SessionStateRunning = 1,\n  // Terminated variant represents a session that is no longer running and due for removal.\n  SessionStateTerminated = 2,\n} // SessionState\nexport class KeepAlive {\n  // Name of the resource to keep alive.\n  public Name: string = \"\";\n  // Namespace is the namespace of the resource.\n  public Namespace: string = \"\";\n  // LeaseID is ID of the lease.\n  public LeaseID: i64;\n  // Expires is set to update expiry time of the resource.\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  public Type: u32;\n  // HostID is an optional UUID of the host the resource belongs to.\n  public HostID: string = \"\";\n\n  // Decodes KeepAlive from an ArrayBuffer\n  static decode(buf: ArrayBuffer): KeepAlive {\n    return KeepAlive.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes KeepAlive from a DataView\n  static decodeDataView(view: DataView): KeepAlive {\n    const decoder = new __proto.Decoder(view);\n    const obj = new KeepAlive();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Namespace = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.LeaseID = decoder.int64();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 9: {\n          obj.Type = decoder.uint32();\n          break;\n        }\n        case 10: {\n          obj.HostID = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode KeepAlive\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.Namespace.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Namespace.length) +\n          this.Namespace.length\n        : 0;\n    size += this.LeaseID == 0 ? 0 : 1 + __proto.Sizer.int64(this.LeaseID);\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += this.Type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Type);\n    size +=\n      this.HostID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.HostID.length) + this.HostID.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes KeepAlive to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes KeepAlive to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.Namespace.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Namespace.length);\n      encoder.string(this.Namespace);\n    }\n    if (this.LeaseID != 0) {\n      encoder.uint32(0x18);\n      encoder.int64(this.LeaseID);\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Type != 0) {\n      encoder.uint32(0x48);\n      encoder.uint32(this.Type);\n    }\n    if (this.HostID.length > 0) {\n      encoder.uint32(0x52);\n      encoder.uint32(this.HostID.length);\n      encoder.string(this.HostID);\n    }\n\n    return buf;\n  } // encode KeepAlive\n} // KeepAlive\n\n/**\n * Type is the type of keep alive, used by servers. At the moment only\n *  \"node\", \"app\" and \"database\" are supported.\n */\nexport enum KeepAlive_KeepAliveType {\n  UNKNOWN = 0,\n  NODE = 1,\n  APP = 2,\n  DATABASE = 3,\n  WINDOWS_DESKTOP = 4,\n  KUBERNETES = 5,\n} // KeepAlive_KeepAliveType\n/**\n * ServerV2List is a list of servers.\n *  DELETE IN 8.0.0 only used in deprecated GetNodes rpc\n */\nexport class Metadata {\n  // Name is an object name\n  public Name: string = \"\";\n  /**\n   * Namespace is object namespace. The field should be called \"namespace\"\n   *  when it returns in Teleport 2.4.\n   */\n  public Namespace: string = \"\";\n  // Description is object description\n  public Description: string = \"\";\n  // Labels is a set of labels\n  public Labels: Map<string, string> = new Map<string, string>();\n  /**\n   * Expires is a global expiry time header can be set on any resource in the\n   *  system.\n   */\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // ID is a record ID\n  public ID: i64;\n\n  // Decodes Metadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Metadata {\n    return Metadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Metadata from a DataView\n  static decodeDataView(view: DataView): Metadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Metadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Namespace = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Description = decoder.string();\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.Labels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          obj.ID = decoder.int64();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Metadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.Namespace.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Namespace.length) +\n          this.Namespace.length\n        : 0;\n    size +=\n      this.Description.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Description.length) +\n          this.Description.length\n        : 0;\n\n    if (this.Labels.size > 0) {\n      const keys = this.Labels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Labels.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += this.ID == 0 ? 0 : 1 + __proto.Sizer.int64(this.ID);\n\n    return size;\n  }\n\n  // Encodes Metadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Metadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.Namespace.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Namespace.length);\n      encoder.string(this.Namespace);\n    }\n    if (this.Description.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Description.length);\n      encoder.string(this.Description);\n    }\n\n    if (this.Labels.size > 0) {\n      const keys = this.Labels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Labels.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0x2a);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.ID != 0) {\n      encoder.uint32(0x38);\n      encoder.int64(this.ID);\n    }\n\n    return buf;\n  } // encode Metadata\n} // Metadata\n\n/**\n * CommandLabelV2 is a label that has a value as a result of the\n *  output generated by running command, e.g. hostname\n */\nexport class Rotation {\n  // State could be one of \"init\" or \"in_progress\".\n  public State: string = \"\";\n  // Phase is the current rotation phase.\n  public Phase: string = \"\";\n  // Mode sets manual or automatic rotation mode.\n  public Mode: string = \"\";\n  /**\n   * CurrentID is the ID of the rotation operation\n   *  to differentiate between rotation attempts.\n   */\n  public CurrentID: string = \"\";\n  /**\n   * Started is set to the time when rotation has been started\n   *  in case if the state of the rotation is \"in_progress\".\n   */\n  public Started: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  /**\n   * GracePeriod is a period during which old and new CA\n   *  are valid for checking purposes, but only new CA is issuing certificates.\n   */\n  public GracePeriod: i64;\n  // LastRotated specifies the last time of the completed rotation.\n  public LastRotated: google.protobuf.Timestamp =\n    new google.protobuf.Timestamp();\n  /**\n   * Schedule is a rotation schedule - used in\n   *  automatic mode to switch beetween phases.\n   */\n  public Schedule: RotationSchedule = new RotationSchedule();\n\n  // Decodes Rotation from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Rotation {\n    return Rotation.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Rotation from a DataView\n  static decodeDataView(view: DataView): Rotation {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Rotation();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.State = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Phase = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Mode = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.CurrentID = decoder.string();\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Started = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.GracePeriod = decoder.int64();\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.LastRotated = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.Schedule = RotationSchedule.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Rotation\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.State.length > 0\n        ? 1 + __proto.Sizer.varint64(this.State.length) + this.State.length\n        : 0;\n    size +=\n      this.Phase.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Phase.length) + this.Phase.length\n        : 0;\n    size +=\n      this.Mode.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Mode.length) + this.Mode.length\n        : 0;\n    size +=\n      this.CurrentID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.CurrentID.length) +\n          this.CurrentID.length\n        : 0;\n\n    if (this.Started != null) {\n      const f: google.protobuf.Timestamp = this\n        .Started as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.GracePeriod == 0 ? 0 : 1 + __proto.Sizer.int64(this.GracePeriod);\n\n    if (this.LastRotated != null) {\n      const f: google.protobuf.Timestamp = this\n        .LastRotated as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Schedule != null) {\n      const f: RotationSchedule = this.Schedule as RotationSchedule;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes Rotation to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Rotation to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.State.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.State.length);\n      encoder.string(this.State);\n    }\n    if (this.Phase.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Phase.length);\n      encoder.string(this.Phase);\n    }\n    if (this.Mode.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Mode.length);\n      encoder.string(this.Mode);\n    }\n    if (this.CurrentID.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.CurrentID.length);\n      encoder.string(this.CurrentID);\n    }\n\n    if (this.Started != null) {\n      const f = this.Started as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.GracePeriod != 0) {\n      encoder.uint32(0x30);\n      encoder.int64(this.GracePeriod);\n    }\n\n    if (this.LastRotated != null) {\n      const f = this.LastRotated as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Schedule != null) {\n      const f = this.Schedule as RotationSchedule;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode Rotation\n} // Rotation\n\n// ProvisionTokenV2List is a list of provisioning tokens.\nexport class RotationSchedule {\n  // UpdateClients specifies time to switch to the \"Update clients\" phase\n  public UpdateClients: google.protobuf.Timestamp =\n    new google.protobuf.Timestamp();\n  // UpdateServers specifies time to switch to the \"Update servers\" phase.\n  public UpdateServers: google.protobuf.Timestamp =\n    new google.protobuf.Timestamp();\n  // Standby specifies time to switch to the \"Standby\" phase.\n  public Standby: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n\n  // Decodes RotationSchedule from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RotationSchedule {\n    return RotationSchedule.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RotationSchedule from a DataView\n  static decodeDataView(view: DataView): RotationSchedule {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RotationSchedule();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.UpdateClients = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.UpdateServers = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Standby = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RotationSchedule\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.UpdateClients != null) {\n      const f: google.protobuf.Timestamp = this\n        .UpdateClients as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.UpdateServers != null) {\n      const f: google.protobuf.Timestamp = this\n        .UpdateServers as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Standby != null) {\n      const f: google.protobuf.Timestamp = this\n        .Standby as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RotationSchedule to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RotationSchedule to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.UpdateClients != null) {\n      const f = this.UpdateClients as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.UpdateServers != null) {\n      const f = this.UpdateServers as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Standby != null) {\n      const f = this.Standby as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RotationSchedule\n} // RotationSchedule\n\n/**\n * ClusterNetworkingConfigSpecV2 is the actual data we care about\n *  for ClusterNetworkingConfig.\n */\nexport class ResourceHeader {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n\n  // Decodes ResourceHeader from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ResourceHeader {\n    return ResourceHeader.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ResourceHeader from a DataView\n  static decodeDataView(view: DataView): ResourceHeader {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ResourceHeader();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ResourceHeader\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ResourceHeader to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ResourceHeader to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ResourceHeader\n} // ResourceHeader\n\n// NamespaceSpec is a namespace specificateion\nexport class DatabaseServerV3 {\n  // Kind is the database server resource kind.\n  public Kind: string = \"\";\n  // SubKind is an optional resource subkind.\n  public SubKind: string = \"\";\n  // Version is the resource version.\n  public Version: string = \"\";\n  // Metadata is the database server metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is the database server spec.\n  public Spec: DatabaseServerSpecV3 = new DatabaseServerSpecV3();\n\n  // Decodes DatabaseServerV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseServerV3 {\n    return DatabaseServerV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseServerV3 from a DataView\n  static decodeDataView(view: DataView): DatabaseServerV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseServerV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = DatabaseServerSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseServerV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: DatabaseServerSpecV3 = this.Spec as DatabaseServerSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseServerV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseServerV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as DatabaseServerSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseServerV3\n} // DatabaseServerV3\n\n// AccessRequestFilter encodes filter params for access requests.\nexport class DatabaseServerSpecV3 {\n  /**\n   * Description is a free-form text describing this database server.\n   *\n   *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.\n   */\n  public Description: string = \"\";\n  /**\n   * Protocol is the database type e.g. postgres, mysql, etc.\n   *\n   *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.\n   */\n  public Protocol: string = \"\";\n  /**\n   * URI is the database connection address.\n   *\n   *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.\n   */\n  public URI: string = \"\";\n  /**\n   * CACert is an optional base64-encoded database CA certificate.\n   *\n   *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.\n   */\n  public CACert: Array<u8> = new Array<u8>();\n  /**\n   * AWS contains AWS specific settings for RDS/Aurora databases.\n   *\n   *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.\n   */\n  public AWS: AWS = new AWS();\n  // Version is the Teleport version that the server is running.\n  public Version: string = \"\";\n  // Hostname is the database server hostname.\n  public Hostname: string = \"\";\n  // HostID is the ID of the host the database server is running on.\n  public HostID: string = \"\";\n  /**\n   * DynamicLabels is the database server dynamic labels.\n   *\n   *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.\n   */\n  public DynamicLabels: Map<string, CommandLabelV2> = new Map<\n    string,\n    CommandLabelV2\n  >();\n  // Rotation contains the server CA rotation information.\n  public Rotation: Rotation = new Rotation();\n  /**\n   * GCP contains parameters specific to GCP Cloud SQL databases.\n   *\n   *  DEPRECATED: Moved to DatabaseSpecV3. DELETE IN 9.0.\n   */\n  public GCP: GCPCloudSQL = new GCPCloudSQL();\n  // Database is the database proxied by this database server.\n  public Database: DatabaseV3 = new DatabaseV3();\n\n  // Decodes DatabaseServerSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseServerSpecV3 {\n    return DatabaseServerSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseServerSpecV3 from a DataView\n  static decodeDataView(view: DataView): DatabaseServerSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseServerSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Description = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Protocol = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.URI = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.CACert = decoder.bytes();\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.AWS = AWS.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.Hostname = decoder.string();\n          break;\n        }\n        case 8: {\n          obj.HostID = decoder.string();\n          break;\n        }\n        case 9: {\n          const length = decoder.uint32();\n          __decodeMap_string_CommandLabelV2(decoder, length, obj.DynamicLabels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.Rotation = Rotation.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 11: {\n          const length = decoder.uint32();\n          obj.GCP = GCPCloudSQL.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 12: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseServerSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Description.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Description.length) +\n          this.Description.length\n        : 0;\n    size +=\n      this.Protocol.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Protocol.length) +\n          this.Protocol.length\n        : 0;\n    size +=\n      this.URI.length > 0\n        ? 1 + __proto.Sizer.varint64(this.URI.length) + this.URI.length\n        : 0;\n    size +=\n      this.CACert.length > 0\n        ? 1 + __proto.Sizer.varint64(this.CACert.length) + this.CACert.length\n        : 0;\n\n    if (this.AWS != null) {\n      const f: AWS = this.AWS as AWS;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n    size +=\n      this.Hostname.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Hostname.length) +\n          this.Hostname.length\n        : 0;\n    size +=\n      this.HostID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.HostID.length) + this.HostID.length\n        : 0;\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const itemSize = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    if (this.Rotation != null) {\n      const f: Rotation = this.Rotation as Rotation;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.GCP != null) {\n      const f: GCPCloudSQL = this.GCP as GCPCloudSQL;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseV3 = this.Database as DatabaseV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseServerSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseServerSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Description.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Description.length);\n      encoder.string(this.Description);\n    }\n    if (this.Protocol.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Protocol.length);\n      encoder.string(this.Protocol);\n    }\n    if (this.URI.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.URI.length);\n      encoder.string(this.URI);\n    }\n    if (this.CACert.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.CACert.length);\n      encoder.bytes(this.CACert);\n    }\n\n    if (this.AWS != null) {\n      const f = this.AWS as AWS;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Version.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n    if (this.Hostname.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.Hostname.length);\n      encoder.string(this.Hostname);\n    }\n    if (this.HostID.length > 0) {\n      encoder.uint32(0x42);\n      encoder.uint32(this.HostID.length);\n      encoder.string(this.HostID);\n    }\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const size = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (size > 0) {\n          encoder.uint32(0x4a);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n\n          const messageSize = value.size();\n\n          if (messageSize > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(messageSize);\n            value.encodeU8Array(encoder);\n          }\n        }\n      }\n    }\n\n    if (this.Rotation != null) {\n      const f = this.Rotation as Rotation;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.GCP != null) {\n      const f = this.GCP as GCPCloudSQL;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x5a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x62);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseServerSpecV3\n} // DatabaseServerSpecV3\n\n// RoleOptions is a set of role options\nexport class DatabaseV3List {\n  // Databases is a list of database resources.\n  public Databases: Array<DatabaseV3> = new Array<DatabaseV3>();\n\n  // Decodes DatabaseV3List from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseV3List {\n    return DatabaseV3List.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseV3List from a DataView\n  static decodeDataView(view: DataView): DatabaseV3List {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseV3List();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Databases.push(\n            DatabaseV3.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseV3List\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.Databases.length; n++) {\n      const messageSize = this.Databases[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseV3List to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseV3List to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.Databases.length; n++) {\n      const messageSize = this.Databases[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.Databases[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseV3List\n} // DatabaseV3List\n\n/**\n * ImpersonateConditions specifies whether users are allowed\n *  to issue certificates for other users or groups.\n */\nexport class DatabaseV3 {\n  // Kind is the database resource kind.\n  public Kind: string = \"\";\n  // SubKind is an optional resource subkind.\n  public SubKind: string = \"\";\n  // Version is the resource version.\n  public Version: string = \"\";\n  // Metadata is the database metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is the database spec.\n  public Spec: DatabaseSpecV3 = new DatabaseSpecV3();\n  // Status is the database runtime information.\n  public Status: DatabaseStatusV3 = new DatabaseStatusV3();\n\n  // Decodes DatabaseV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseV3 {\n    return DatabaseV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseV3 from a DataView\n  static decodeDataView(view: DataView): DatabaseV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = DatabaseSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.Status = DatabaseStatusV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: DatabaseSpecV3 = this.Spec as DatabaseSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Status != null) {\n      const f: DatabaseStatusV3 = this.Status as DatabaseStatusV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as DatabaseSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Status != null) {\n      const f = this.Status as DatabaseStatusV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseV3\n} // DatabaseV3\n\n// U2FDevice holds the U2F-specific fields of MFADevice.\nexport class DatabaseSpecV3 {\n  // Protocol is the database protocol: postgres, mysql, mongodb, etc.\n  public Protocol: string = \"\";\n  // URI is the database connection endpoint.\n  public URI: string = \"\";\n  /**\n   * CACert is the PEM-encoded database CA certificate.\n   *\n   *  DEPRECATED: Moved to TLS.CACert. DELETE IN 10.0.\n   */\n  public CACert: string = \"\";\n  // DynamicLabels is the database dynamic labels.\n  public DynamicLabels: Map<string, CommandLabelV2> = new Map<\n    string,\n    CommandLabelV2\n  >();\n  // AWS contains AWS specific settings for RDS/Aurora/Redshift databases.\n  public AWS: AWS = new AWS();\n  // GCP contains parameters specific to GCP Cloud SQL databases.\n  public GCP: GCPCloudSQL = new GCPCloudSQL();\n  // Azure contains Azure specific database metadata.\n  public Azure: Azure = new Azure();\n  /**\n   * TLS is the TLS configuration used when establishing connection to target database.\n   *  Allows to provide custom CA cert or override server name.\n   */\n  public TLS: DatabaseTLS = new DatabaseTLS();\n  // AD is the Active Directory configuration for the database.\n  public AD: AD = new AD();\n\n  // Decodes DatabaseSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseSpecV3 {\n    return DatabaseSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseSpecV3 from a DataView\n  static decodeDataView(view: DataView): DatabaseSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Protocol = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.URI = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.CACert = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          __decodeMap_string_CommandLabelV2(decoder, length, obj.DynamicLabels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.AWS = AWS.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.GCP = GCPCloudSQL.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.Azure = Azure.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.TLS = DatabaseTLS.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 9: {\n          const length = decoder.uint32();\n          obj.AD = AD.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Protocol.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Protocol.length) +\n          this.Protocol.length\n        : 0;\n    size +=\n      this.URI.length > 0\n        ? 1 + __proto.Sizer.varint64(this.URI.length) + this.URI.length\n        : 0;\n    size +=\n      this.CACert.length > 0\n        ? 1 + __proto.Sizer.varint64(this.CACert.length) + this.CACert.length\n        : 0;\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const itemSize = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    if (this.AWS != null) {\n      const f: AWS = this.AWS as AWS;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.GCP != null) {\n      const f: GCPCloudSQL = this.GCP as GCPCloudSQL;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Azure != null) {\n      const f: Azure = this.Azure as Azure;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.TLS != null) {\n      const f: DatabaseTLS = this.TLS as DatabaseTLS;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AD != null) {\n      const f: AD = this.AD as AD;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Protocol.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Protocol.length);\n      encoder.string(this.Protocol);\n    }\n    if (this.URI.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.URI.length);\n      encoder.string(this.URI);\n    }\n    if (this.CACert.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.CACert.length);\n      encoder.string(this.CACert);\n    }\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const size = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (size > 0) {\n          encoder.uint32(0x22);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n\n          const messageSize = value.size();\n\n          if (messageSize > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(messageSize);\n            value.encodeU8Array(encoder);\n          }\n        }\n      }\n    }\n\n    if (this.AWS != null) {\n      const f = this.AWS as AWS;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.GCP != null) {\n      const f = this.GCP as GCPCloudSQL;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Azure != null) {\n      const f = this.Azure as Azure;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.TLS != null) {\n      const f = this.TLS as DatabaseTLS;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AD != null) {\n      const f = this.AD as AD;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x4a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseSpecV3\n} // DatabaseSpecV3\n\n// AcquireSemaphoreRequest holds semaphore lease acquisition parameters.\nexport class DatabaseStatusV3 {\n  // CACert is the auto-downloaded cloud database CA certificate.\n  public CACert: string = \"\";\n  // AWS is the auto-discovered AWS cloud database metadata.\n  public AWS: AWS = new AWS();\n\n  // Decodes DatabaseStatusV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseStatusV3 {\n    return DatabaseStatusV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseStatusV3 from a DataView\n  static decodeDataView(view: DataView): DatabaseStatusV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseStatusV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.CACert = decoder.string();\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.AWS = AWS.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseStatusV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.CACert.length > 0\n        ? 1 + __proto.Sizer.varint64(this.CACert.length) + this.CACert.length\n        : 0;\n\n    if (this.AWS != null) {\n      const f: AWS = this.AWS as AWS;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseStatusV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseStatusV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.CACert.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.CACert.length);\n      encoder.string(this.CACert);\n    }\n\n    if (this.AWS != null) {\n      const f = this.AWS as AWS;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseStatusV3\n} // DatabaseStatusV3\n\n/**\n * KubernetesCluster is a named kubernetes API endpoint handled by a Server.\n *\n *  TODO: deprecate and convert all usage to KubernetesClusterV3\n */\nexport class AWS {\n  // Region is a AWS cloud region.\n  public Region: string = \"\";\n  // Redshift contains Redshift specific metadata.\n  public Redshift: Redshift = new Redshift();\n  // RDS contains RDS specific metadata.\n  public RDS: RDS = new RDS();\n  // AccountID is the AWS account ID this database belongs to.\n  public AccountID: string = \"\";\n\n  // Decodes AWS from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AWS {\n    return AWS.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AWS from a DataView\n  static decodeDataView(view: DataView): AWS {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AWS();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Region = decoder.string();\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Redshift = Redshift.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.RDS = RDS.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.AccountID = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AWS\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Region.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Region.length) + this.Region.length\n        : 0;\n\n    if (this.Redshift != null) {\n      const f: Redshift = this.Redshift as Redshift;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.RDS != null) {\n      const f: RDS = this.RDS as RDS;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.AccountID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.AccountID.length) +\n          this.AccountID.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes AWS to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AWS to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Region.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Region.length);\n      encoder.string(this.Region);\n    }\n\n    if (this.Redshift != null) {\n      const f = this.Redshift as Redshift;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RDS != null) {\n      const f = this.RDS as RDS;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AccountID.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.AccountID.length);\n      encoder.string(this.AccountID);\n    }\n\n    return buf;\n  } // encode AWS\n} // AWS\n\n// ResourceWithSecretsRequest is a request relating to a named resource with secrets.\nexport class Redshift {\n  // ClusterID is the Redshift cluster identifier.\n  public ClusterID: string = \"\";\n\n  // Decodes Redshift from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Redshift {\n    return Redshift.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Redshift from a DataView\n  static decodeDataView(view: DataView): Redshift {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Redshift();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ClusterID = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Redshift\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ClusterID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClusterID.length) +\n          this.ClusterID.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes Redshift to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Redshift to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ClusterID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.ClusterID.length);\n      encoder.string(this.ClusterID);\n    }\n\n    return buf;\n  } // encode Redshift\n} // Redshift\n\n// AttributeMapping maps a SAML attribute statement to teleport roles.\nexport class RDS {\n  // InstanceID is the RDS instance identifier.\n  public InstanceID: string = \"\";\n  // ClusterID is the RDS cluster (Aurora) identifier.\n  public ClusterID: string = \"\";\n  // ResourceID is the RDS instance resource identifier (db-xxx).\n  public ResourceID: string = \"\";\n  // IAMAuth indicates whether database IAM authentication is enabled.\n  public IAMAuth: bool;\n\n  // Decodes RDS from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RDS {\n    return RDS.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RDS from a DataView\n  static decodeDataView(view: DataView): RDS {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RDS();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.InstanceID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.ClusterID = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.ResourceID = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.IAMAuth = decoder.bool();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RDS\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.InstanceID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.InstanceID.length) +\n          this.InstanceID.length\n        : 0;\n    size +=\n      this.ClusterID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClusterID.length) +\n          this.ClusterID.length\n        : 0;\n    size +=\n      this.ResourceID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ResourceID.length) +\n          this.ResourceID.length\n        : 0;\n    size += this.IAMAuth == 0 ? 0 : 1 + 1;\n\n    return size;\n  }\n\n  // Encodes RDS to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RDS to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.InstanceID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.InstanceID.length);\n      encoder.string(this.InstanceID);\n    }\n    if (this.ClusterID.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.ClusterID.length);\n      encoder.string(this.ClusterID);\n    }\n    if (this.ResourceID.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.ResourceID.length);\n      encoder.string(this.ResourceID);\n    }\n    if (this.IAMAuth != 0) {\n      encoder.uint32(0x20);\n      encoder.bool(this.IAMAuth);\n    }\n\n    return buf;\n  } // encode RDS\n} // RDS\n\n// LockSpecV2 is a Lock specification.\nexport class GCPCloudSQL {\n  // ProjectID is the GCP project ID the Cloud SQL instance resides in.\n  public ProjectID: string = \"\";\n  // InstanceID is the Cloud SQL instance ID.\n  public InstanceID: string = \"\";\n\n  // Decodes GCPCloudSQL from an ArrayBuffer\n  static decode(buf: ArrayBuffer): GCPCloudSQL {\n    return GCPCloudSQL.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes GCPCloudSQL from a DataView\n  static decodeDataView(view: DataView): GCPCloudSQL {\n    const decoder = new __proto.Decoder(view);\n    const obj = new GCPCloudSQL();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ProjectID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.InstanceID = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode GCPCloudSQL\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ProjectID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ProjectID.length) +\n          this.ProjectID.length\n        : 0;\n    size +=\n      this.InstanceID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.InstanceID.length) +\n          this.InstanceID.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes GCPCloudSQL to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes GCPCloudSQL to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ProjectID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.ProjectID.length);\n      encoder.string(this.ProjectID);\n    }\n    if (this.InstanceID.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.InstanceID.length);\n      encoder.string(this.InstanceID);\n    }\n\n    return buf;\n  } // encode GCPCloudSQL\n} // GCPCloudSQL\n\n/**\n * RegisterUsingTokenRequest is a request to register with the auth server using\n *  an authentication token\n */\nexport class Azure {\n  // Name is the Azure database server name.\n  public Name: string = \"\";\n\n  // Decodes Azure from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Azure {\n    return Azure.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Azure from a DataView\n  static decodeDataView(view: DataView): Azure {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Azure();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Azure\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes Azure to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Azure to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n\n    return buf;\n  } // encode Azure\n} // Azure\n\n// SortBy defines a sort criteria.\nexport class AD {\n  // KeytabFile is the path to the Kerberos keytab file.\n  public KeytabFile: string = \"\";\n  // Krb5File is the path to the Kerberos configuration file. Defaults to /etc/krb5.conf.\n  public Krb5File: string = \"\";\n  // Domain is the Active Directory domain the database resides in.\n  public Domain: string = \"\";\n  // SPN is the service principal name for the database.\n  public SPN: string = \"\";\n\n  // Decodes AD from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AD {\n    return AD.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AD from a DataView\n  static decodeDataView(view: DataView): AD {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AD();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.KeytabFile = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Krb5File = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Domain = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.SPN = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AD\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.KeytabFile.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.KeytabFile.length) +\n          this.KeytabFile.length\n        : 0;\n    size +=\n      this.Krb5File.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Krb5File.length) +\n          this.Krb5File.length\n        : 0;\n    size +=\n      this.Domain.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Domain.length) + this.Domain.length\n        : 0;\n    size +=\n      this.SPN.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SPN.length) + this.SPN.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes AD to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AD to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.KeytabFile.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.KeytabFile.length);\n      encoder.string(this.KeytabFile);\n    }\n    if (this.Krb5File.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Krb5File.length);\n      encoder.string(this.Krb5File);\n    }\n    if (this.Domain.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Domain.length);\n      encoder.string(this.Domain);\n    }\n    if (this.SPN.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.SPN.length);\n      encoder.string(this.SPN);\n    }\n\n    return buf;\n  } // encode AD\n} // AD\n\n// DatabaseTLS contains TLS configuration options.\nexport class DatabaseTLS {\n  // Mode is a TLS connection mode. See DatabaseTLSMode for details.\n  public Mode: u32;\n  /**\n   * CACert is an optional user provided CA certificate used for verifying\n   *  database TLS connection.\n   */\n  public CACert: string = \"\";\n  /**\n   * ServerName allows to provide custom hostname. This value will override the\n   *  servername/hostname on a certificate during validation.\n   */\n  public ServerName: string = \"\";\n\n  // Decodes DatabaseTLS from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseTLS {\n    return DatabaseTLS.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseTLS from a DataView\n  static decodeDataView(view: DataView): DatabaseTLS {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseTLS();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Mode = decoder.uint32();\n          break;\n        }\n        case 2: {\n          obj.CACert = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.ServerName = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseTLS\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.Mode == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Mode);\n    size +=\n      this.CACert.length > 0\n        ? 1 + __proto.Sizer.varint64(this.CACert.length) + this.CACert.length\n        : 0;\n    size +=\n      this.ServerName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ServerName.length) +\n          this.ServerName.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes DatabaseTLS to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseTLS to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Mode != 0) {\n      encoder.uint32(0x8);\n      encoder.uint32(this.Mode);\n    }\n    if (this.CACert.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.CACert.length);\n      encoder.string(this.CACert);\n    }\n    if (this.ServerName.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.ServerName.length);\n      encoder.string(this.ServerName);\n    }\n\n    return buf;\n  } // encode DatabaseTLS\n} // DatabaseTLS\n\n// ServerV2 represents a Node, App, Database, Proxy or Auth server in a Teleport cluster.\nexport class ServerV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a server spec\n  public Spec: ServerSpecV2 = new ServerSpecV2();\n\n  // Decodes ServerV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ServerV2 {\n    return ServerV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ServerV2 from a DataView\n  static decodeDataView(view: DataView): ServerV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ServerV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = ServerSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ServerV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: ServerSpecV2 = this.Spec as ServerSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ServerV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ServerV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as ServerSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ServerV2\n} // ServerV2\n\n/**\n * ServerV2List is a list of servers.\n *  DELETE IN 8.0.0 only used in deprecated GetNodes rpc\n */\nexport class ServerV2List {\n  // Servers is a list of servers.\n  public Servers: Array<ServerV2> = new Array<ServerV2>();\n\n  // Decodes ServerV2List from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ServerV2List {\n    return ServerV2List.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ServerV2List from a DataView\n  static decodeDataView(view: DataView): ServerV2List {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ServerV2List();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Servers.push(\n            ServerV2.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ServerV2List\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.Servers.length; n++) {\n      const messageSize = this.Servers[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ServerV2List to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ServerV2List to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.Servers.length; n++) {\n      const messageSize = this.Servers[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.Servers[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ServerV2List\n} // ServerV2List\n\n// ServerSpecV2 is a specification for V2 Server\nexport class ServerSpecV2 {\n  // Addr is server host:port address\n  public Addr: string = \"\";\n  // PublicAddr is the public address this cluster can be reached at.\n  public PublicAddr: string = \"\";\n  // Hostname is server hostname\n  public Hostname: string = \"\";\n  // CmdLabels is server dynamic labels\n  public CmdLabels: Map<string, CommandLabelV2> = new Map<\n    string,\n    CommandLabelV2\n  >();\n  // Rotation specifies server rotation\n  public Rotation: Rotation = new Rotation();\n  /**\n   * UseTunnel indicates that connections to this server should occur over a\n   *  reverse tunnel.\n   */\n  public UseTunnel: bool;\n  // TeleportVersion is the teleport version that the server is running on\n  public Version: string = \"\";\n  /**\n   * Apps is a list of applications this server is proxying.\n   *\n   *  DELETE IN 9.0. Deprecated, moved to AppServerSpecV3.\n   */\n  public Apps: Array<App> = new Array<App>();\n  /**\n   * KubernetesClusters is a list of kubernetes clusters provided by this\n   *  Proxy or KubeService server.\n   *\n   *  Important: jsontag must not be \"kubernetes_clusters\", because a\n   *  different field with that jsontag existed in 4.4:\n   *  https://github.com/gravitational/teleport/issues/4862\n   */\n  public KubernetesClusters: Array<KubernetesCluster> =\n    new Array<KubernetesCluster>();\n\n  // Decodes ServerSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ServerSpecV2 {\n    return ServerSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ServerSpecV2 from a DataView\n  static decodeDataView(view: DataView): ServerSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ServerSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Addr = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.PublicAddr = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Hostname = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          __decodeMap_string_CommandLabelV2(decoder, length, obj.CmdLabels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Rotation = Rotation.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.UseTunnel = decoder.bool();\n          break;\n        }\n        case 7: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 9: {\n          const length = decoder.uint32();\n          obj.Apps.push(\n            App.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.KubernetesClusters.push(\n            KubernetesCluster.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ServerSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Addr.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Addr.length) + this.Addr.length\n        : 0;\n    size +=\n      this.PublicAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PublicAddr.length) +\n          this.PublicAddr.length\n        : 0;\n    size +=\n      this.Hostname.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Hostname.length) +\n          this.Hostname.length\n        : 0;\n\n    if (this.CmdLabels.size > 0) {\n      const keys = this.CmdLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.CmdLabels.get(key);\n        const itemSize = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    if (this.Rotation != null) {\n      const f: Rotation = this.Rotation as Rotation;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += this.UseTunnel == 0 ? 0 : 1 + 1;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    for (let n: i32 = 0; n < this.Apps.length; n++) {\n      const messageSize = this.Apps[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.KubernetesClusters.length; n++) {\n      const messageSize = this.KubernetesClusters[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ServerSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ServerSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Addr.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Addr.length);\n      encoder.string(this.Addr);\n    }\n    if (this.PublicAddr.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.PublicAddr.length);\n      encoder.string(this.PublicAddr);\n    }\n    if (this.Hostname.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Hostname.length);\n      encoder.string(this.Hostname);\n    }\n\n    if (this.CmdLabels.size > 0) {\n      const keys = this.CmdLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.CmdLabels.get(key);\n        const size = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (size > 0) {\n          encoder.uint32(0x22);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n\n          const messageSize = value.size();\n\n          if (messageSize > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(messageSize);\n            value.encodeU8Array(encoder);\n          }\n        }\n      }\n    }\n\n    if (this.Rotation != null) {\n      const f = this.Rotation as Rotation;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.UseTunnel != 0) {\n      encoder.uint32(0x30);\n      encoder.bool(this.UseTunnel);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    for (let n: i32 = 0; n < this.Apps.length; n++) {\n      const messageSize = this.Apps[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x4a);\n        encoder.uint32(messageSize);\n        this.Apps[n].encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.KubernetesClusters.length; n++) {\n      const messageSize = this.KubernetesClusters[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        this.KubernetesClusters[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ServerSpecV2\n} // ServerSpecV2\n\n// AppServerV3 represents a single proxied web app.\nexport class AppServerV3 {\n  // Kind is the app server resource kind. Always \"app_server\".\n  public Kind: string = \"\";\n  // SubKind is an optional resource subkind.\n  public SubKind: string = \"\";\n  // Version is the resource version.\n  public Version: string = \"\";\n  // Metadata is the app server metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is the app server spec.\n  public Spec: AppServerSpecV3 = new AppServerSpecV3();\n\n  // Decodes AppServerV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppServerV3 {\n    return AppServerV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppServerV3 from a DataView\n  static decodeDataView(view: DataView): AppServerV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppServerV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = AppServerSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppServerV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: AppServerSpecV3 = this.Spec as AppServerSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AppServerV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppServerV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as AppServerSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AppServerV3\n} // AppServerV3\n\n// AppServerSpecV3 is the app access server spec.\nexport class AppServerSpecV3 {\n  // Version is the Teleport version that the server is running.\n  public Version: string = \"\";\n  // Hostname is the app server hostname.\n  public Hostname: string = \"\";\n  // HostID is the app server host uuid.\n  public HostID: string = \"\";\n  // Rotation contains the app server CA rotation information.\n  public Rotation: Rotation = new Rotation();\n  // App is the app proxied by this app server.\n  public App: AppV3 = new AppV3();\n\n  // Decodes AppServerSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppServerSpecV3 {\n    return AppServerSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppServerSpecV3 from a DataView\n  static decodeDataView(view: DataView): AppServerSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppServerSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Hostname = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.HostID = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Rotation = Rotation.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.App = AppV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppServerSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n    size +=\n      this.Hostname.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Hostname.length) +\n          this.Hostname.length\n        : 0;\n    size +=\n      this.HostID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.HostID.length) + this.HostID.length\n        : 0;\n\n    if (this.Rotation != null) {\n      const f: Rotation = this.Rotation as Rotation;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.App != null) {\n      const f: AppV3 = this.App as AppV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AppServerSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppServerSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Version.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n    if (this.Hostname.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Hostname.length);\n      encoder.string(this.Hostname);\n    }\n    if (this.HostID.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.HostID.length);\n      encoder.string(this.HostID);\n    }\n\n    if (this.Rotation != null) {\n      const f = this.Rotation as Rotation;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.App != null) {\n      const f = this.App as AppV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AppServerSpecV3\n} // AppServerSpecV3\n\n// AppV3List represents a list of app resources.\nexport class AppV3List {\n  // Apps is a list of app resources.\n  public Apps: Array<AppV3> = new Array<AppV3>();\n\n  // Decodes AppV3List from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppV3List {\n    return AppV3List.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppV3List from a DataView\n  static decodeDataView(view: DataView): AppV3List {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppV3List();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Apps.push(\n            AppV3.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppV3List\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.Apps.length; n++) {\n      const messageSize = this.Apps[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AppV3List to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppV3List to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.Apps.length; n++) {\n      const messageSize = this.Apps[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.Apps[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AppV3List\n} // AppV3List\n\n// AppV3 represents an app resource.\nexport class AppV3 {\n  // Kind is the app resource kind. Always \"app\".\n  public Kind: string = \"\";\n  // SubKind is an optional resource subkind.\n  public SubKind: string = \"\";\n  // Version is the resource version.\n  public Version: string = \"\";\n  // Metadata is the app resource metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is the app resource spec.\n  public Spec: AppSpecV3 = new AppSpecV3();\n\n  // Decodes AppV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppV3 {\n    return AppV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppV3 from a DataView\n  static decodeDataView(view: DataView): AppV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = AppSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: AppSpecV3 = this.Spec as AppSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AppV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as AppSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AppV3\n} // AppV3\n\n// AppSpecV3 is the AppV3 resource spec.\nexport class AppSpecV3 {\n  // URI is the web app endpoint.\n  public URI: string = \"\";\n  // PublicAddr is the public address the application is accessible at.\n  public PublicAddr: string = \"\";\n  // DynamicLabels are the app's command labels.\n  public DynamicLabels: Map<string, CommandLabelV2> = new Map<\n    string,\n    CommandLabelV2\n  >();\n  // InsecureSkipVerify disables app's TLS certificate verification.\n  public InsecureSkipVerify: bool;\n  // Rewrite is a list of rewriting rules to apply to requests and responses.\n  public Rewrite: Rewrite = new Rewrite();\n\n  // Decodes AppSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppSpecV3 {\n    return AppSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppSpecV3 from a DataView\n  static decodeDataView(view: DataView): AppSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.URI = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.PublicAddr = decoder.string();\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          __decodeMap_string_CommandLabelV2(decoder, length, obj.DynamicLabels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.InsecureSkipVerify = decoder.bool();\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Rewrite = Rewrite.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.URI.length > 0\n        ? 1 + __proto.Sizer.varint64(this.URI.length) + this.URI.length\n        : 0;\n    size +=\n      this.PublicAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PublicAddr.length) +\n          this.PublicAddr.length\n        : 0;\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const itemSize = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    size += this.InsecureSkipVerify == 0 ? 0 : 1 + 1;\n\n    if (this.Rewrite != null) {\n      const f: Rewrite = this.Rewrite as Rewrite;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AppSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.URI.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.URI.length);\n      encoder.string(this.URI);\n    }\n    if (this.PublicAddr.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.PublicAddr.length);\n      encoder.string(this.PublicAddr);\n    }\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const size = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (size > 0) {\n          encoder.uint32(0x1a);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n\n          const messageSize = value.size();\n\n          if (messageSize > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(messageSize);\n            value.encodeU8Array(encoder);\n          }\n        }\n      }\n    }\n\n    if (this.InsecureSkipVerify != 0) {\n      encoder.uint32(0x20);\n      encoder.bool(this.InsecureSkipVerify);\n    }\n\n    if (this.Rewrite != null) {\n      const f = this.Rewrite as Rewrite;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AppSpecV3\n} // AppSpecV3\n\n/**\n * App is a specific application that a server proxies.\n *\n *  DELETE IN 9.0. Deprecated, use AppV3.\n */\nexport class App {\n  // Name is the name of the application.\n  public Name: string = \"\";\n  // URI is the internal address the application is available at.\n  public URI: string = \"\";\n  // PublicAddr is the public address the application is accessible at.\n  public PublicAddr: string = \"\";\n  /**\n   * StaticLabels is map of static labels associated with an application.\n   *  Used for RBAC.\n   */\n  public StaticLabels: Map<string, string> = new Map<string, string>();\n  /**\n   * DynamicLabels is map of dynamic labels associated with an application.\n   *  Used for RBAC.\n   */\n  public DynamicLabels: Map<string, CommandLabelV2> = new Map<\n    string,\n    CommandLabelV2\n  >();\n  // InsecureSkipVerify disables app's TLS certificate verification.\n  public InsecureSkipVerify: bool;\n  // Rewrite is a list of rewriting rules to apply to requests and responses.\n  public Rewrite: Rewrite = new Rewrite();\n  // Description is an optional free-form app description.\n  public Description: string = \"\";\n\n  // Decodes App from an ArrayBuffer\n  static decode(buf: ArrayBuffer): App {\n    return App.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes App from a DataView\n  static decodeDataView(view: DataView): App {\n    const decoder = new __proto.Decoder(view);\n    const obj = new App();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.URI = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.PublicAddr = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.StaticLabels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          __decodeMap_string_CommandLabelV2(decoder, length, obj.DynamicLabels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.InsecureSkipVerify = decoder.bool();\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.Rewrite = Rewrite.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 8: {\n          obj.Description = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode App\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.URI.length > 0\n        ? 1 + __proto.Sizer.varint64(this.URI.length) + this.URI.length\n        : 0;\n    size +=\n      this.PublicAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PublicAddr.length) +\n          this.PublicAddr.length\n        : 0;\n\n    if (this.StaticLabels.size > 0) {\n      const keys = this.StaticLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.StaticLabels.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const itemSize = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    size += this.InsecureSkipVerify == 0 ? 0 : 1 + 1;\n\n    if (this.Rewrite != null) {\n      const f: Rewrite = this.Rewrite as Rewrite;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Description.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Description.length) +\n          this.Description.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes App to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes App to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.URI.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.URI.length);\n      encoder.string(this.URI);\n    }\n    if (this.PublicAddr.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.PublicAddr.length);\n      encoder.string(this.PublicAddr);\n    }\n\n    if (this.StaticLabels.size > 0) {\n      const keys = this.StaticLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.StaticLabels.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0x22);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const size = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (size > 0) {\n          encoder.uint32(0x2a);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n\n          const messageSize = value.size();\n\n          if (messageSize > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(messageSize);\n            value.encodeU8Array(encoder);\n          }\n        }\n      }\n    }\n\n    if (this.InsecureSkipVerify != 0) {\n      encoder.uint32(0x30);\n      encoder.bool(this.InsecureSkipVerify);\n    }\n\n    if (this.Rewrite != null) {\n      const f = this.Rewrite as Rewrite;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Description.length > 0) {\n      encoder.uint32(0x42);\n      encoder.uint32(this.Description.length);\n      encoder.string(this.Description);\n    }\n\n    return buf;\n  } // encode App\n} // App\n\n// Rewrite is a list of rewriting rules to apply to requests and responses.\nexport class Rewrite {\n  /**\n   * Redirect defines a list of hosts which will be rewritten to the public\n   *  address of the application if they occur in the \"Location\" header.\n   */\n  public Redirect: Array<string> = new Array<string>();\n  /**\n   * Headers is a list of headers to inject when passing the request over\n   *  to the application.\n   */\n  public Headers: Array<Header> = new Array<Header>();\n\n  // Decodes Rewrite from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Rewrite {\n    return Rewrite.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Rewrite from a DataView\n  static decodeDataView(view: DataView): Rewrite {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Rewrite();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Redirect.push(decoder.string());\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Headers.push(\n            Header.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Rewrite\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += __size_string_repeated(this.Redirect);\n\n    for (let n: i32 = 0; n < this.Headers.length; n++) {\n      const messageSize = this.Headers[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes Rewrite to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Rewrite to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Redirect.length > 0) {\n      for (let n: i32 = 0; n < this.Redirect.length; n++) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.Redirect[n].length);\n        encoder.string(this.Redirect[n]);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Headers.length; n++) {\n      const messageSize = this.Headers[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        this.Headers[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode Rewrite\n} // Rewrite\n\n// Header represents a single http header passed over to the proxied application.\nexport class Header {\n  // Name is the http header name.\n  public Name: string = \"\";\n  // Value is the http header value.\n  public Value: string = \"\";\n\n  // Decodes Header from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Header {\n    return Header.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Header from a DataView\n  static decodeDataView(view: DataView): Header {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Header();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Value = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Header\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.Value.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Value.length) + this.Value.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes Header to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Header to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.Value.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Value.length);\n      encoder.string(this.Value);\n    }\n\n    return buf;\n  } // encode Header\n} // Header\n\n/**\n * CommandLabelV2 is a label that has a value as a result of the\n *  output generated by running command, e.g. hostname\n */\nexport class CommandLabelV2 {\n  // Period is a time between command runs\n  public Period: i64;\n  // Command is a command to run\n  public Command: Array<string> = new Array<string>();\n  // Result captures standard output\n  public Result: string = \"\";\n\n  // Decodes CommandLabelV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): CommandLabelV2 {\n    return CommandLabelV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes CommandLabelV2 from a DataView\n  static decodeDataView(view: DataView): CommandLabelV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new CommandLabelV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Period = decoder.int64();\n          break;\n        }\n        case 2: {\n          obj.Command.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.Result = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode CommandLabelV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.Period == 0 ? 0 : 1 + __proto.Sizer.int64(this.Period);\n\n    size += __size_string_repeated(this.Command);\n\n    size +=\n      this.Result.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Result.length) + this.Result.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes CommandLabelV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes CommandLabelV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Period != 0) {\n      encoder.uint32(0x8);\n      encoder.int64(this.Period);\n    }\n\n    if (this.Command.length > 0) {\n      for (let n: i32 = 0; n < this.Command.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.Command[n].length);\n        encoder.string(this.Command[n]);\n      }\n    }\n\n    if (this.Result.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Result.length);\n      encoder.string(this.Result);\n    }\n\n    return buf;\n  } // encode CommandLabelV2\n} // CommandLabelV2\n\n// SSHKeyPair is an SSH CA key pair.\nexport class SSHKeyPair {\n  // PublicKey is the SSH public key.\n  public PublicKey: Array<u8> = new Array<u8>();\n  // PrivateKey is the SSH private key.\n  public PrivateKey: Array<u8> = new Array<u8>();\n  // PrivateKeyType is the type of the PrivateKey.\n  public PrivateKeyType: u32;\n\n  // Decodes SSHKeyPair from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SSHKeyPair {\n    return SSHKeyPair.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SSHKeyPair from a DataView\n  static decodeDataView(view: DataView): SSHKeyPair {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SSHKeyPair();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.PublicKey = decoder.bytes();\n          break;\n        }\n        case 2: {\n          obj.PrivateKey = decoder.bytes();\n          break;\n        }\n        case 3: {\n          obj.PrivateKeyType = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SSHKeyPair\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.PublicKey.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PublicKey.length) +\n          this.PublicKey.length\n        : 0;\n    size +=\n      this.PrivateKey.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PrivateKey.length) +\n          this.PrivateKey.length\n        : 0;\n    size +=\n      this.PrivateKeyType == 0\n        ? 0\n        : 1 + __proto.Sizer.uint32(this.PrivateKeyType);\n\n    return size;\n  }\n\n  // Encodes SSHKeyPair to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SSHKeyPair to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.PublicKey.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.PublicKey.length);\n      encoder.bytes(this.PublicKey);\n    }\n    if (this.PrivateKey.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.PrivateKey.length);\n      encoder.bytes(this.PrivateKey);\n    }\n    if (this.PrivateKeyType != 0) {\n      encoder.uint32(0x18);\n      encoder.uint32(this.PrivateKeyType);\n    }\n\n    return buf;\n  } // encode SSHKeyPair\n} // SSHKeyPair\n\n// TLSKeyPair is a TLS key pair\nexport class TLSKeyPair {\n  // Cert is a PEM encoded TLS cert\n  public Cert: Array<u8> = new Array<u8>();\n  // Key is a PEM encoded TLS key\n  public Key: Array<u8> = new Array<u8>();\n  // KeyType is the type of the Key.\n  public KeyType: u32;\n\n  // Decodes TLSKeyPair from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TLSKeyPair {\n    return TLSKeyPair.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TLSKeyPair from a DataView\n  static decodeDataView(view: DataView): TLSKeyPair {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TLSKeyPair();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Cert = decoder.bytes();\n          break;\n        }\n        case 2: {\n          obj.Key = decoder.bytes();\n          break;\n        }\n        case 3: {\n          obj.KeyType = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TLSKeyPair\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Cert.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Cert.length) + this.Cert.length\n        : 0;\n    size +=\n      this.Key.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Key.length) + this.Key.length\n        : 0;\n    size += this.KeyType == 0 ? 0 : 1 + __proto.Sizer.uint32(this.KeyType);\n\n    return size;\n  }\n\n  // Encodes TLSKeyPair to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TLSKeyPair to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Cert.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Cert.length);\n      encoder.bytes(this.Cert);\n    }\n    if (this.Key.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Key.length);\n      encoder.bytes(this.Key);\n    }\n    if (this.KeyType != 0) {\n      encoder.uint32(0x18);\n      encoder.uint32(this.KeyType);\n    }\n\n    return buf;\n  } // encode TLSKeyPair\n} // TLSKeyPair\n\n// JWTKeyPair is a PEM encoded keypair used for signing JWT tokens.\nexport class JWTKeyPair {\n  // PublicKey is a PEM encoded public key.\n  public PublicKey: Array<u8> = new Array<u8>();\n  // PrivateKey is a PEM encoded private key.\n  public PrivateKey: Array<u8> = new Array<u8>();\n  // PrivateKeyType is the type of the PrivateKey.\n  public PrivateKeyType: u32;\n\n  // Decodes JWTKeyPair from an ArrayBuffer\n  static decode(buf: ArrayBuffer): JWTKeyPair {\n    return JWTKeyPair.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes JWTKeyPair from a DataView\n  static decodeDataView(view: DataView): JWTKeyPair {\n    const decoder = new __proto.Decoder(view);\n    const obj = new JWTKeyPair();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.PublicKey = decoder.bytes();\n          break;\n        }\n        case 2: {\n          obj.PrivateKey = decoder.bytes();\n          break;\n        }\n        case 3: {\n          obj.PrivateKeyType = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode JWTKeyPair\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.PublicKey.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PublicKey.length) +\n          this.PublicKey.length\n        : 0;\n    size +=\n      this.PrivateKey.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PrivateKey.length) +\n          this.PrivateKey.length\n        : 0;\n    size +=\n      this.PrivateKeyType == 0\n        ? 0\n        : 1 + __proto.Sizer.uint32(this.PrivateKeyType);\n\n    return size;\n  }\n\n  // Encodes JWTKeyPair to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes JWTKeyPair to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.PublicKey.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.PublicKey.length);\n      encoder.bytes(this.PublicKey);\n    }\n    if (this.PrivateKey.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.PrivateKey.length);\n      encoder.bytes(this.PrivateKey);\n    }\n    if (this.PrivateKeyType != 0) {\n      encoder.uint32(0x18);\n      encoder.uint32(this.PrivateKeyType);\n    }\n\n    return buf;\n  } // encode JWTKeyPair\n} // JWTKeyPair\n\n// CertAuthorityV2 is version 2 resource spec for Cert Authority\nexport class CertAuthorityV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is connector metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec contains cert authority specification\n  public Spec: CertAuthoritySpecV2 = new CertAuthoritySpecV2();\n\n  // Decodes CertAuthorityV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): CertAuthorityV2 {\n    return CertAuthorityV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes CertAuthorityV2 from a DataView\n  static decodeDataView(view: DataView): CertAuthorityV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new CertAuthorityV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = CertAuthoritySpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode CertAuthorityV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: CertAuthoritySpecV2 = this.Spec as CertAuthoritySpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes CertAuthorityV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes CertAuthorityV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as CertAuthoritySpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode CertAuthorityV2\n} // CertAuthorityV2\n\n/**\n * CertAuthoritySpecV2 is a host or user certificate authority that\n *  can check and if it has private key stored as well, sign it too\n */\nexport class CertAuthoritySpecV2 {\n  // Type is either user or host certificate authority\n  public Type: string = \"\";\n  /**\n   * DELETE IN(2.7.0) this field is deprecated,\n   *  as resource name matches cluster name after migrations.\n   *  and this property is enforced by the auth server code.\n   *  ClusterName identifies cluster name this authority serves,\n   *  for host authorities that means base hostname of all servers,\n   *  for user authorities that means organization name\n   */\n  public ClusterName: string = \"\";\n  /**\n   * Checkers is a list of SSH public keys that can be used to check\n   *  certificate signatures\n   *\n   *  DEPRECATED: use ActiveKeys and AdditionalTrustedKeys instead.\n   */\n  public CheckingKeys: Array<Array<u8>> = new Array<Array<u8>>();\n  /**\n   * SigningKeys is a list of private keys used for signing\n   *\n   *  DEPRECATED: use ActiveKeys instead.\n   */\n  public SigningKeys: Array<Array<u8>> = new Array<Array<u8>>();\n  // Roles is a list of roles assumed by users signed by this CA\n  public Roles: Array<string> = new Array<string>();\n  // RoleMap specifies role mappings to remote roles\n  public RoleMap: Array<RoleMapping> = new Array<RoleMapping>();\n  /**\n   * TLS is a list of TLS key pairs\n   *\n   *  DEPRECATED: use ActiveKeys and AdditionalTrustedKeys instead.\n   */\n  public TLSKeyPairs: Array<TLSKeyPair> = new Array<TLSKeyPair>();\n  // Rotation is a status of the certificate authority rotation\n  public Rotation: Rotation = new Rotation();\n  public SigningAlg: u32;\n  /**\n   * JWTKeyPair is a list of JWT key pairs.\n   *\n   *  DEPRECATED: use ActiveKeys and AdditionalTrustedKeys instead.\n   */\n  public JWTKeyPairs: Array<JWTKeyPair> = new Array<JWTKeyPair>();\n  // ActiveKeys are the CA key sets used to sign any new certificates.\n  public ActiveKeys: CAKeySet = new CAKeySet();\n  /**\n   * AdditionalTrustedKeys are additional CA key sets that can be used to\n   *  verify certificates. Certificates should be verified with\n   *  AdditionalTrustedKeys and ActiveKeys combined.\n   */\n  public AdditionalTrustedKeys: CAKeySet = new CAKeySet();\n\n  // Decodes CertAuthoritySpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): CertAuthoritySpecV2 {\n    return CertAuthoritySpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes CertAuthoritySpecV2 from a DataView\n  static decodeDataView(view: DataView): CertAuthoritySpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new CertAuthoritySpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Type = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.ClusterName = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.CheckingKeys.push(decoder.bytes());\n          break;\n        }\n        case 4: {\n          obj.SigningKeys.push(decoder.bytes());\n          break;\n        }\n        case 5: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.RoleMap.push(\n            RoleMapping.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.TLSKeyPairs.push(\n            TLSKeyPair.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.Rotation = Rotation.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 9: {\n          obj.SigningAlg = decoder.uint32();\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.JWTKeyPairs.push(\n            JWTKeyPair.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 11: {\n          const length = decoder.uint32();\n          obj.ActiveKeys = CAKeySet.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 12: {\n          const length = decoder.uint32();\n          obj.AdditionalTrustedKeys = CAKeySet.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode CertAuthoritySpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Type.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Type.length) + this.Type.length\n        : 0;\n    size +=\n      this.ClusterName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClusterName.length) +\n          this.ClusterName.length\n        : 0;\n\n    size += __size_bytes_repeated(this.CheckingKeys);\n\n    size += __size_bytes_repeated(this.SigningKeys);\n\n    size += __size_string_repeated(this.Roles);\n\n    for (let n: i32 = 0; n < this.RoleMap.length; n++) {\n      const messageSize = this.RoleMap[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.TLSKeyPairs.length; n++) {\n      const messageSize = this.TLSKeyPairs[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Rotation != null) {\n      const f: Rotation = this.Rotation as Rotation;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.SigningAlg == 0 ? 0 : 1 + __proto.Sizer.uint32(this.SigningAlg);\n\n    for (let n: i32 = 0; n < this.JWTKeyPairs.length; n++) {\n      const messageSize = this.JWTKeyPairs[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.ActiveKeys != null) {\n      const f: CAKeySet = this.ActiveKeys as CAKeySet;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AdditionalTrustedKeys != null) {\n      const f: CAKeySet = this.AdditionalTrustedKeys as CAKeySet;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes CertAuthoritySpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes CertAuthoritySpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Type.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Type.length);\n      encoder.string(this.Type);\n    }\n    if (this.ClusterName.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.ClusterName.length);\n      encoder.string(this.ClusterName);\n    }\n\n    if (this.CheckingKeys.length > 0) {\n      for (let n: i32 = 0; n < this.CheckingKeys.length; n++) {\n        encoder.uint32(0x1a);\n        encoder.uint32(this.CheckingKeys[n].length);\n        encoder.bytes(this.CheckingKeys[n]);\n      }\n    }\n\n    if (this.SigningKeys.length > 0) {\n      for (let n: i32 = 0; n < this.SigningKeys.length; n++) {\n        encoder.uint32(0x22);\n        encoder.uint32(this.SigningKeys[n].length);\n        encoder.bytes(this.SigningKeys[n]);\n      }\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x2a);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.RoleMap.length; n++) {\n      const messageSize = this.RoleMap[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        this.RoleMap[n].encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.TLSKeyPairs.length; n++) {\n      const messageSize = this.TLSKeyPairs[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        this.TLSKeyPairs[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Rotation != null) {\n      const f = this.Rotation as Rotation;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SigningAlg != 0) {\n      encoder.uint32(0x48);\n      encoder.uint32(this.SigningAlg);\n    }\n\n    for (let n: i32 = 0; n < this.JWTKeyPairs.length; n++) {\n      const messageSize = this.JWTKeyPairs[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        this.JWTKeyPairs[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.ActiveKeys != null) {\n      const f = this.ActiveKeys as CAKeySet;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x5a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AdditionalTrustedKeys != null) {\n      const f = this.AdditionalTrustedKeys as CAKeySet;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x62);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode CertAuthoritySpecV2\n} // CertAuthoritySpecV2\n\n/**\n * SigningAlg is the algorithm used for signing new SSH certificates using\n *  SigningKeys.\n */\nexport enum CertAuthoritySpecV2_SigningAlgType {\n  UNKNOWN = 0,\n  RSA_SHA1 = 1,\n  RSA_SHA2_256 = 2,\n  RSA_SHA2_512 = 3,\n} // CertAuthoritySpecV2_SigningAlgType\n// CAKeySet is the set of CA keys.\nexport class CAKeySet {\n  // SSH contains SSH CA key pairs.\n  public SSH: Array<SSHKeyPair> = new Array<SSHKeyPair>();\n  // TLS contains TLS CA key/cert pairs.\n  public TLS: Array<TLSKeyPair> = new Array<TLSKeyPair>();\n  // JWT contains JWT signing key pairs.\n  public JWT: Array<JWTKeyPair> = new Array<JWTKeyPair>();\n\n  // Decodes CAKeySet from an ArrayBuffer\n  static decode(buf: ArrayBuffer): CAKeySet {\n    return CAKeySet.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes CAKeySet from a DataView\n  static decodeDataView(view: DataView): CAKeySet {\n    const decoder = new __proto.Decoder(view);\n    const obj = new CAKeySet();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.SSH.push(\n            SSHKeyPair.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.TLS.push(\n            TLSKeyPair.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.JWT.push(\n            JWTKeyPair.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode CAKeySet\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.SSH.length; n++) {\n      const messageSize = this.SSH[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.TLS.length; n++) {\n      const messageSize = this.TLS[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.JWT.length; n++) {\n      const messageSize = this.JWT[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes CAKeySet to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes CAKeySet to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.SSH.length; n++) {\n      const messageSize = this.SSH[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.SSH[n].encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.TLS.length; n++) {\n      const messageSize = this.TLS[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        this.TLS[n].encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.JWT.length; n++) {\n      const messageSize = this.JWT[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        this.JWT[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode CAKeySet\n} // CAKeySet\n\n/**\n * RoleMapping provides mapping of remote roles to local roles\n *  for trusted clusters\n */\nexport class RoleMapping {\n  // Remote specifies remote role name to map from\n  public Remote: string = \"\";\n  // Local specifies local roles to map to\n  public Local: Array<string> = new Array<string>();\n\n  // Decodes RoleMapping from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RoleMapping {\n    return RoleMapping.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RoleMapping from a DataView\n  static decodeDataView(view: DataView): RoleMapping {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RoleMapping();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Remote = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Local.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RoleMapping\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Remote.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Remote.length) + this.Remote.length\n        : 0;\n\n    size += __size_string_repeated(this.Local);\n\n    return size;\n  }\n\n  // Encodes RoleMapping to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RoleMapping to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Remote.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Remote.length);\n      encoder.string(this.Remote);\n    }\n\n    if (this.Local.length > 0) {\n      for (let n: i32 = 0; n < this.Local.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.Local[n].length);\n        encoder.string(this.Local[n]);\n      }\n    }\n\n    return buf;\n  } // encode RoleMapping\n} // RoleMapping\n\n// ProvisionTokenV1 is a provisioning token V1\nexport class ProvisionTokenV1 {\n  /**\n   * Roles is a list of roles associated with the token,\n   *  that will be converted to metadata in the SSH and X509\n   *  certificates issued to the user of the token\n   */\n  public Roles: Array<string> = new Array<string>();\n  /**\n   * Expires is a global expiry time header can be set on any resource in the\n   *  system.\n   */\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // Token is a token name\n  public Token: string = \"\";\n\n  // Decodes ProvisionTokenV1 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ProvisionTokenV1 {\n    return ProvisionTokenV1.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ProvisionTokenV1 from a DataView\n  static decodeDataView(view: DataView): ProvisionTokenV1 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ProvisionTokenV1();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          obj.Token = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ProvisionTokenV1\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += __size_string_repeated(this.Roles);\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Token.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Token.length) + this.Token.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ProvisionTokenV1 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ProvisionTokenV1 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Token.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Token.length);\n      encoder.string(this.Token);\n    }\n\n    return buf;\n  } // encode ProvisionTokenV1\n} // ProvisionTokenV1\n\n// ProvisionTokenV2 specifies provisioning token\nexport class ProvisionTokenV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a provisioning token V2 spec\n  public Spec: ProvisionTokenSpecV2 = new ProvisionTokenSpecV2();\n\n  // Decodes ProvisionTokenV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ProvisionTokenV2 {\n    return ProvisionTokenV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ProvisionTokenV2 from a DataView\n  static decodeDataView(view: DataView): ProvisionTokenV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ProvisionTokenV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = ProvisionTokenSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ProvisionTokenV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: ProvisionTokenSpecV2 = this.Spec as ProvisionTokenSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ProvisionTokenV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ProvisionTokenV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as ProvisionTokenSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ProvisionTokenV2\n} // ProvisionTokenV2\n\n// ProvisionTokenV2List is a list of provisioning tokens.\nexport class ProvisionTokenV2List {\n  // ProvisionTokens is a list of provisioning tokens.\n  public ProvisionTokens: Array<ProvisionTokenV2> =\n    new Array<ProvisionTokenV2>();\n\n  // Decodes ProvisionTokenV2List from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ProvisionTokenV2List {\n    return ProvisionTokenV2List.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ProvisionTokenV2List from a DataView\n  static decodeDataView(view: DataView): ProvisionTokenV2List {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ProvisionTokenV2List();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.ProvisionTokens.push(\n            ProvisionTokenV2.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ProvisionTokenV2List\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.ProvisionTokens.length; n++) {\n      const messageSize = this.ProvisionTokens[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ProvisionTokenV2List to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ProvisionTokenV2List to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.ProvisionTokens.length; n++) {\n      const messageSize = this.ProvisionTokens[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.ProvisionTokens[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ProvisionTokenV2List\n} // ProvisionTokenV2List\n\n/**\n * TokenRule is a rule that a joining node must match in order to use the\n *  associated token.\n */\nexport class TokenRule {\n  // AWSAccount is the AWS account ID.\n  public AWSAccount: string = \"\";\n  /**\n   * AWSRegions is used for the EC2 join method and is a list of AWS regions a\n   *  node is allowed to join from.\n   */\n  public AWSRegions: Array<string> = new Array<string>();\n  /**\n   * AWSRole is used for the EC2 join method and is the the ARN of the AWS\n   *  role that the auth server will assume in order to call the ec2 API.\n   */\n  public AWSRole: string = \"\";\n  /**\n   * AWSARN is used for the IAM join method, the AWS identity of joining nodes\n   *  must match this ARN. Supports wildcards \"*\" and \"?\".\n   */\n  public AWSARN: string = \"\";\n\n  // Decodes TokenRule from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TokenRule {\n    return TokenRule.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TokenRule from a DataView\n  static decodeDataView(view: DataView): TokenRule {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TokenRule();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.AWSAccount = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.AWSRegions.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.AWSRole = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.AWSARN = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TokenRule\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.AWSAccount.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.AWSAccount.length) +\n          this.AWSAccount.length\n        : 0;\n\n    size += __size_string_repeated(this.AWSRegions);\n\n    size +=\n      this.AWSRole.length > 0\n        ? 1 + __proto.Sizer.varint64(this.AWSRole.length) + this.AWSRole.length\n        : 0;\n    size +=\n      this.AWSARN.length > 0\n        ? 1 + __proto.Sizer.varint64(this.AWSARN.length) + this.AWSARN.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes TokenRule to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TokenRule to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.AWSAccount.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.AWSAccount.length);\n      encoder.string(this.AWSAccount);\n    }\n\n    if (this.AWSRegions.length > 0) {\n      for (let n: i32 = 0; n < this.AWSRegions.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.AWSRegions[n].length);\n        encoder.string(this.AWSRegions[n]);\n      }\n    }\n\n    if (this.AWSRole.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.AWSRole.length);\n      encoder.string(this.AWSRole);\n    }\n    if (this.AWSARN.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.AWSARN.length);\n      encoder.string(this.AWSARN);\n    }\n\n    return buf;\n  } // encode TokenRule\n} // TokenRule\n\n// ProvisionTokenSpecV2 is a specification for V2 token\nexport class ProvisionTokenSpecV2 {\n  /**\n   * Roles is a list of roles associated with the token,\n   *  that will be converted to metadata in the SSH and X509\n   *  certificates issued to the user of the token\n   */\n  public Roles: Array<string> = new Array<string>();\n  /**\n   * Allow is a list of TokenRules, nodes using this token must match one\n   *  allow rule to use this token.\n   */\n  public Allow: Array<TokenRule> = new Array<TokenRule>();\n  /**\n   * AWSIIDTTL is the TTL to use for AWS EC2 Instance Identity Documents used\n   *  to join the cluster with this token.\n   */\n  public AWSIIDTTL: i64;\n  /**\n   * JoinMethod is the joining method required in order to use this token.\n   *  Supported joining methods include \"token\", \"ec2\", and \"iam\".\n   */\n  public JoinMethod: string = \"\";\n  // BotName is the name of the bot this token grants access to, if any\n  public BotName: string = \"\";\n\n  // Decodes ProvisionTokenSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ProvisionTokenSpecV2 {\n    return ProvisionTokenSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ProvisionTokenSpecV2 from a DataView\n  static decodeDataView(view: DataView): ProvisionTokenSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ProvisionTokenSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Allow.push(\n            TokenRule.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          obj.AWSIIDTTL = decoder.int64();\n          break;\n        }\n        case 4: {\n          obj.JoinMethod = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.BotName = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ProvisionTokenSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += __size_string_repeated(this.Roles);\n\n    for (let n: i32 = 0; n < this.Allow.length; n++) {\n      const messageSize = this.Allow[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += this.AWSIIDTTL == 0 ? 0 : 1 + __proto.Sizer.int64(this.AWSIIDTTL);\n    size +=\n      this.JoinMethod.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.JoinMethod.length) +\n          this.JoinMethod.length\n        : 0;\n    size +=\n      this.BotName.length > 0\n        ? 1 + __proto.Sizer.varint64(this.BotName.length) + this.BotName.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ProvisionTokenSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ProvisionTokenSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Allow.length; n++) {\n      const messageSize = this.Allow[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        this.Allow[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AWSIIDTTL != 0) {\n      encoder.uint32(0x18);\n      encoder.int64(this.AWSIIDTTL);\n    }\n    if (this.JoinMethod.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.JoinMethod.length);\n      encoder.string(this.JoinMethod);\n    }\n    if (this.BotName.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.BotName.length);\n      encoder.string(this.BotName);\n    }\n\n    return buf;\n  } // encode ProvisionTokenSpecV2\n} // ProvisionTokenSpecV2\n\n// StaticTokensV2 implements the StaticTokens interface.\nexport class StaticTokensV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a provisioning token V2 spec\n  public Spec: StaticTokensSpecV2 = new StaticTokensSpecV2();\n\n  // Decodes StaticTokensV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): StaticTokensV2 {\n    return StaticTokensV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes StaticTokensV2 from a DataView\n  static decodeDataView(view: DataView): StaticTokensV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new StaticTokensV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = StaticTokensSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode StaticTokensV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: StaticTokensSpecV2 = this.Spec as StaticTokensSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes StaticTokensV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes StaticTokensV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as StaticTokensSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode StaticTokensV2\n} // StaticTokensV2\n\n// StaticTokensSpecV2 is the actual data we care about for StaticTokensSpecV2.\nexport class StaticTokensSpecV2 {\n  /**\n   * StaticTokens is a list of tokens that can be used to add nodes to the\n   *  cluster.\n   */\n  public StaticTokens: Array<ProvisionTokenV1> = new Array<ProvisionTokenV1>();\n\n  // Decodes StaticTokensSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): StaticTokensSpecV2 {\n    return StaticTokensSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes StaticTokensSpecV2 from a DataView\n  static decodeDataView(view: DataView): StaticTokensSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new StaticTokensSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.StaticTokens.push(\n            ProvisionTokenV1.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode StaticTokensSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.StaticTokens.length; n++) {\n      const messageSize = this.StaticTokens[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes StaticTokensSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes StaticTokensSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.StaticTokens.length; n++) {\n      const messageSize = this.StaticTokens[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.StaticTokens[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode StaticTokensSpecV2\n} // StaticTokensSpecV2\n\n// ClusterNameV2 implements the ClusterName interface.\nexport class ClusterNameV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a cluster name V2 spec\n  public Spec: ClusterNameSpecV2 = new ClusterNameSpecV2();\n\n  // Decodes ClusterNameV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ClusterNameV2 {\n    return ClusterNameV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ClusterNameV2 from a DataView\n  static decodeDataView(view: DataView): ClusterNameV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ClusterNameV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = ClusterNameSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ClusterNameV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: ClusterNameSpecV2 = this.Spec as ClusterNameSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ClusterNameV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ClusterNameV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as ClusterNameSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ClusterNameV2\n} // ClusterNameV2\n\n// ClusterNameSpecV2 is the actual data we care about for ClusterName.\nexport class ClusterNameSpecV2 {\n  /**\n   * ClusterName is the name of the cluster. Changing this value once the\n   *  cluster is setup can and will cause catastrophic problems.\n   */\n  public ClusterName: string = \"\";\n  /**\n   * ClusterID is the unique cluster ID that is set once during the first\n   *  auth server startup.\n   */\n  public ClusterID: string = \"\";\n\n  // Decodes ClusterNameSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ClusterNameSpecV2 {\n    return ClusterNameSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ClusterNameSpecV2 from a DataView\n  static decodeDataView(view: DataView): ClusterNameSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ClusterNameSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ClusterName = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.ClusterID = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ClusterNameSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ClusterName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClusterName.length) +\n          this.ClusterName.length\n        : 0;\n    size +=\n      this.ClusterID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClusterID.length) +\n          this.ClusterID.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ClusterNameSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ClusterNameSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ClusterName.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.ClusterName.length);\n      encoder.string(this.ClusterName);\n    }\n    if (this.ClusterID.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.ClusterID.length);\n      encoder.string(this.ClusterID);\n    }\n\n    return buf;\n  } // encode ClusterNameSpecV2\n} // ClusterNameSpecV2\n\n// ClusterAuditConfigV2 represents audit log settings in the cluster.\nexport class ClusterAuditConfigV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is a resource version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a ClusterAuditConfig specification\n  public Spec: ClusterAuditConfigSpecV2 = new ClusterAuditConfigSpecV2();\n\n  // Decodes ClusterAuditConfigV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ClusterAuditConfigV2 {\n    return ClusterAuditConfigV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ClusterAuditConfigV2 from a DataView\n  static decodeDataView(view: DataView): ClusterAuditConfigV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ClusterAuditConfigV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = ClusterAuditConfigSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ClusterAuditConfigV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: ClusterAuditConfigSpecV2 = this.Spec as ClusterAuditConfigSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ClusterAuditConfigV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ClusterAuditConfigV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as ClusterAuditConfigSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ClusterAuditConfigV2\n} // ClusterAuditConfigV2\n\n/**\n * ClusterAuditConfigSpecV2 is the actual data we care about\n *  for ClusterAuditConfig.\n */\nexport class ClusterAuditConfigSpecV2 {\n  // Type is audit backend type\n  public Type: string = \"\";\n  // Region is a region setting for audit sessions used by cloud providers\n  public Region: string = \"\";\n  // AuditSessionsURI is a parameter where to upload sessions\n  public AuditSessionsURI: string = \"\";\n  /**\n   * AuditEventsURI is a parameter with all supported outputs\n   *  for audit events\n   */\n  public AuditEventsURI: wrappers.StringValues = new wrappers.StringValues();\n  // EnableContinuousBackups is used to enable (or disable) PITR (Point-In-Time Recovery).\n  public EnableContinuousBackups: bool;\n  // EnableAutoScaling is used to enable (or disable) auto scaling policy.\n  public EnableAutoScaling: bool;\n  // ReadMaxCapacity is the maximum provisioned read capacity.\n  public ReadMaxCapacity: i64;\n  // ReadMinCapacity is the minimum provisioned read capacity.\n  public ReadMinCapacity: i64;\n  // ReadTargetValue is the ratio of consumed read to provisioned capacity.\n  public ReadTargetValue: f64;\n  // WriteMaxCapacity is the maximum provisioned write capacity.\n  public WriteMaxCapacity: i64;\n  // WriteMinCapacity is the minimum provisioned write capacity.\n  public WriteMinCapacity: i64;\n  // WriteTargetValue is the ratio of consumed write to provisioned capacity.\n  public WriteTargetValue: f64;\n  // RetentionPeriod is the retention period for audit events.\n  public RetentionPeriod: i64;\n\n  // Decodes ClusterAuditConfigSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ClusterAuditConfigSpecV2 {\n    return ClusterAuditConfigSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ClusterAuditConfigSpecV2 from a DataView\n  static decodeDataView(view: DataView): ClusterAuditConfigSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ClusterAuditConfigSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Type = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Region = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.AuditSessionsURI = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.AuditEventsURI = wrappers.StringValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.EnableContinuousBackups = decoder.bool();\n          break;\n        }\n        case 7: {\n          obj.EnableAutoScaling = decoder.bool();\n          break;\n        }\n        case 8: {\n          obj.ReadMaxCapacity = decoder.int64();\n          break;\n        }\n        case 9: {\n          obj.ReadMinCapacity = decoder.int64();\n          break;\n        }\n        case 10: {\n          obj.ReadTargetValue = decoder.double();\n          break;\n        }\n        case 11: {\n          obj.WriteMaxCapacity = decoder.int64();\n          break;\n        }\n        case 12: {\n          obj.WriteMinCapacity = decoder.int64();\n          break;\n        }\n        case 13: {\n          obj.WriteTargetValue = decoder.double();\n          break;\n        }\n        case 14: {\n          obj.RetentionPeriod = decoder.int64();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ClusterAuditConfigSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Type.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Type.length) + this.Type.length\n        : 0;\n    size +=\n      this.Region.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Region.length) + this.Region.length\n        : 0;\n    size +=\n      this.AuditSessionsURI.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.AuditSessionsURI.length) +\n          this.AuditSessionsURI.length\n        : 0;\n\n    if (this.AuditEventsURI != null) {\n      const f: wrappers.StringValues = this\n        .AuditEventsURI as wrappers.StringValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += this.EnableContinuousBackups == 0 ? 0 : 1 + 1;\n    size += this.EnableAutoScaling == 0 ? 0 : 1 + 1;\n    size +=\n      this.ReadMaxCapacity == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.ReadMaxCapacity);\n    size +=\n      this.ReadMinCapacity == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.ReadMinCapacity);\n    size += this.ReadTargetValue == 0 ? 0 : 1 + 8;\n    size +=\n      this.WriteMaxCapacity == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.WriteMaxCapacity);\n    size +=\n      this.WriteMinCapacity == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.WriteMinCapacity);\n    size += this.WriteTargetValue == 0 ? 0 : 1 + 8;\n    size +=\n      this.RetentionPeriod == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.RetentionPeriod);\n\n    return size;\n  }\n\n  // Encodes ClusterAuditConfigSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ClusterAuditConfigSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Type.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Type.length);\n      encoder.string(this.Type);\n    }\n    if (this.Region.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Region.length);\n      encoder.string(this.Region);\n    }\n    if (this.AuditSessionsURI.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.AuditSessionsURI.length);\n      encoder.string(this.AuditSessionsURI);\n    }\n\n    if (this.AuditEventsURI != null) {\n      const f = this.AuditEventsURI as wrappers.StringValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.EnableContinuousBackups != 0) {\n      encoder.uint32(0x30);\n      encoder.bool(this.EnableContinuousBackups);\n    }\n    if (this.EnableAutoScaling != 0) {\n      encoder.uint32(0x38);\n      encoder.bool(this.EnableAutoScaling);\n    }\n    if (this.ReadMaxCapacity != 0) {\n      encoder.uint32(0x40);\n      encoder.int64(this.ReadMaxCapacity);\n    }\n    if (this.ReadMinCapacity != 0) {\n      encoder.uint32(0x48);\n      encoder.int64(this.ReadMinCapacity);\n    }\n    if (this.ReadTargetValue != 0) {\n      encoder.uint32(0x51);\n      encoder.double(this.ReadTargetValue);\n    }\n    if (this.WriteMaxCapacity != 0) {\n      encoder.uint32(0x58);\n      encoder.int64(this.WriteMaxCapacity);\n    }\n    if (this.WriteMinCapacity != 0) {\n      encoder.uint32(0x60);\n      encoder.int64(this.WriteMinCapacity);\n    }\n    if (this.WriteTargetValue != 0) {\n      encoder.uint32(0x69);\n      encoder.double(this.WriteTargetValue);\n    }\n    if (this.RetentionPeriod != 0) {\n      encoder.uint32(0x70);\n      encoder.int64(this.RetentionPeriod);\n    }\n\n    return buf;\n  } // encode ClusterAuditConfigSpecV2\n} // ClusterAuditConfigSpecV2\n\n// ClusterNetworkingConfigV2 contains cluster-wide networking configuration.\nexport class ClusterNetworkingConfigV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is a resource version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a ClusterNetworkingConfig specification\n  public Spec: ClusterNetworkingConfigSpecV2 =\n    new ClusterNetworkingConfigSpecV2();\n\n  // Decodes ClusterNetworkingConfigV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ClusterNetworkingConfigV2 {\n    return ClusterNetworkingConfigV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ClusterNetworkingConfigV2 from a DataView\n  static decodeDataView(view: DataView): ClusterNetworkingConfigV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ClusterNetworkingConfigV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = ClusterNetworkingConfigSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ClusterNetworkingConfigV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: ClusterNetworkingConfigSpecV2 = this\n        .Spec as ClusterNetworkingConfigSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ClusterNetworkingConfigV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ClusterNetworkingConfigV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as ClusterNetworkingConfigSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ClusterNetworkingConfigV2\n} // ClusterNetworkingConfigV2\n\n/**\n * ClusterNetworkingConfigSpecV2 is the actual data we care about\n *  for ClusterNetworkingConfig.\n */\nexport class ClusterNetworkingConfigSpecV2 {\n  /**\n   * ClientIdleTimeout sets global cluster default setting for client idle\n   *  timeouts.\n   */\n  public ClientIdleTimeout: i64;\n  /**\n   * KeepAliveInterval is the interval at which the server sends keep-alive messages\n   *  to the client.\n   */\n  public KeepAliveInterval: i64;\n  /**\n   * KeepAliveCountMax is the number of keep-alive messages that can be\n   *  missed before the server disconnects the connection to the client.\n   */\n  public KeepAliveCountMax: i64;\n  /**\n   * SessionControlTimeout is the session control lease expiry and defines\n   *  the upper limit of how long a node may be out of contact with the auth\n   *  server before it begins terminating controlled sessions.\n   */\n  public SessionControlTimeout: i64;\n  // ClientIdleTimeoutMessage is the message sent to the user when a connection times out.\n  public ClientIdleTimeoutMessage: string = \"\";\n  /**\n   * WebIdleTimeout sets global cluster default setting for the web UI idle\n   *  timeouts.\n   */\n  public WebIdleTimeout: i64;\n  // ProxyListenerMode is proxy listener mode used by Teleport Proxies.\n  public ProxyListenerMode: u32;\n  // RoutingStrategy determines the strategy used to route to nodes.\n  public RoutingStrategy: u32;\n\n  // Decodes ClusterNetworkingConfigSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ClusterNetworkingConfigSpecV2 {\n    return ClusterNetworkingConfigSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ClusterNetworkingConfigSpecV2 from a DataView\n  static decodeDataView(view: DataView): ClusterNetworkingConfigSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ClusterNetworkingConfigSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ClientIdleTimeout = decoder.int64();\n          break;\n        }\n        case 2: {\n          obj.KeepAliveInterval = decoder.int64();\n          break;\n        }\n        case 3: {\n          obj.KeepAliveCountMax = decoder.int64();\n          break;\n        }\n        case 4: {\n          obj.SessionControlTimeout = decoder.int64();\n          break;\n        }\n        case 5: {\n          obj.ClientIdleTimeoutMessage = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.WebIdleTimeout = decoder.int64();\n          break;\n        }\n        case 7: {\n          obj.ProxyListenerMode = decoder.uint32();\n          break;\n        }\n        case 8: {\n          obj.RoutingStrategy = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ClusterNetworkingConfigSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ClientIdleTimeout == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.ClientIdleTimeout);\n    size +=\n      this.KeepAliveInterval == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.KeepAliveInterval);\n    size +=\n      this.KeepAliveCountMax == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.KeepAliveCountMax);\n    size +=\n      this.SessionControlTimeout == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.SessionControlTimeout);\n    size +=\n      this.ClientIdleTimeoutMessage.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClientIdleTimeoutMessage.length) +\n          this.ClientIdleTimeoutMessage.length\n        : 0;\n    size +=\n      this.WebIdleTimeout == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.WebIdleTimeout);\n    size +=\n      this.ProxyListenerMode == 0\n        ? 0\n        : 1 + __proto.Sizer.uint32(this.ProxyListenerMode);\n    size +=\n      this.RoutingStrategy == 0\n        ? 0\n        : 1 + __proto.Sizer.uint32(this.RoutingStrategy);\n\n    return size;\n  }\n\n  // Encodes ClusterNetworkingConfigSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ClusterNetworkingConfigSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ClientIdleTimeout != 0) {\n      encoder.uint32(0x8);\n      encoder.int64(this.ClientIdleTimeout);\n    }\n    if (this.KeepAliveInterval != 0) {\n      encoder.uint32(0x10);\n      encoder.int64(this.KeepAliveInterval);\n    }\n    if (this.KeepAliveCountMax != 0) {\n      encoder.uint32(0x18);\n      encoder.int64(this.KeepAliveCountMax);\n    }\n    if (this.SessionControlTimeout != 0) {\n      encoder.uint32(0x20);\n      encoder.int64(this.SessionControlTimeout);\n    }\n    if (this.ClientIdleTimeoutMessage.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.ClientIdleTimeoutMessage.length);\n      encoder.string(this.ClientIdleTimeoutMessage);\n    }\n    if (this.WebIdleTimeout != 0) {\n      encoder.uint32(0x30);\n      encoder.int64(this.WebIdleTimeout);\n    }\n    if (this.ProxyListenerMode != 0) {\n      encoder.uint32(0x38);\n      encoder.uint32(this.ProxyListenerMode);\n    }\n    if (this.RoutingStrategy != 0) {\n      encoder.uint32(0x40);\n      encoder.uint32(this.RoutingStrategy);\n    }\n\n    return buf;\n  } // encode ClusterNetworkingConfigSpecV2\n} // ClusterNetworkingConfigSpecV2\n\n// SessionRecordingConfigV2 contains session recording configuration.\nexport class SessionRecordingConfigV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is a resource version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a SessionRecordingConfig specification\n  public Spec: SessionRecordingConfigSpecV2 =\n    new SessionRecordingConfigSpecV2();\n\n  // Decodes SessionRecordingConfigV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionRecordingConfigV2 {\n    return SessionRecordingConfigV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionRecordingConfigV2 from a DataView\n  static decodeDataView(view: DataView): SessionRecordingConfigV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionRecordingConfigV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = SessionRecordingConfigSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionRecordingConfigV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: SessionRecordingConfigSpecV2 = this\n        .Spec as SessionRecordingConfigSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SessionRecordingConfigV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionRecordingConfigV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as SessionRecordingConfigSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SessionRecordingConfigV2\n} // SessionRecordingConfigV2\n\n/**\n * SessionRecordingConfigSpecV2 is the actual data we care about\n *  for SessionRecordingConfig.\n */\nexport class SessionRecordingConfigSpecV2 {\n  // Mode controls where (or if) the session is recorded.\n  public Mode: string = \"\";\n  /**\n   * ProxyChecksHostKeys is used to control if the proxy will check host keys\n   *  when in recording mode.\n   */\n  public ProxyChecksHostKeys: BoolValue = new BoolValue();\n\n  // Decodes SessionRecordingConfigSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionRecordingConfigSpecV2 {\n    return SessionRecordingConfigSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionRecordingConfigSpecV2 from a DataView\n  static decodeDataView(view: DataView): SessionRecordingConfigSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionRecordingConfigSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Mode = decoder.string();\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.ProxyChecksHostKeys = BoolValue.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionRecordingConfigSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Mode.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Mode.length) + this.Mode.length\n        : 0;\n\n    if (this.ProxyChecksHostKeys != null) {\n      const f: BoolValue = this.ProxyChecksHostKeys as BoolValue;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SessionRecordingConfigSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionRecordingConfigSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Mode.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Mode.length);\n      encoder.string(this.Mode);\n    }\n\n    if (this.ProxyChecksHostKeys != null) {\n      const f = this.ProxyChecksHostKeys as BoolValue;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SessionRecordingConfigSpecV2\n} // SessionRecordingConfigSpecV2\n\n// AuthPreferenceV2 implements the AuthPreference interface.\nexport class AuthPreferenceV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is a resource version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is an AuthPreference specification\n  public Spec: AuthPreferenceSpecV2 = new AuthPreferenceSpecV2();\n\n  // Decodes AuthPreferenceV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AuthPreferenceV2 {\n    return AuthPreferenceV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AuthPreferenceV2 from a DataView\n  static decodeDataView(view: DataView): AuthPreferenceV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AuthPreferenceV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = AuthPreferenceSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AuthPreferenceV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: AuthPreferenceSpecV2 = this.Spec as AuthPreferenceSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AuthPreferenceV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AuthPreferenceV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as AuthPreferenceSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AuthPreferenceV2\n} // AuthPreferenceV2\n\n// AuthPreferenceSpecV2 is the actual data we care about for AuthPreference.\nexport class AuthPreferenceSpecV2 {\n  // Type is the type of authentication.\n  public Type: string = \"\";\n  // SecondFactor is the type of second factor.\n  public SecondFactor: string = \"\";\n  /**\n   * ConnectorName is the name of the OIDC or SAML connector. If this value is\n   *  not set the first connector in the backend will be used.\n   */\n  public ConnectorName: string = \"\";\n  // U2F are the settings for the U2F device.\n  public U2F: U2F = new U2F();\n  /**\n   * RequireSessionMFA causes all sessions in this cluster to require MFA\n   *  checks.\n   */\n  public RequireSessionMFA: bool;\n  /**\n   * DisconnectExpiredCert provides disconnect expired certificate setting -\n   *  if true, connections with expired client certificates will get disconnected\n   */\n  public DisconnectExpiredCert: BoolValue = new BoolValue();\n  // AllowLocalAuth is true if local authentication is enabled.\n  public AllowLocalAuth: BoolValue = new BoolValue();\n  public MessageOfTheDay: string = \"\";\n  // LockingMode is the cluster-wide locking mode default.\n  public LockingMode: string = \"\";\n  // Webauthn are the settings for server-side Web Authentication support.\n  public Webauthn: Webauthn = new Webauthn();\n\n  // Decodes AuthPreferenceSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AuthPreferenceSpecV2 {\n    return AuthPreferenceSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AuthPreferenceSpecV2 from a DataView\n  static decodeDataView(view: DataView): AuthPreferenceSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AuthPreferenceSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Type = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SecondFactor = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.ConnectorName = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.U2F = U2F.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.RequireSessionMFA = decoder.bool();\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.DisconnectExpiredCert = BoolValue.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.AllowLocalAuth = BoolValue.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 8: {\n          obj.MessageOfTheDay = decoder.string();\n          break;\n        }\n        case 9: {\n          obj.LockingMode = decoder.string();\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.Webauthn = Webauthn.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AuthPreferenceSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Type.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Type.length) + this.Type.length\n        : 0;\n    size +=\n      this.SecondFactor.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SecondFactor.length) +\n          this.SecondFactor.length\n        : 0;\n    size +=\n      this.ConnectorName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ConnectorName.length) +\n          this.ConnectorName.length\n        : 0;\n\n    if (this.U2F != null) {\n      const f: U2F = this.U2F as U2F;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += this.RequireSessionMFA == 0 ? 0 : 1 + 1;\n\n    if (this.DisconnectExpiredCert != null) {\n      const f: BoolValue = this.DisconnectExpiredCert as BoolValue;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AllowLocalAuth != null) {\n      const f: BoolValue = this.AllowLocalAuth as BoolValue;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.MessageOfTheDay.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.MessageOfTheDay.length) +\n          this.MessageOfTheDay.length\n        : 0;\n    size +=\n      this.LockingMode.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.LockingMode.length) +\n          this.LockingMode.length\n        : 0;\n\n    if (this.Webauthn != null) {\n      const f: Webauthn = this.Webauthn as Webauthn;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AuthPreferenceSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AuthPreferenceSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Type.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Type.length);\n      encoder.string(this.Type);\n    }\n    if (this.SecondFactor.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SecondFactor.length);\n      encoder.string(this.SecondFactor);\n    }\n    if (this.ConnectorName.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.ConnectorName.length);\n      encoder.string(this.ConnectorName);\n    }\n\n    if (this.U2F != null) {\n      const f = this.U2F as U2F;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RequireSessionMFA != 0) {\n      encoder.uint32(0x28);\n      encoder.bool(this.RequireSessionMFA);\n    }\n\n    if (this.DisconnectExpiredCert != null) {\n      const f = this.DisconnectExpiredCert as BoolValue;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AllowLocalAuth != null) {\n      const f = this.AllowLocalAuth as BoolValue;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.MessageOfTheDay.length > 0) {\n      encoder.uint32(0x42);\n      encoder.uint32(this.MessageOfTheDay.length);\n      encoder.string(this.MessageOfTheDay);\n    }\n    if (this.LockingMode.length > 0) {\n      encoder.uint32(0x4a);\n      encoder.uint32(this.LockingMode.length);\n      encoder.string(this.LockingMode);\n    }\n\n    if (this.Webauthn != null) {\n      const f = this.Webauthn as Webauthn;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AuthPreferenceSpecV2\n} // AuthPreferenceSpecV2\n\n// U2F defines settings for U2F device.\nexport class U2F {\n  // AppID returns the application ID for universal second factor.\n  public AppID: string = \"\";\n  /**\n   * Facets returns the facets for universal second factor.\n   *  DELETE IN 11.0, time to sunset U2F (codingllama).\n   */\n  public Facets: Array<string> = new Array<string>();\n  /**\n   * DeviceAttestationCAs contains the trusted attestation CAs for U2F\n   *  devices.\n   *  DELETE IN 11.0, time to sunset U2F (codingllama).\n   */\n  public DeviceAttestationCAs: Array<string> = new Array<string>();\n\n  // Decodes U2F from an ArrayBuffer\n  static decode(buf: ArrayBuffer): U2F {\n    return U2F.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes U2F from a DataView\n  static decodeDataView(view: DataView): U2F {\n    const decoder = new __proto.Decoder(view);\n    const obj = new U2F();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.AppID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Facets.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.DeviceAttestationCAs.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode U2F\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.AppID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.AppID.length) + this.AppID.length\n        : 0;\n\n    size += __size_string_repeated(this.Facets);\n\n    size += __size_string_repeated(this.DeviceAttestationCAs);\n\n    return size;\n  }\n\n  // Encodes U2F to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes U2F to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.AppID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.AppID.length);\n      encoder.string(this.AppID);\n    }\n\n    if (this.Facets.length > 0) {\n      for (let n: i32 = 0; n < this.Facets.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.Facets[n].length);\n        encoder.string(this.Facets[n]);\n      }\n    }\n\n    if (this.DeviceAttestationCAs.length > 0) {\n      for (let n: i32 = 0; n < this.DeviceAttestationCAs.length; n++) {\n        encoder.uint32(0x1a);\n        encoder.uint32(this.DeviceAttestationCAs[n].length);\n        encoder.string(this.DeviceAttestationCAs[n]);\n      }\n    }\n\n    return buf;\n  } // encode U2F\n} // U2F\n\n/**\n * Webauthn defines user-visible settings for server-side Web Authentication\n *  support.\n */\nexport class Webauthn {\n  /**\n   * RPID is the ID of the Relying Party.\n   *  It should be set to the domain name of the Teleport installation.\n   *\n   *  IMPORTANT: RPID must never change in the lifetime of the cluster, because\n   *  it's recorded in the registration data on the WebAuthn device. If the\n   *  RPID changes, all existing WebAuthn key registrations will become invalid\n   *  and all users who use WebAuthn as the second factor will need to\n   *  re-register.\n   */\n  public RPID: string = \"\";\n  /**\n   * Allow list of device attestation CAs in PEM format.\n   *  If present, only devices whose attestation certificates match the\n   *  certificates specified here may be registered (existing registrations are\n   *  unchanged).\n   *  If supplied in conjunction with AttestationDeniedCAs, then both\n   *  conditions need to be true for registration to be allowed (the device\n   *  MUST match an allowed CA and MUST NOT match a denied CA).\n   *  By default all devices are allowed.\n   */\n  public AttestationAllowedCAs: Array<string> = new Array<string>();\n  /**\n   * Deny list of device attestation CAs in PEM format.\n   *  If present, only devices whose attestation certificates don't match the\n   *  certificates specified here may be registered (existing registrations are\n   *  unchanged).\n   *  If supplied in conjunction with AttestationAllowedCAs, then both\n   *  conditions need to be true for registration to be allowed (the device\n   *  MUST match an allowed CA and MUST NOT match a denied CA).\n   *  By default no devices are denied.\n   */\n  public AttestationDeniedCAs: Array<string> = new Array<string>();\n\n  // Decodes Webauthn from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Webauthn {\n    return Webauthn.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Webauthn from a DataView\n  static decodeDataView(view: DataView): Webauthn {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Webauthn();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.RPID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.AttestationAllowedCAs.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.AttestationDeniedCAs.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Webauthn\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.RPID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.RPID.length) + this.RPID.length\n        : 0;\n\n    size += __size_string_repeated(this.AttestationAllowedCAs);\n\n    size += __size_string_repeated(this.AttestationDeniedCAs);\n\n    return size;\n  }\n\n  // Encodes Webauthn to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Webauthn to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.RPID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.RPID.length);\n      encoder.string(this.RPID);\n    }\n\n    if (this.AttestationAllowedCAs.length > 0) {\n      for (let n: i32 = 0; n < this.AttestationAllowedCAs.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.AttestationAllowedCAs[n].length);\n        encoder.string(this.AttestationAllowedCAs[n]);\n      }\n    }\n\n    if (this.AttestationDeniedCAs.length > 0) {\n      for (let n: i32 = 0; n < this.AttestationDeniedCAs.length; n++) {\n        encoder.uint32(0x1a);\n        encoder.uint32(this.AttestationDeniedCAs[n].length);\n        encoder.string(this.AttestationDeniedCAs[n]);\n      }\n    }\n\n    return buf;\n  } // encode Webauthn\n} // Webauthn\n\n// Namespace represents namespace resource specification\nexport class Namespace {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a namespace spec\n  public Spec: NamespaceSpec = new NamespaceSpec();\n\n  // Decodes Namespace from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Namespace {\n    return Namespace.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Namespace from a DataView\n  static decodeDataView(view: DataView): Namespace {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Namespace();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = NamespaceSpec.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Namespace\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: NamespaceSpec = this.Spec as NamespaceSpec;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes Namespace to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Namespace to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as NamespaceSpec;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode Namespace\n} // Namespace\n\n// NamespaceSpec is a namespace specificateion\nexport class NamespaceSpec {\n  // Decodes NamespaceSpec from an ArrayBuffer\n  static decode(buf: ArrayBuffer): NamespaceSpec {\n    return NamespaceSpec.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes NamespaceSpec from a DataView\n  static decodeDataView(view: DataView): NamespaceSpec {\n    const decoder = new __proto.Decoder(view);\n    const obj = new NamespaceSpec();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode NamespaceSpec\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    return size;\n  }\n\n  // Encodes NamespaceSpec to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes NamespaceSpec to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    return buf;\n  } // encode NamespaceSpec\n} // NamespaceSpec\n\nexport class UserTokenV3 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is a resource sub kind, used to define the type of user token.\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is an resource specification\n  public Spec: UserTokenSpecV3 = new UserTokenSpecV3();\n\n  // Decodes UserTokenV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserTokenV3 {\n    return UserTokenV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserTokenV3 from a DataView\n  static decodeDataView(view: DataView): UserTokenV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserTokenV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = UserTokenSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserTokenV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: UserTokenSpecV3 = this.Spec as UserTokenSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes UserTokenV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserTokenV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as UserTokenSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode UserTokenV3\n} // UserTokenV3\n\nexport class UserTokenSpecV3 {\n  // User is user name associated with this token\n  public User: string = \"\";\n  // URL is this token URL\n  public URL: string = \"\";\n  // Usage is an optional field that provides more information about how this token will be used.\n  public Usage: u32;\n  // Created holds information about when the token was created\n  public Created: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n\n  // Decodes UserTokenSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserTokenSpecV3 {\n    return UserTokenSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserTokenSpecV3 from a DataView\n  static decodeDataView(view: DataView): UserTokenSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserTokenSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.URL = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Usage = decoder.uint32();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Created = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserTokenSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size +=\n      this.URL.length > 0\n        ? 1 + __proto.Sizer.varint64(this.URL.length) + this.URL.length\n        : 0;\n    size += this.Usage == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Usage);\n\n    if (this.Created != null) {\n      const f: google.protobuf.Timestamp = this\n        .Created as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes UserTokenSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserTokenSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.URL.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.URL.length);\n      encoder.string(this.URL);\n    }\n    if (this.Usage != 0) {\n      encoder.uint32(0x18);\n      encoder.uint32(this.Usage);\n    }\n\n    if (this.Created != null) {\n      const f = this.Created as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode UserTokenSpecV3\n} // UserTokenSpecV3\n\nexport class UserTokenSecretsV3 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is an resource specification\n  public Spec: UserTokenSecretsSpecV3 = new UserTokenSecretsSpecV3();\n\n  // Decodes UserTokenSecretsV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserTokenSecretsV3 {\n    return UserTokenSecretsV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserTokenSecretsV3 from a DataView\n  static decodeDataView(view: DataView): UserTokenSecretsV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserTokenSecretsV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = UserTokenSecretsSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserTokenSecretsV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: UserTokenSecretsSpecV3 = this.Spec as UserTokenSecretsSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes UserTokenSecretsV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserTokenSecretsV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as UserTokenSecretsSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode UserTokenSecretsV3\n} // UserTokenSecretsV3\n\nexport class UserTokenSecretsSpecV3 {\n  // OTPKey is is a secret value of one time password secret generator\n  public OTPKey: string = \"\";\n  // OTPKey is is a secret value of one time password secret generator\n  public QRCode: string = \"\";\n  // Created holds information about when the token was created\n  public Created: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n\n  // Decodes UserTokenSecretsSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserTokenSecretsSpecV3 {\n    return UserTokenSecretsSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserTokenSecretsSpecV3 from a DataView\n  static decodeDataView(view: DataView): UserTokenSecretsSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserTokenSecretsSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.OTPKey = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.QRCode = decoder.string();\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Created = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserTokenSecretsSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.OTPKey.length > 0\n        ? 1 + __proto.Sizer.varint64(this.OTPKey.length) + this.OTPKey.length\n        : 0;\n    size +=\n      this.QRCode.length > 0\n        ? 1 + __proto.Sizer.varint64(this.QRCode.length) + this.QRCode.length\n        : 0;\n\n    if (this.Created != null) {\n      const f: google.protobuf.Timestamp = this\n        .Created as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes UserTokenSecretsSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserTokenSecretsSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.OTPKey.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.OTPKey.length);\n      encoder.string(this.OTPKey);\n    }\n    if (this.QRCode.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.QRCode.length);\n      encoder.string(this.QRCode);\n    }\n\n    if (this.Created != null) {\n      const f = this.Created as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode UserTokenSecretsSpecV3\n} // UserTokenSecretsSpecV3\n\n// AccessRequest represents an access request resource specification\nexport class AccessRequestV3 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is AccessRequest metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is an AccessRequest specification\n  public Spec: AccessRequestSpecV3 = new AccessRequestSpecV3();\n\n  // Decodes AccessRequestV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessRequestV3 {\n    return AccessRequestV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessRequestV3 from a DataView\n  static decodeDataView(view: DataView): AccessRequestV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessRequestV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = AccessRequestSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessRequestV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: AccessRequestSpecV3 = this.Spec as AccessRequestSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AccessRequestV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessRequestV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as AccessRequestSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AccessRequestV3\n} // AccessRequestV3\n\n/**\n * AccessReviewThreshold describes a filter used to match access reviews,\n *  as well as approval/denial counts which trigger state-transitions.  This type\n *  can be used to describe policies such as \"can be approved by 2 admins\"\n *  or \"can be denied by any non-contractor\".\n */\nexport class AccessReviewThreshold {\n  // Name is the optional human-readable name of the threshold.\n  public Name: string = \"\";\n  /**\n   * Filter is an optional predicate used to determine which reviews\n   *  count toward this threshold.\n   */\n  public Filter: string = \"\";\n  // Approve is the number of matching approvals needed for state-transition.\n  public Approve: u32;\n  // Deny is the number of denials needed for state-transition.\n  public Deny: u32;\n\n  // Decodes AccessReviewThreshold from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessReviewThreshold {\n    return AccessReviewThreshold.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessReviewThreshold from a DataView\n  static decodeDataView(view: DataView): AccessReviewThreshold {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessReviewThreshold();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Filter = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Approve = decoder.uint32();\n          break;\n        }\n        case 4: {\n          obj.Deny = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessReviewThreshold\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.Filter.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Filter.length) + this.Filter.length\n        : 0;\n    size += this.Approve == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Approve);\n    size += this.Deny == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Deny);\n\n    return size;\n  }\n\n  // Encodes AccessReviewThreshold to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessReviewThreshold to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.Filter.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Filter.length);\n      encoder.string(this.Filter);\n    }\n    if (this.Approve != 0) {\n      encoder.uint32(0x18);\n      encoder.uint32(this.Approve);\n    }\n    if (this.Deny != 0) {\n      encoder.uint32(0x20);\n      encoder.uint32(this.Deny);\n    }\n\n    return buf;\n  } // encode AccessReviewThreshold\n} // AccessReviewThreshold\n\n// AccessReview is a review to be applied to an access request.\nexport class AccessReview {\n  // Author is the teleport username of the review author.\n  public Author: string = \"\";\n  // Roles is a list used for role-subselection (not yet fully supported).\n  public Roles: Array<string> = new Array<string>();\n  // ProposedState is the proposed state (must be APPROVED or DENIED).\n  public ProposedState: u32;\n  /**\n   * Reason is an optional human-readable reason for why the above state\n   *  is being proposed.\n   */\n  public Reason: string = \"\";\n  // Created is the time at which the review was created.\n  public Created: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // Annotations is the proposed value of the request's resolve_annotations field.\n  public Annotations: wrappers.LabelValues = new wrappers.LabelValues();\n  /**\n   * ThresholdIndexes stores the indexes of thresholds which this review matches\n   *  (internal use only).\n   */\n  public ThresholdIndexes: Array<u32> = new Array<u32>();\n\n  // Decodes AccessReview from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessReview {\n    return AccessReview.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessReview from a DataView\n  static decodeDataView(view: DataView): AccessReview {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessReview();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Author = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.ProposedState = decoder.uint32();\n          break;\n        }\n        case 4: {\n          obj.Reason = decoder.string();\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Created = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.Annotations = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          obj.ThresholdIndexes.push(decoder.uint32());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessReview\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Author.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Author.length) + this.Author.length\n        : 0;\n\n    size += __size_string_repeated(this.Roles);\n\n    size +=\n      this.ProposedState == 0\n        ? 0\n        : 1 + __proto.Sizer.uint32(this.ProposedState);\n    size +=\n      this.Reason.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Reason.length) + this.Reason.length\n        : 0;\n\n    if (this.Created != null) {\n      const f: google.protobuf.Timestamp = this\n        .Created as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Annotations != null) {\n      const f: wrappers.LabelValues = this.Annotations as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_uint32_repeated(this.ThresholdIndexes);\n\n    return size;\n  }\n\n  // Encodes AccessReview to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessReview to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Author.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Author.length);\n      encoder.string(this.Author);\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    if (this.ProposedState != 0) {\n      encoder.uint32(0x18);\n      encoder.uint32(this.ProposedState);\n    }\n    if (this.Reason.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.Reason.length);\n      encoder.string(this.Reason);\n    }\n\n    if (this.Created != null) {\n      const f = this.Created as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Annotations != null) {\n      const f = this.Annotations as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.ThresholdIndexes.length > 0) {\n      for (let n: i32 = 0; n < this.ThresholdIndexes.length; n++) {\n        encoder.uint32(0x3a);\n        encoder.uint32(this.ThresholdIndexes[n]);\n      }\n    }\n\n    return buf;\n  } // encode AccessReview\n} // AccessReview\n\n/**\n * AccessReviewSubmission encodes the necessary parameters for submitting\n *  a new access review.\n */\nexport class AccessReviewSubmission {\n  // RequestID is the unique ID of the request to be reviewed.\n  public RequestID: string = \"\";\n  // Review is the review to be applied.\n  public Review: AccessReview = new AccessReview();\n\n  // Decodes AccessReviewSubmission from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessReviewSubmission {\n    return AccessReviewSubmission.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessReviewSubmission from a DataView\n  static decodeDataView(view: DataView): AccessReviewSubmission {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessReviewSubmission();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.RequestID = decoder.string();\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Review = AccessReview.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessReviewSubmission\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.RequestID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RequestID.length) +\n          this.RequestID.length\n        : 0;\n\n    if (this.Review != null) {\n      const f: AccessReview = this.Review as AccessReview;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AccessReviewSubmission to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessReviewSubmission to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.RequestID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.RequestID.length);\n      encoder.string(this.RequestID);\n    }\n\n    if (this.Review != null) {\n      const f = this.Review as AccessReview;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AccessReviewSubmission\n} // AccessReviewSubmission\n\n/**\n * ThresholdIndexSet encodes a list of threshold indexes. One of the listed thresholds\n *  must pass for the set to be considered to have passed (i.e. this is an `or` operator).\n */\nexport class ThresholdIndexSet {\n  // Indexes are the indexes of thresholds which relate to the role.\n  public Indexes: Array<u32> = new Array<u32>();\n\n  // Decodes ThresholdIndexSet from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ThresholdIndexSet {\n    return ThresholdIndexSet.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ThresholdIndexSet from a DataView\n  static decodeDataView(view: DataView): ThresholdIndexSet {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ThresholdIndexSet();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Indexes.push(decoder.uint32());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ThresholdIndexSet\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += __size_uint32_repeated(this.Indexes);\n\n    return size;\n  }\n\n  // Encodes ThresholdIndexSet to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ThresholdIndexSet to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Indexes.length > 0) {\n      for (let n: i32 = 0; n < this.Indexes.length; n++) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.Indexes[n]);\n      }\n    }\n\n    return buf;\n  } // encode ThresholdIndexSet\n} // ThresholdIndexSet\n\n/**\n * ThresholdIndexSets is a list of threshold index sets.  Each of the individual\n *  sets must pass (i.e. this is an `and` operator).\n */\nexport class ThresholdIndexSets {\n  // Sets are the sets that make up this group.\n  public Sets: Array<ThresholdIndexSet> = new Array<ThresholdIndexSet>();\n\n  // Decodes ThresholdIndexSets from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ThresholdIndexSets {\n    return ThresholdIndexSets.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ThresholdIndexSets from a DataView\n  static decodeDataView(view: DataView): ThresholdIndexSets {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ThresholdIndexSets();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Sets.push(\n            ThresholdIndexSet.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ThresholdIndexSets\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.Sets.length; n++) {\n      const messageSize = this.Sets[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ThresholdIndexSets to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ThresholdIndexSets to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.Sets.length; n++) {\n      const messageSize = this.Sets[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.Sets[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ThresholdIndexSets\n} // ThresholdIndexSets\n\n// AccessRequestSpec is the specification for AccessRequest\nexport class AccessRequestSpecV3 {\n  // User is the name of the user to whom the roles will be applied.\n  public User: string = \"\";\n  // Roles is the name of the roles being requested.\n  public Roles: Array<string> = new Array<string>();\n  // State is the current state of this access request.\n  public State: u32;\n  /**\n   * Created encodes the time at which the request was registered with the auth\n   *  server.\n   */\n  public Created: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  /**\n   * Expires constrains the maximum lifetime of any login session for which this\n   *  request is active.\n   */\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // RequestReason is an optional message explaining the reason for the request.\n  public RequestReason: string = \"\";\n  /**\n   * ResolveReason is an optional message explaining the reason for the resolution\n   *  of the request (approval, denail, etc...).\n   */\n  public ResolveReason: string = \"\";\n  /**\n   * ResolveAnnotations is a set of arbitrary values received from plugins or other\n   *  resolving parties during approval/denial.  Importantly, these annotations are\n   *  included in the access_request.update event, allowing plugins to propagate\n   *  arbitrary structured data to the audit log.\n   */\n  public ResolveAnnotations: wrappers.LabelValues = new wrappers.LabelValues();\n  /**\n   * SystemAnnotations is a set of programmatically generated annotations attached\n   *  to pending access requests by teleport.  These annotations are generated by\n   *  applying variable interpolation to the RoleConditions.Request.Annotations block\n   *  of a user's role(s).  These annotations serve as a mechanism for administrators\n   *  to pass extra information to plugins when they process pending access requests.\n   */\n  public SystemAnnotations: wrappers.LabelValues = new wrappers.LabelValues();\n  /**\n   * Thresholds is a list of review thresholds relevant to this request.  Order must be\n   *  preserved, as thresholds are referenced by index (internal use only).\n   */\n  public Thresholds: Array<AccessReviewThreshold> =\n    new Array<AccessReviewThreshold>();\n  /**\n   * RoleThresholdMapping encodes the relationship between the requested roles and\n   *  the review threshold requirements for the given role (internal use only).\n   *  By storing a representation of which thresholds must pass for each requested role, we\n   *  both eliminate the need to cache the requestor's roles directly, and allow future\n   *  versions of teleport to become smarter about calculating more granular requirements\n   *  in a backwards-compatible manner (i.e. calculation can become smarter in minor releases).\n   *  Storing this relationship on the request is necessary in order to avoid unexpected or\n   *  inconsistent behavior due to review submission timing.\n   */\n  public RoleThresholdMapping: Map<string, ThresholdIndexSets> = new Map<\n    string,\n    ThresholdIndexSets\n  >();\n  // Reviews is a list of reviews applied to this request (internal use only).\n  public Reviews: Array<AccessReview> = new Array<AccessReview>();\n  /**\n   * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but\n   *  that is not a requirement.\n   */\n  public SuggestedReviewers: Array<string> = new Array<string>();\n\n  // Decodes AccessRequestSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessRequestSpecV3 {\n    return AccessRequestSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessRequestSpecV3 from a DataView\n  static decodeDataView(view: DataView): AccessRequestSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessRequestSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.State = decoder.uint32();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Created = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.RequestReason = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.ResolveReason = decoder.string();\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.ResolveAnnotations = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 9: {\n          const length = decoder.uint32();\n          obj.SystemAnnotations = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.Thresholds.push(\n            AccessReviewThreshold.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 11: {\n          const length = decoder.uint32();\n          __decodeMap_string_ThresholdIndexSets(\n            decoder,\n            length,\n            obj.RoleThresholdMapping\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 12: {\n          const length = decoder.uint32();\n          obj.Reviews.push(\n            AccessReview.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 13: {\n          obj.SuggestedReviewers.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessRequestSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n\n    size += __size_string_repeated(this.Roles);\n\n    size += this.State == 0 ? 0 : 1 + __proto.Sizer.uint32(this.State);\n\n    if (this.Created != null) {\n      const f: google.protobuf.Timestamp = this\n        .Created as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.RequestReason.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RequestReason.length) +\n          this.RequestReason.length\n        : 0;\n    size +=\n      this.ResolveReason.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ResolveReason.length) +\n          this.ResolveReason.length\n        : 0;\n\n    if (this.ResolveAnnotations != null) {\n      const f: wrappers.LabelValues = this\n        .ResolveAnnotations as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SystemAnnotations != null) {\n      const f: wrappers.LabelValues = this\n        .SystemAnnotations as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Thresholds.length; n++) {\n      const messageSize = this.Thresholds[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.RoleThresholdMapping.size > 0) {\n      const keys = this.RoleThresholdMapping.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.RoleThresholdMapping.get(key);\n        const itemSize = __sizeMapEntry_string_ThresholdIndexSets(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Reviews.length; n++) {\n      const messageSize = this.Reviews[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.SuggestedReviewers);\n\n    return size;\n  }\n\n  // Encodes AccessRequestSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessRequestSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    if (this.State != 0) {\n      encoder.uint32(0x18);\n      encoder.uint32(this.State);\n    }\n\n    if (this.Created != null) {\n      const f = this.Created as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RequestReason.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.RequestReason.length);\n      encoder.string(this.RequestReason);\n    }\n    if (this.ResolveReason.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.ResolveReason.length);\n      encoder.string(this.ResolveReason);\n    }\n\n    if (this.ResolveAnnotations != null) {\n      const f = this.ResolveAnnotations as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SystemAnnotations != null) {\n      const f = this.SystemAnnotations as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x4a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Thresholds.length; n++) {\n      const messageSize = this.Thresholds[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        this.Thresholds[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RoleThresholdMapping.size > 0) {\n      const keys = this.RoleThresholdMapping.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.RoleThresholdMapping.get(key);\n        const size = __sizeMapEntry_string_ThresholdIndexSets(key, value);\n        if (size > 0) {\n          encoder.uint32(0x5a);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n\n          const messageSize = value.size();\n\n          if (messageSize > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(messageSize);\n            value.encodeU8Array(encoder);\n          }\n        }\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Reviews.length; n++) {\n      const messageSize = this.Reviews[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x62);\n        encoder.uint32(messageSize);\n        this.Reviews[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SuggestedReviewers.length > 0) {\n      for (let n: i32 = 0; n < this.SuggestedReviewers.length; n++) {\n        encoder.uint32(0x6a);\n        encoder.uint32(this.SuggestedReviewers[n].length);\n        encoder.string(this.SuggestedReviewers[n]);\n      }\n    }\n\n    return buf;\n  } // encode AccessRequestSpecV3\n} // AccessRequestSpecV3\n\n// AccessRequestFilter encodes filter params for access requests.\nexport class AccessRequestFilter {\n  // ID specifies a request ID if set.\n  public ID: string = \"\";\n  // User specifies a username if set.\n  public User: string = \"\";\n  // RequestState filters for requests in a specific state.\n  public State: u32;\n\n  // Decodes AccessRequestFilter from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessRequestFilter {\n    return AccessRequestFilter.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessRequestFilter from a DataView\n  static decodeDataView(view: DataView): AccessRequestFilter {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessRequestFilter();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.State = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessRequestFilter\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.ID.length) + this.ID.length\n        : 0;\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size += this.State == 0 ? 0 : 1 + __proto.Sizer.uint32(this.State);\n\n    return size;\n  }\n\n  // Encodes AccessRequestFilter to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessRequestFilter to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.ID.length);\n      encoder.string(this.ID);\n    }\n    if (this.User.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.State != 0) {\n      encoder.uint32(0x18);\n      encoder.uint32(this.State);\n    }\n\n    return buf;\n  } // encode AccessRequestFilter\n} // AccessRequestFilter\n\n/**\n * AccessCapabilities is a summary of capabilities that a user\n *  is granted via their dynamic access privileges which may not be\n *  calculable by directly examining the user's own static roles.\n */\nexport class AccessCapabilities {\n  // RequestableRoles is a list of existent roles which the user is allowed to request.\n  public RequestableRoles: Array<string> = new Array<string>();\n  // SuggestedReviewers is a list of all reviewers which are suggested by the user's roles.\n  public SuggestedReviewers: Array<string> = new Array<string>();\n\n  // Decodes AccessCapabilities from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessCapabilities {\n    return AccessCapabilities.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessCapabilities from a DataView\n  static decodeDataView(view: DataView): AccessCapabilities {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessCapabilities();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.RequestableRoles.push(decoder.string());\n          break;\n        }\n        case 2: {\n          obj.SuggestedReviewers.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessCapabilities\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += __size_string_repeated(this.RequestableRoles);\n\n    size += __size_string_repeated(this.SuggestedReviewers);\n\n    return size;\n  }\n\n  // Encodes AccessCapabilities to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessCapabilities to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.RequestableRoles.length > 0) {\n      for (let n: i32 = 0; n < this.RequestableRoles.length; n++) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.RequestableRoles[n].length);\n        encoder.string(this.RequestableRoles[n]);\n      }\n    }\n\n    if (this.SuggestedReviewers.length > 0) {\n      for (let n: i32 = 0; n < this.SuggestedReviewers.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.SuggestedReviewers[n].length);\n        encoder.string(this.SuggestedReviewers[n]);\n      }\n    }\n\n    return buf;\n  } // encode AccessCapabilities\n} // AccessCapabilities\n\n// AccessCapabilitiesRequest encodes parameters for the GetAccessCapabilities method.\nexport class AccessCapabilitiesRequest {\n  /**\n   * User is the name of the user whose capabilities we are interested in (defaults to\n   *  the caller's own username).\n   */\n  public User: string = \"\";\n  /**\n   * RequestableRoles is a flag indicating that we would like to view the list of roles\n   *  that the user is able to request.\n   */\n  public RequestableRoles: bool;\n  /**\n   * SuggestedReviewers is a flag indicating that we would like to view the list of all\n   *  reviewers which are suggested by the user's roles.\n   */\n  public SuggestedReviewers: bool;\n\n  // Decodes AccessCapabilitiesRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessCapabilitiesRequest {\n    return AccessCapabilitiesRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessCapabilitiesRequest from a DataView\n  static decodeDataView(view: DataView): AccessCapabilitiesRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessCapabilitiesRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.RequestableRoles = decoder.bool();\n          break;\n        }\n        case 3: {\n          obj.SuggestedReviewers = decoder.bool();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessCapabilitiesRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size += this.RequestableRoles == 0 ? 0 : 1 + 1;\n    size += this.SuggestedReviewers == 0 ? 0 : 1 + 1;\n\n    return size;\n  }\n\n  // Encodes AccessCapabilitiesRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessCapabilitiesRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.RequestableRoles != 0) {\n      encoder.uint32(0x10);\n      encoder.bool(this.RequestableRoles);\n    }\n    if (this.SuggestedReviewers != 0) {\n      encoder.uint32(0x18);\n      encoder.bool(this.SuggestedReviewers);\n    }\n\n    return buf;\n  } // encode AccessCapabilitiesRequest\n} // AccessCapabilitiesRequest\n\n// PluginData stores a collection of values associated with a specific resource.\nexport class PluginDataV3 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is PluginData metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a PluginData specification\n  public Spec: PluginDataSpecV3 = new PluginDataSpecV3();\n\n  // Decodes PluginDataV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): PluginDataV3 {\n    return PluginDataV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes PluginDataV3 from a DataView\n  static decodeDataView(view: DataView): PluginDataV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new PluginDataV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = PluginDataSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode PluginDataV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: PluginDataSpecV3 = this.Spec as PluginDataSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes PluginDataV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes PluginDataV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as PluginDataSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode PluginDataV3\n} // PluginDataV3\n\n/**\n * PluginDataEntry wraps a mapping of arbitrary string values used by\n *  plugins to store per-resource information.\n */\nexport class PluginDataEntry {\n  // Data is a mapping of arbitrary string values.\n  public Data: Map<string, string> = new Map<string, string>();\n\n  // Decodes PluginDataEntry from an ArrayBuffer\n  static decode(buf: ArrayBuffer): PluginDataEntry {\n    return PluginDataEntry.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes PluginDataEntry from a DataView\n  static decodeDataView(view: DataView): PluginDataEntry {\n    const decoder = new __proto.Decoder(view);\n    const obj = new PluginDataEntry();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.Data);\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode PluginDataEntry\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Data.size > 0) {\n      const keys = this.Data.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Data.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes PluginDataEntry to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes PluginDataEntry to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Data.size > 0) {\n      const keys = this.Data.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Data.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    return buf;\n  } // encode PluginDataEntry\n} // PluginDataEntry\n\n// PluginData stores a collection of values associated with a specific resource.\nexport class PluginDataSpecV3 {\n  // Entries is a collection of PluginData values organized by plugin name.\n  public Entries: Map<string, PluginDataEntry> = new Map<\n    string,\n    PluginDataEntry\n  >();\n\n  // Decodes PluginDataSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): PluginDataSpecV3 {\n    return PluginDataSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes PluginDataSpecV3 from a DataView\n  static decodeDataView(view: DataView): PluginDataSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new PluginDataSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          __decodeMap_string_PluginDataEntry(decoder, length, obj.Entries);\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode PluginDataSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Entries.size > 0) {\n      const keys = this.Entries.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Entries.get(key);\n        const itemSize = __sizeMapEntry_string_PluginDataEntry(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes PluginDataSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes PluginDataSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Entries.size > 0) {\n      const keys = this.Entries.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Entries.get(key);\n        const size = __sizeMapEntry_string_PluginDataEntry(key, value);\n        if (size > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n\n          const messageSize = value.size();\n\n          if (messageSize > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(messageSize);\n            value.encodeU8Array(encoder);\n          }\n        }\n      }\n    }\n\n    return buf;\n  } // encode PluginDataSpecV3\n} // PluginDataSpecV3\n\n/**\n * NOTE: PluginDataFilter and PluginDataUpdateParams currently only target AccessRequest resources\n *  since those are the only resources currently managed via plugin.  Support for additional resource\n *  kinds may be added in a backwards-compatible manner by adding a `Kind` field which defaults\n *  to `access_request` if unspecified.\n *  PluginDataFilter encodes filter params for plugin data.\n */\nexport class PluginDataFilter {\n  /**\n   * Kind is the kind of resource that the target plugin data\n   *  is associated with.\n   */\n  public Kind: string = \"\";\n  // Resource matches a specific resource name if set.\n  public Resource: string = \"\";\n  // Plugin matches a specific plugin name if set.\n  public Plugin: string = \"\";\n\n  // Decodes PluginDataFilter from an ArrayBuffer\n  static decode(buf: ArrayBuffer): PluginDataFilter {\n    return PluginDataFilter.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes PluginDataFilter from a DataView\n  static decodeDataView(view: DataView): PluginDataFilter {\n    const decoder = new __proto.Decoder(view);\n    const obj = new PluginDataFilter();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Resource = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Plugin = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode PluginDataFilter\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.Resource.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Resource.length) +\n          this.Resource.length\n        : 0;\n    size +=\n      this.Plugin.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Plugin.length) + this.Plugin.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes PluginDataFilter to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes PluginDataFilter to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.Resource.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Resource.length);\n      encoder.string(this.Resource);\n    }\n    if (this.Plugin.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Plugin.length);\n      encoder.string(this.Plugin);\n    }\n\n    return buf;\n  } // encode PluginDataFilter\n} // PluginDataFilter\n\n// PluginDataUpdateParams encodes paramers for updating a PluginData field.\nexport class PluginDataUpdateParams {\n  /**\n   * Kind is the kind of resource that the target plugin data\n   *  is associated with.\n   */\n  public Kind: string = \"\";\n  // Resource indicates the name of the target resource.\n  public Resource: string = \"\";\n  // Plugin is the name of the plugin that owns the data.\n  public Plugin: string = \"\";\n  // Set indicates the fields which should be set by this operation.\n  public Set: Map<string, string> = new Map<string, string>();\n  // Expect optionally indicates the expected state of fields prior to this update.\n  public Expect: Map<string, string> = new Map<string, string>();\n\n  // Decodes PluginDataUpdateParams from an ArrayBuffer\n  static decode(buf: ArrayBuffer): PluginDataUpdateParams {\n    return PluginDataUpdateParams.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes PluginDataUpdateParams from a DataView\n  static decodeDataView(view: DataView): PluginDataUpdateParams {\n    const decoder = new __proto.Decoder(view);\n    const obj = new PluginDataUpdateParams();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Resource = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Plugin = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.Set);\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.Expect);\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode PluginDataUpdateParams\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.Resource.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Resource.length) +\n          this.Resource.length\n        : 0;\n    size +=\n      this.Plugin.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Plugin.length) + this.Plugin.length\n        : 0;\n\n    if (this.Set.size > 0) {\n      const keys = this.Set.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Set.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    if (this.Expect.size > 0) {\n      const keys = this.Expect.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Expect.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes PluginDataUpdateParams to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes PluginDataUpdateParams to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.Resource.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Resource.length);\n      encoder.string(this.Resource);\n    }\n    if (this.Plugin.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Plugin.length);\n      encoder.string(this.Plugin);\n    }\n\n    if (this.Set.size > 0) {\n      const keys = this.Set.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Set.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0x22);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    if (this.Expect.size > 0) {\n      const keys = this.Expect.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Expect.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0x2a);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    return buf;\n  } // encode PluginDataUpdateParams\n} // PluginDataUpdateParams\n\n// RoleV5 represents role resource specification\nexport class RoleV5 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a role specification\n  public Spec: RoleSpecV5 = new RoleSpecV5();\n\n  // Decodes RoleV5 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RoleV5 {\n    return RoleV5.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RoleV5 from a DataView\n  static decodeDataView(view: DataView): RoleV5 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RoleV5();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = RoleSpecV5.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RoleV5\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: RoleSpecV5 = this.Spec as RoleSpecV5;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RoleV5 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RoleV5 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as RoleSpecV5;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RoleV5\n} // RoleV5\n\n// RoleSpecV5 is role specification for RoleV5.\nexport class RoleSpecV5 {\n  // Options is for OpenSSH options like agent forwarding.\n  public Options: RoleOptions = new RoleOptions();\n  // Allow is the set of conditions evaluated to grant access.\n  public Allow: RoleConditions = new RoleConditions();\n  /**\n   * Deny is the set of conditions evaluated to deny access. Deny takes priority\n   *  over allow.\n   */\n  public Deny: RoleConditions = new RoleConditions();\n\n  // Decodes RoleSpecV5 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RoleSpecV5 {\n    return RoleSpecV5.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RoleSpecV5 from a DataView\n  static decodeDataView(view: DataView): RoleSpecV5 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RoleSpecV5();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Options = RoleOptions.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Allow = RoleConditions.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Deny = RoleConditions.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RoleSpecV5\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Options != null) {\n      const f: RoleOptions = this.Options as RoleOptions;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Allow != null) {\n      const f: RoleConditions = this.Allow as RoleConditions;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Deny != null) {\n      const f: RoleConditions = this.Deny as RoleConditions;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RoleSpecV5 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RoleSpecV5 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Options != null) {\n      const f = this.Options as RoleOptions;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Allow != null) {\n      const f = this.Allow as RoleConditions;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Deny != null) {\n      const f = this.Deny as RoleConditions;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RoleSpecV5\n} // RoleSpecV5\n\n// RoleOptions is a set of role options\nexport class RoleOptions {\n  // ForwardAgent is SSH agent forwarding.\n  public ForwardAgent: bool;\n  // MaxSessionTTL defines how long a SSH session can last for.\n  public MaxSessionTTL: i64;\n  /**\n   * PortForwarding defines if the certificate will have\n   *  \"permit-port-forwarding\"\n   *  in the certificate. PortForwarding is \"yes\" if not set,\n   *  that's why this is a pointer\n   */\n  public PortForwarding: BoolValue = new BoolValue();\n  /**\n   * CertificateFormat defines the format of the user certificate to allow\n   *  compatibility with older versions of OpenSSH.\n   */\n  public CertificateFormat: string = \"\";\n  /**\n   * ClientIdleTimeout sets disconnect clients on idle timeout behavior,\n   *  if set to 0 means do not disconnect, otherwise is set to the idle\n   *  duration.\n   */\n  public ClientIdleTimeout: i64;\n  // DisconnectExpiredCert sets disconnect clients on expired certificates.\n  public DisconnectExpiredCert: bool;\n  // BPF defines what events to record for the BPF-based session recorder.\n  public BPF: Array<string> = new Array<string>();\n  // PermitX11Forwarding authorizes use of X11 forwarding.\n  public PermitX11Forwarding: bool;\n  /**\n   * MaxConnections defines the maximum number of\n   *  concurrent connections a user may hold.\n   */\n  public MaxConnections: i64;\n  /**\n   * MaxSessions defines the maximum number of\n   *  concurrent sessions per connection.\n   */\n  public MaxSessions: i64;\n  /**\n   * RequestAccess defines the access request stategy (optional|note|always)\n   *  where optional is the default.\n   */\n  public RequestAccess: string = \"\";\n  // RequestPrompt is an optional message which tells users what they aught to\n  public RequestPrompt: string = \"\";\n  /**\n   * RequireSessionMFA specifies whether a user is required to do an MFA\n   *  check for every session.\n   */\n  public RequireSessionMFA: bool;\n  /**\n   * Lock specifies the locking mode (strict|best_effort) to be applied with\n   *  the role.\n   */\n  public Lock: string = \"\";\n  /**\n   * RecordDesktopSession indicates whether desktop access sessions should be recorded.\n   *  It defaults to true unless explicitly set to false.\n   */\n  public RecordSession: RecordSession = new RecordSession();\n  /**\n   * DesktopClipboard indicates whether clipboard sharing is allowed between the user's\n   *  workstation and the remote desktop. It defaults to true unless explicitly set to\n   *  false.\n   */\n  public DesktopClipboard: BoolValue = new BoolValue();\n  // CertExtensions specifies the key/values\n  public CertExtensions: Array<CertExtension> = new Array<CertExtension>();\n\n  // Decodes RoleOptions from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RoleOptions {\n    return RoleOptions.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RoleOptions from a DataView\n  static decodeDataView(view: DataView): RoleOptions {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RoleOptions();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ForwardAgent = decoder.bool();\n          break;\n        }\n        case 2: {\n          obj.MaxSessionTTL = decoder.int64();\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.PortForwarding = BoolValue.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.CertificateFormat = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.ClientIdleTimeout = decoder.int64();\n          break;\n        }\n        case 6: {\n          obj.DisconnectExpiredCert = decoder.bool();\n          break;\n        }\n        case 7: {\n          obj.BPF.push(decoder.string());\n          break;\n        }\n        case 8: {\n          obj.PermitX11Forwarding = decoder.bool();\n          break;\n        }\n        case 9: {\n          obj.MaxConnections = decoder.int64();\n          break;\n        }\n        case 10: {\n          obj.MaxSessions = decoder.int64();\n          break;\n        }\n        case 11: {\n          obj.RequestAccess = decoder.string();\n          break;\n        }\n        case 12: {\n          obj.RequestPrompt = decoder.string();\n          break;\n        }\n        case 13: {\n          obj.RequireSessionMFA = decoder.bool();\n          break;\n        }\n        case 14: {\n          obj.Lock = decoder.string();\n          break;\n        }\n        case 15: {\n          const length = decoder.uint32();\n          obj.RecordSession = RecordSession.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 16: {\n          const length = decoder.uint32();\n          obj.DesktopClipboard = BoolValue.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 17: {\n          const length = decoder.uint32();\n          obj.CertExtensions.push(\n            CertExtension.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RoleOptions\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.ForwardAgent == 0 ? 0 : 1 + 1;\n    size +=\n      this.MaxSessionTTL == 0 ? 0 : 1 + __proto.Sizer.int64(this.MaxSessionTTL);\n\n    if (this.PortForwarding != null) {\n      const f: BoolValue = this.PortForwarding as BoolValue;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.CertificateFormat.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.CertificateFormat.length) +\n          this.CertificateFormat.length\n        : 0;\n    size +=\n      this.ClientIdleTimeout == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.ClientIdleTimeout);\n    size += this.DisconnectExpiredCert == 0 ? 0 : 1 + 1;\n\n    size += __size_string_repeated(this.BPF);\n\n    size += this.PermitX11Forwarding == 0 ? 0 : 1 + 1;\n    size +=\n      this.MaxConnections == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.MaxConnections);\n    size +=\n      this.MaxSessions == 0 ? 0 : 1 + __proto.Sizer.int64(this.MaxSessions);\n    size +=\n      this.RequestAccess.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RequestAccess.length) +\n          this.RequestAccess.length\n        : 0;\n    size +=\n      this.RequestPrompt.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RequestPrompt.length) +\n          this.RequestPrompt.length\n        : 0;\n    size += this.RequireSessionMFA == 0 ? 0 : 1 + 1;\n    size +=\n      this.Lock.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Lock.length) + this.Lock.length\n        : 0;\n\n    if (this.RecordSession != null) {\n      const f: RecordSession = this.RecordSession as RecordSession;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.DesktopClipboard != null) {\n      const f: BoolValue = this.DesktopClipboard as BoolValue;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.CertExtensions.length; n++) {\n      const messageSize = this.CertExtensions[n].size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RoleOptions to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RoleOptions to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ForwardAgent != 0) {\n      encoder.uint32(0x8);\n      encoder.bool(this.ForwardAgent);\n    }\n    if (this.MaxSessionTTL != 0) {\n      encoder.uint32(0x10);\n      encoder.int64(this.MaxSessionTTL);\n    }\n\n    if (this.PortForwarding != null) {\n      const f = this.PortForwarding as BoolValue;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.CertificateFormat.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.CertificateFormat.length);\n      encoder.string(this.CertificateFormat);\n    }\n    if (this.ClientIdleTimeout != 0) {\n      encoder.uint32(0x28);\n      encoder.int64(this.ClientIdleTimeout);\n    }\n    if (this.DisconnectExpiredCert != 0) {\n      encoder.uint32(0x30);\n      encoder.bool(this.DisconnectExpiredCert);\n    }\n\n    if (this.BPF.length > 0) {\n      for (let n: i32 = 0; n < this.BPF.length; n++) {\n        encoder.uint32(0x3a);\n        encoder.uint32(this.BPF[n].length);\n        encoder.string(this.BPF[n]);\n      }\n    }\n\n    if (this.PermitX11Forwarding != 0) {\n      encoder.uint32(0x40);\n      encoder.bool(this.PermitX11Forwarding);\n    }\n    if (this.MaxConnections != 0) {\n      encoder.uint32(0x48);\n      encoder.int64(this.MaxConnections);\n    }\n    if (this.MaxSessions != 0) {\n      encoder.uint32(0x50);\n      encoder.int64(this.MaxSessions);\n    }\n    if (this.RequestAccess.length > 0) {\n      encoder.uint32(0x5a);\n      encoder.uint32(this.RequestAccess.length);\n      encoder.string(this.RequestAccess);\n    }\n    if (this.RequestPrompt.length > 0) {\n      encoder.uint32(0x62);\n      encoder.uint32(this.RequestPrompt.length);\n      encoder.string(this.RequestPrompt);\n    }\n    if (this.RequireSessionMFA != 0) {\n      encoder.uint32(0x68);\n      encoder.bool(this.RequireSessionMFA);\n    }\n    if (this.Lock.length > 0) {\n      encoder.uint32(0x72);\n      encoder.uint32(this.Lock.length);\n      encoder.string(this.Lock);\n    }\n\n    if (this.RecordSession != null) {\n      const f = this.RecordSession as RecordSession;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x7a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DesktopClipboard != null) {\n      const f = this.DesktopClipboard as BoolValue;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x82);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.CertExtensions.length; n++) {\n      const messageSize = this.CertExtensions[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x8a);\n        encoder.uint32(messageSize);\n        this.CertExtensions[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RoleOptions\n} // RoleOptions\n\nexport class RecordSession {\n  /**\n   * Desktop indicates whether desktop sessions should be recorded.\n   *  It defaults to true unless explicitly set to false.\n   */\n  public Desktop: BoolValue = new BoolValue();\n\n  // Decodes RecordSession from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RecordSession {\n    return RecordSession.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RecordSession from a DataView\n  static decodeDataView(view: DataView): RecordSession {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RecordSession();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Desktop = BoolValue.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RecordSession\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Desktop != null) {\n      const f: BoolValue = this.Desktop as BoolValue;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RecordSession to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RecordSession to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Desktop != null) {\n      const f = this.Desktop as BoolValue;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RecordSession\n} // RecordSession\n\n// CertExtension represents a key/value for a certificate extension\nexport class CertExtension {\n  /**\n   * Type represents the certificate type being extended, only ssh\n   *  is supported at this time.\n   */\n  public Type: u32;\n  /**\n   * Mode is the type of extension to be used -- currently\n   *  critical-option is not supported\n   */\n  public Mode: u32;\n  // Name specifies the key to be used in the cert extension.\n  public Name: string = \"\";\n  // Value specifies the valueg to be used in the cert extension.\n  public Value: string = \"\";\n\n  // Decodes CertExtension from an ArrayBuffer\n  static decode(buf: ArrayBuffer): CertExtension {\n    return CertExtension.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes CertExtension from a DataView\n  static decodeDataView(view: DataView): CertExtension {\n    const decoder = new __proto.Decoder(view);\n    const obj = new CertExtension();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Type = decoder.uint32();\n          break;\n        }\n        case 2: {\n          obj.Mode = decoder.uint32();\n          break;\n        }\n        case 3: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.Value = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode CertExtension\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.Type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Type);\n    size += this.Mode == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Mode);\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.Value.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Value.length) + this.Value.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes CertExtension to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes CertExtension to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Type != 0) {\n      encoder.uint32(0x8);\n      encoder.uint32(this.Type);\n    }\n    if (this.Mode != 0) {\n      encoder.uint32(0x10);\n      encoder.uint32(this.Mode);\n    }\n    if (this.Name.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.Value.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.Value.length);\n      encoder.string(this.Value);\n    }\n\n    return buf;\n  } // encode CertExtension\n} // CertExtension\n\n/**\n * RoleConditions is a set of conditions that must all match to be allowed or\n *  denied access.\n */\nexport class RoleConditions {\n  // Logins is a list of *nix system logins.\n  public Logins: Array<string> = new Array<string>();\n  /**\n   * Namespaces is a list of namespaces (used to partition a cluster). The\n   *  field should be called \"namespaces\" when it returns in Teleport 2.4.\n   */\n  public Namespaces: Array<string> = new Array<string>();\n  /**\n   * NodeLabels is a map of node labels (used to dynamically grant access to\n   *  nodes).\n   */\n  public NodeLabels: wrappers.LabelValues = new wrappers.LabelValues();\n  /**\n   * Rules is a list of rules and their access levels. Rules are a high level\n   *  construct used for access control.\n   */\n  public Rules: Array<Rule> = new Array<Rule>();\n  // KubeGroups is a list of kubernetes groups\n  public KubeGroups: Array<string> = new Array<string>();\n  public Request: AccessRequestConditions = new AccessRequestConditions();\n  // KubeUsers is an optional kubernetes users to impersonate\n  public KubeUsers: Array<string> = new Array<string>();\n  // AppLabels is a map of labels used as part of the RBAC system.\n  public AppLabels: wrappers.LabelValues = new wrappers.LabelValues();\n  /**\n   * ClusterLabels is a map of node labels (used to dynamically grant access to\n   *  clusters).\n   */\n  public ClusterLabels: wrappers.LabelValues = new wrappers.LabelValues();\n  // KubernetesLabels is a map of kubernetes cluster labels used for RBAC.\n  public KubernetesLabels: wrappers.LabelValues = new wrappers.LabelValues();\n  // DatabaseLabels are used in RBAC system to allow/deny access to databases.\n  public DatabaseLabels: wrappers.LabelValues = new wrappers.LabelValues();\n  // DatabaseNames is a list of database names this role is allowed to connect to.\n  public DatabaseNames: Array<string> = new Array<string>();\n  // DatabaseUsers is a list of databaes users this role is allowed to connect as.\n  public DatabaseUsers: Array<string> = new Array<string>();\n  /**\n   * Impersonate specifies what users and roles this role is allowed to impersonate\n   *  by issuing certificates or other possible means.\n   */\n  public Impersonate: ImpersonateConditions = new ImpersonateConditions();\n  // ReviewRequests defines conditions for submitting access reviews.\n  public ReviewRequests: AccessReviewConditions = new AccessReviewConditions();\n  // AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.\n  public AWSRoleARNs: Array<string> = new Array<string>();\n  // WindowsDesktopLogins is a list of desktop login names allowed/denied for Windows desktops.\n  public WindowsDesktopLogins: Array<string> = new Array<string>();\n  // WindowsDesktopLabels are used in the RBAC system to allow/deny access to Windows desktops.\n  public WindowsDesktopLabels: wrappers.LabelValues =\n    new wrappers.LabelValues();\n  // RequireSessionJoin specifies policies for required users to start a session.\n  public RequireSessionJoin: Array<SessionRequirePolicy> =\n    new Array<SessionRequirePolicy>();\n  // JoinSessions specifies policies to allow users to join other sessions.\n  public JoinSessions: Array<SessionJoinPolicy> =\n    new Array<SessionJoinPolicy>();\n\n  // Decodes RoleConditions from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RoleConditions {\n    return RoleConditions.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RoleConditions from a DataView\n  static decodeDataView(view: DataView): RoleConditions {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RoleConditions();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Logins.push(decoder.string());\n          break;\n        }\n        case 2: {\n          obj.Namespaces.push(decoder.string());\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.NodeLabels = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Rules.push(\n            Rule.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.KubeGroups.push(decoder.string());\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.Request = AccessRequestConditions.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          obj.KubeUsers.push(decoder.string());\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.AppLabels = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 9: {\n          const length = decoder.uint32();\n          obj.ClusterLabels = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.KubernetesLabels = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 11: {\n          const length = decoder.uint32();\n          obj.DatabaseLabels = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 12: {\n          obj.DatabaseNames.push(decoder.string());\n          break;\n        }\n        case 13: {\n          obj.DatabaseUsers.push(decoder.string());\n          break;\n        }\n        case 14: {\n          const length = decoder.uint32();\n          obj.Impersonate = ImpersonateConditions.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 15: {\n          const length = decoder.uint32();\n          obj.ReviewRequests = AccessReviewConditions.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 16: {\n          obj.AWSRoleARNs.push(decoder.string());\n          break;\n        }\n        case 17: {\n          obj.WindowsDesktopLogins.push(decoder.string());\n          break;\n        }\n        case 18: {\n          const length = decoder.uint32();\n          obj.WindowsDesktopLabels = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 19: {\n          const length = decoder.uint32();\n          obj.RequireSessionJoin.push(\n            SessionRequirePolicy.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 20: {\n          const length = decoder.uint32();\n          obj.JoinSessions.push(\n            SessionJoinPolicy.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RoleConditions\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += __size_string_repeated(this.Logins);\n\n    size += __size_string_repeated(this.Namespaces);\n\n    if (this.NodeLabels != null) {\n      const f: wrappers.LabelValues = this.NodeLabels as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Rules.length; n++) {\n      const messageSize = this.Rules[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.KubeGroups);\n\n    if (this.Request != null) {\n      const f: AccessRequestConditions = this\n        .Request as AccessRequestConditions;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.KubeUsers);\n\n    if (this.AppLabels != null) {\n      const f: wrappers.LabelValues = this.AppLabels as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.ClusterLabels != null) {\n      const f: wrappers.LabelValues = this\n        .ClusterLabels as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.KubernetesLabels != null) {\n      const f: wrappers.LabelValues = this\n        .KubernetesLabels as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.DatabaseLabels != null) {\n      const f: wrappers.LabelValues = this\n        .DatabaseLabels as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.DatabaseNames);\n\n    size += __size_string_repeated(this.DatabaseUsers);\n\n    if (this.Impersonate != null) {\n      const f: ImpersonateConditions = this\n        .Impersonate as ImpersonateConditions;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.ReviewRequests != null) {\n      const f: AccessReviewConditions = this\n        .ReviewRequests as AccessReviewConditions;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.AWSRoleARNs);\n\n    size += __size_string_repeated(this.WindowsDesktopLogins);\n\n    if (this.WindowsDesktopLabels != null) {\n      const f: wrappers.LabelValues = this\n        .WindowsDesktopLabels as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.RequireSessionJoin.length; n++) {\n      const messageSize = this.RequireSessionJoin[n].size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.JoinSessions.length; n++) {\n      const messageSize = this.JoinSessions[n].size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RoleConditions to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RoleConditions to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Logins.length > 0) {\n      for (let n: i32 = 0; n < this.Logins.length; n++) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.Logins[n].length);\n        encoder.string(this.Logins[n]);\n      }\n    }\n\n    if (this.Namespaces.length > 0) {\n      for (let n: i32 = 0; n < this.Namespaces.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.Namespaces[n].length);\n        encoder.string(this.Namespaces[n]);\n      }\n    }\n\n    if (this.NodeLabels != null) {\n      const f = this.NodeLabels as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Rules.length; n++) {\n      const messageSize = this.Rules[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        this.Rules[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubeGroups.length > 0) {\n      for (let n: i32 = 0; n < this.KubeGroups.length; n++) {\n        encoder.uint32(0x2a);\n        encoder.uint32(this.KubeGroups[n].length);\n        encoder.string(this.KubeGroups[n]);\n      }\n    }\n\n    if (this.Request != null) {\n      const f = this.Request as AccessRequestConditions;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubeUsers.length > 0) {\n      for (let n: i32 = 0; n < this.KubeUsers.length; n++) {\n        encoder.uint32(0x3a);\n        encoder.uint32(this.KubeUsers[n].length);\n        encoder.string(this.KubeUsers[n]);\n      }\n    }\n\n    if (this.AppLabels != null) {\n      const f = this.AppLabels as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.ClusterLabels != null) {\n      const f = this.ClusterLabels as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x4a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubernetesLabels != null) {\n      const f = this.KubernetesLabels as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DatabaseLabels != null) {\n      const f = this.DatabaseLabels as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x5a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DatabaseNames.length > 0) {\n      for (let n: i32 = 0; n < this.DatabaseNames.length; n++) {\n        encoder.uint32(0x62);\n        encoder.uint32(this.DatabaseNames[n].length);\n        encoder.string(this.DatabaseNames[n]);\n      }\n    }\n\n    if (this.DatabaseUsers.length > 0) {\n      for (let n: i32 = 0; n < this.DatabaseUsers.length; n++) {\n        encoder.uint32(0x6a);\n        encoder.uint32(this.DatabaseUsers[n].length);\n        encoder.string(this.DatabaseUsers[n]);\n      }\n    }\n\n    if (this.Impersonate != null) {\n      const f = this.Impersonate as ImpersonateConditions;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x72);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.ReviewRequests != null) {\n      const f = this.ReviewRequests as AccessReviewConditions;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x7a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AWSRoleARNs.length > 0) {\n      for (let n: i32 = 0; n < this.AWSRoleARNs.length; n++) {\n        encoder.uint32(0x82);\n        encoder.uint32(this.AWSRoleARNs[n].length);\n        encoder.string(this.AWSRoleARNs[n]);\n      }\n    }\n\n    if (this.WindowsDesktopLogins.length > 0) {\n      for (let n: i32 = 0; n < this.WindowsDesktopLogins.length; n++) {\n        encoder.uint32(0x8a);\n        encoder.uint32(this.WindowsDesktopLogins[n].length);\n        encoder.string(this.WindowsDesktopLogins[n]);\n      }\n    }\n\n    if (this.WindowsDesktopLabels != null) {\n      const f = this.WindowsDesktopLabels as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x92);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.RequireSessionJoin.length; n++) {\n      const messageSize = this.RequireSessionJoin[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x9a);\n        encoder.uint32(messageSize);\n        this.RequireSessionJoin[n].encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.JoinSessions.length; n++) {\n      const messageSize = this.JoinSessions[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa2);\n        encoder.uint32(messageSize);\n        this.JoinSessions[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RoleConditions\n} // RoleConditions\n\n// SessionRequirePolicy a requirement policy that needs to be fulfilled to grant access.\nexport class SessionRequirePolicy {\n  // Name is the name of the policy.\n  public Name: string = \"\";\n  // Filter is a predicate that determines what users count towards this policy.\n  public Filter: string = \"\";\n  // Kinds are the session kinds this policy applies to.\n  public Kinds: Array<string> = new Array<string>();\n  // Count is the amount of people that need to be matched for this policy to be fulfilled.\n  public Count: i32;\n  // Modes is the list of modes that may be used to fulfill this policy.\n  public Modes: Array<string> = new Array<string>();\n  /**\n   * OnLeave is the behaviour that's used when the policy is no longer fulfilled\n   *  for a live session.\n   */\n  public OnLeave: string = \"\";\n\n  // Decodes SessionRequirePolicy from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionRequirePolicy {\n    return SessionRequirePolicy.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionRequirePolicy from a DataView\n  static decodeDataView(view: DataView): SessionRequirePolicy {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionRequirePolicy();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Filter = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Kinds.push(decoder.string());\n          break;\n        }\n        case 4: {\n          obj.Count = decoder.int32();\n          break;\n        }\n        case 5: {\n          obj.Modes.push(decoder.string());\n          break;\n        }\n        case 6: {\n          obj.OnLeave = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionRequirePolicy\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.Filter.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Filter.length) + this.Filter.length\n        : 0;\n\n    size += __size_string_repeated(this.Kinds);\n\n    size += this.Count == 0 ? 0 : 1 + __proto.Sizer.int32(this.Count);\n\n    size += __size_string_repeated(this.Modes);\n\n    size +=\n      this.OnLeave.length > 0\n        ? 1 + __proto.Sizer.varint64(this.OnLeave.length) + this.OnLeave.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes SessionRequirePolicy to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionRequirePolicy to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.Filter.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Filter.length);\n      encoder.string(this.Filter);\n    }\n\n    if (this.Kinds.length > 0) {\n      for (let n: i32 = 0; n < this.Kinds.length; n++) {\n        encoder.uint32(0x1a);\n        encoder.uint32(this.Kinds[n].length);\n        encoder.string(this.Kinds[n]);\n      }\n    }\n\n    if (this.Count != 0) {\n      encoder.uint32(0x20);\n      encoder.int32(this.Count);\n    }\n\n    if (this.Modes.length > 0) {\n      for (let n: i32 = 0; n < this.Modes.length; n++) {\n        encoder.uint32(0x2a);\n        encoder.uint32(this.Modes[n].length);\n        encoder.string(this.Modes[n]);\n      }\n    }\n\n    if (this.OnLeave.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.OnLeave.length);\n      encoder.string(this.OnLeave);\n    }\n\n    return buf;\n  } // encode SessionRequirePolicy\n} // SessionRequirePolicy\n\n// SessionJoinPolicy defines a policy that allows a user to join sessions.\nexport class SessionJoinPolicy {\n  // Name is the name of the policy.\n  public Name: string = \"\";\n  // Roles is a list of roles that you can join the session of.\n  public Roles: Array<string> = new Array<string>();\n  // Kinds are the session kinds this policy applies to.\n  public Kinds: Array<string> = new Array<string>();\n  // Modes is a list of permitted participant modes for this policy.\n  public Modes: Array<string> = new Array<string>();\n\n  // Decodes SessionJoinPolicy from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionJoinPolicy {\n    return SessionJoinPolicy.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionJoinPolicy from a DataView\n  static decodeDataView(view: DataView): SessionJoinPolicy {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionJoinPolicy();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.Kinds.push(decoder.string());\n          break;\n        }\n        case 4: {\n          obj.Modes.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionJoinPolicy\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n\n    size += __size_string_repeated(this.Roles);\n\n    size += __size_string_repeated(this.Kinds);\n\n    size += __size_string_repeated(this.Modes);\n\n    return size;\n  }\n\n  // Encodes SessionJoinPolicy to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionJoinPolicy to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    if (this.Kinds.length > 0) {\n      for (let n: i32 = 0; n < this.Kinds.length; n++) {\n        encoder.uint32(0x1a);\n        encoder.uint32(this.Kinds[n].length);\n        encoder.string(this.Kinds[n]);\n      }\n    }\n\n    if (this.Modes.length > 0) {\n      for (let n: i32 = 0; n < this.Modes.length; n++) {\n        encoder.uint32(0x22);\n        encoder.uint32(this.Modes[n].length);\n        encoder.string(this.Modes[n]);\n      }\n    }\n\n    return buf;\n  } // encode SessionJoinPolicy\n} // SessionJoinPolicy\n\n/**\n * AccessRequestConditions is a matcher for allow/deny restrictions on\n *  access-requests.\n */\nexport class AccessRequestConditions {\n  // Roles is the name of roles which will match the request rule.\n  public Roles: Array<string> = new Array<string>();\n  // ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.\n  public ClaimsToRoles: Array<ClaimMapping> = new Array<ClaimMapping>();\n  /**\n   * Annotations is a collection of annotations to be programmatically\n   *  appended to pending access requests at the time of their creation.\n   *  These annotations serve as a mechanism to propagate extra information\n   *  to plugins.  Since these annotations support variable interpolation\n   *  syntax, they also offer a mechanism for forwarding claims from an\n   *  external identity provider, to a plugin via `{{external.trait_name}}`\n   *  style substitutions.\n   */\n  public Annotations: wrappers.LabelValues = new wrappers.LabelValues();\n  /**\n   * Thresholds is a list of thresholds, one of which must be met in order for reviews\n   *  to trigger a state-transition.  If no thresholds are provided, a default threshold\n   *  of 1 for approval and denial is used.\n   */\n  public Thresholds: Array<AccessReviewThreshold> =\n    new Array<AccessReviewThreshold>();\n  /**\n   * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but\n   *  that is not a requirement.\n   */\n  public SuggestedReviewers: Array<string> = new Array<string>();\n\n  // Decodes AccessRequestConditions from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessRequestConditions {\n    return AccessRequestConditions.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessRequestConditions from a DataView\n  static decodeDataView(view: DataView): AccessRequestConditions {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessRequestConditions();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.ClaimsToRoles.push(\n            ClaimMapping.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Annotations = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Thresholds.push(\n            AccessReviewThreshold.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.SuggestedReviewers.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessRequestConditions\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += __size_string_repeated(this.Roles);\n\n    for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {\n      const messageSize = this.ClaimsToRoles[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Annotations != null) {\n      const f: wrappers.LabelValues = this.Annotations as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Thresholds.length; n++) {\n      const messageSize = this.Thresholds[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.SuggestedReviewers);\n\n    return size;\n  }\n\n  // Encodes AccessRequestConditions to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessRequestConditions to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {\n      const messageSize = this.ClaimsToRoles[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        this.ClaimsToRoles[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Annotations != null) {\n      const f = this.Annotations as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Thresholds.length; n++) {\n      const messageSize = this.Thresholds[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        this.Thresholds[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SuggestedReviewers.length > 0) {\n      for (let n: i32 = 0; n < this.SuggestedReviewers.length; n++) {\n        encoder.uint32(0x2a);\n        encoder.uint32(this.SuggestedReviewers[n].length);\n        encoder.string(this.SuggestedReviewers[n]);\n      }\n    }\n\n    return buf;\n  } // encode AccessRequestConditions\n} // AccessRequestConditions\n\n/**\n * AccessReviewConditions is a matcher for allow/deny restrictions on\n *  access reviews.\n */\nexport class AccessReviewConditions {\n  // Roles is the name of roles which may be reviewed.\n  public Roles: Array<string> = new Array<string>();\n  // ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.\n  public ClaimsToRoles: Array<ClaimMapping> = new Array<ClaimMapping>();\n  /**\n   * Where is an optional predicate which further limits which requests are\n   *  reviewable.\n   */\n  public Where: string = \"\";\n\n  // Decodes AccessReviewConditions from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessReviewConditions {\n    return AccessReviewConditions.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessReviewConditions from a DataView\n  static decodeDataView(view: DataView): AccessReviewConditions {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessReviewConditions();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.ClaimsToRoles.push(\n            ClaimMapping.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          obj.Where = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessReviewConditions\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += __size_string_repeated(this.Roles);\n\n    for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {\n      const messageSize = this.ClaimsToRoles[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Where.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Where.length) + this.Where.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes AccessReviewConditions to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessReviewConditions to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {\n      const messageSize = this.ClaimsToRoles[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        this.ClaimsToRoles[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Where.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Where.length);\n      encoder.string(this.Where);\n    }\n\n    return buf;\n  } // encode AccessReviewConditions\n} // AccessReviewConditions\n\n// ClaimMapping maps a claim to teleport roles.\nexport class ClaimMapping {\n  // Claim is a claim name.\n  public Claim: string = \"\";\n  // Value is a claim value to match.\n  public Value: string = \"\";\n  // Roles is a list of static teleport roles to match.\n  public Roles: Array<string> = new Array<string>();\n\n  // Decodes ClaimMapping from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ClaimMapping {\n    return ClaimMapping.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ClaimMapping from a DataView\n  static decodeDataView(view: DataView): ClaimMapping {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ClaimMapping();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Claim = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Value = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ClaimMapping\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Claim.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Claim.length) + this.Claim.length\n        : 0;\n    size +=\n      this.Value.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Value.length) + this.Value.length\n        : 0;\n\n    size += __size_string_repeated(this.Roles);\n\n    return size;\n  }\n\n  // Encodes ClaimMapping to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ClaimMapping to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Claim.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Claim.length);\n      encoder.string(this.Claim);\n    }\n    if (this.Value.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Value.length);\n      encoder.string(this.Value);\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x1a);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    return buf;\n  } // encode ClaimMapping\n} // ClaimMapping\n\n/**\n * Rule represents allow or deny rule that is executed to check\n *  if user or service have access to resource\n */\nexport class Rule {\n  // Resources is a list of resources\n  public Resources: Array<string> = new Array<string>();\n  // Verbs is a list of verbs\n  public Verbs: Array<string> = new Array<string>();\n  // Where specifies optional advanced matcher\n  public Where: string = \"\";\n  // Actions specifies optional actions taken when this rule matches\n  public Actions: Array<string> = new Array<string>();\n\n  // Decodes Rule from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Rule {\n    return Rule.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Rule from a DataView\n  static decodeDataView(view: DataView): Rule {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Rule();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Resources.push(decoder.string());\n          break;\n        }\n        case 2: {\n          obj.Verbs.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.Where = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.Actions.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Rule\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += __size_string_repeated(this.Resources);\n\n    size += __size_string_repeated(this.Verbs);\n\n    size +=\n      this.Where.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Where.length) + this.Where.length\n        : 0;\n\n    size += __size_string_repeated(this.Actions);\n\n    return size;\n  }\n\n  // Encodes Rule to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Rule to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Resources.length > 0) {\n      for (let n: i32 = 0; n < this.Resources.length; n++) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.Resources[n].length);\n        encoder.string(this.Resources[n]);\n      }\n    }\n\n    if (this.Verbs.length > 0) {\n      for (let n: i32 = 0; n < this.Verbs.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.Verbs[n].length);\n        encoder.string(this.Verbs[n]);\n      }\n    }\n\n    if (this.Where.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Where.length);\n      encoder.string(this.Where);\n    }\n\n    if (this.Actions.length > 0) {\n      for (let n: i32 = 0; n < this.Actions.length; n++) {\n        encoder.uint32(0x22);\n        encoder.uint32(this.Actions[n].length);\n        encoder.string(this.Actions[n]);\n      }\n    }\n\n    return buf;\n  } // encode Rule\n} // Rule\n\n/**\n * ImpersonateConditions specifies whether users are allowed\n *  to issue certificates for other users or groups.\n */\nexport class ImpersonateConditions {\n  /**\n   * Users is a list of resources this role is allowed to impersonate,\n   *  could be an empty list or a Wildcard pattern\n   */\n  public Users: Array<string> = new Array<string>();\n  // Roles is a list of resources this role is allowed to impersonate\n  public Roles: Array<string> = new Array<string>();\n  // Where specifies optional advanced matcher\n  public Where: string = \"\";\n\n  // Decodes ImpersonateConditions from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ImpersonateConditions {\n    return ImpersonateConditions.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ImpersonateConditions from a DataView\n  static decodeDataView(view: DataView): ImpersonateConditions {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ImpersonateConditions();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Users.push(decoder.string());\n          break;\n        }\n        case 2: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.Where = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ImpersonateConditions\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += __size_string_repeated(this.Users);\n\n    size += __size_string_repeated(this.Roles);\n\n    size +=\n      this.Where.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Where.length) + this.Where.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ImpersonateConditions to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ImpersonateConditions to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Users.length > 0) {\n      for (let n: i32 = 0; n < this.Users.length; n++) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.Users[n].length);\n        encoder.string(this.Users[n]);\n      }\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    if (this.Where.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Where.length);\n      encoder.string(this.Where);\n    }\n\n    return buf;\n  } // encode ImpersonateConditions\n} // ImpersonateConditions\n\n/**\n * BoolValue is a wrapper around bool, used in cases\n *  whenever bool value can have different default value when missing\n */\nexport class BoolValue {\n  public Value: bool;\n\n  // Decodes BoolValue from an ArrayBuffer\n  static decode(buf: ArrayBuffer): BoolValue {\n    return BoolValue.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes BoolValue from a DataView\n  static decodeDataView(view: DataView): BoolValue {\n    const decoder = new __proto.Decoder(view);\n    const obj = new BoolValue();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Value = decoder.bool();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode BoolValue\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.Value == 0 ? 0 : 1 + 1;\n\n    return size;\n  }\n\n  // Encodes BoolValue to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes BoolValue to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Value != 0) {\n      encoder.uint32(0x8);\n      encoder.bool(this.Value);\n    }\n\n    return buf;\n  } // encode BoolValue\n} // BoolValue\n\n// UserV2 is version 2 resource spec of the user\nexport class UserV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a user specification\n  public Spec: UserSpecV2 = new UserSpecV2();\n\n  // Decodes UserV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserV2 {\n    return UserV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserV2 from a DataView\n  static decodeDataView(view: DataView): UserV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = UserSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: UserSpecV2 = this.Spec as UserSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes UserV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as UserSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode UserV2\n} // UserV2\n\n// UserSpecV2 is a specification for V2 user\nexport class UserSpecV2 {\n  /**\n   * OIDCIdentities lists associated OpenID Connect identities\n   *  that let user log in using externally verified identity\n   */\n  public OIDCIdentities: Array<ExternalIdentity> =\n    new Array<ExternalIdentity>();\n  /**\n   * SAMLIdentities lists associated SAML identities\n   *  that let user log in using externally verified identity\n   */\n  public SAMLIdentities: Array<ExternalIdentity> =\n    new Array<ExternalIdentity>();\n  /**\n   * GithubIdentities list associated Github OAuth2 identities\n   *  that let user log in using externally verified identity\n   */\n  public GithubIdentities: Array<ExternalIdentity> =\n    new Array<ExternalIdentity>();\n  // Roles is a list of roles assigned to user\n  public Roles: Array<string> = new Array<string>();\n  /**\n   * Traits are key/value pairs received from an identity provider (through\n   *  OIDC claims or SAML assertions) or from a system administrator for local\n   *  accounts. Traits are used to populate role variables.\n   */\n  public Traits: wrappers.LabelValues = new wrappers.LabelValues();\n  // Status is a login status of the user\n  public Status: LoginStatus = new LoginStatus();\n  // Expires if set sets TTL on the user\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // CreatedBy holds information about agent or person created this user\n  public CreatedBy: CreatedBy = new CreatedBy();\n  /**\n   * LocalAuths hold sensitive data necessary for performing local\n   *  authentication\n   */\n  public LocalAuth: LocalAuthSecrets = new LocalAuthSecrets();\n\n  // Decodes UserSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserSpecV2 {\n    return UserSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserSpecV2 from a DataView\n  static decodeDataView(view: DataView): UserSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.OIDCIdentities.push(\n            ExternalIdentity.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.SAMLIdentities.push(\n            ExternalIdentity.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.GithubIdentities.push(\n            ExternalIdentity.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Traits = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.Status = LoginStatus.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.CreatedBy = CreatedBy.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 9: {\n          const length = decoder.uint32();\n          obj.LocalAuth = LocalAuthSecrets.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.OIDCIdentities.length; n++) {\n      const messageSize = this.OIDCIdentities[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.SAMLIdentities.length; n++) {\n      const messageSize = this.SAMLIdentities[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.GithubIdentities.length; n++) {\n      const messageSize = this.GithubIdentities[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.Roles);\n\n    if (this.Traits != null) {\n      const f: wrappers.LabelValues = this.Traits as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Status != null) {\n      const f: LoginStatus = this.Status as LoginStatus;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.CreatedBy != null) {\n      const f: CreatedBy = this.CreatedBy as CreatedBy;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.LocalAuth != null) {\n      const f: LocalAuthSecrets = this.LocalAuth as LocalAuthSecrets;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes UserSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.OIDCIdentities.length; n++) {\n      const messageSize = this.OIDCIdentities[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.OIDCIdentities[n].encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.SAMLIdentities.length; n++) {\n      const messageSize = this.SAMLIdentities[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        this.SAMLIdentities[n].encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.GithubIdentities.length; n++) {\n      const messageSize = this.GithubIdentities[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        this.GithubIdentities[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x22);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    if (this.Traits != null) {\n      const f = this.Traits as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Status != null) {\n      const f = this.Status as LoginStatus;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.CreatedBy != null) {\n      const f = this.CreatedBy as CreatedBy;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.LocalAuth != null) {\n      const f = this.LocalAuth as LocalAuthSecrets;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x4a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode UserSpecV2\n} // UserSpecV2\n\n/**\n * ExternalIdentity is OpenID Connect/SAML or Github identity that is linked\n *  to particular user and connector and lets user to log in using external\n *  credentials, e.g. google\n */\nexport class ExternalIdentity {\n  // ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'\n  public ConnectorID: string = \"\";\n  // Username is username supplied by external identity provider\n  public Username: string = \"\";\n\n  // Decodes ExternalIdentity from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ExternalIdentity {\n    return ExternalIdentity.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ExternalIdentity from a DataView\n  static decodeDataView(view: DataView): ExternalIdentity {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ExternalIdentity();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ConnectorID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Username = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ExternalIdentity\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ConnectorID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ConnectorID.length) +\n          this.ConnectorID.length\n        : 0;\n    size +=\n      this.Username.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Username.length) +\n          this.Username.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ExternalIdentity to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ExternalIdentity to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ConnectorID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.ConnectorID.length);\n      encoder.string(this.ConnectorID);\n    }\n    if (this.Username.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Username.length);\n      encoder.string(this.Username);\n    }\n\n    return buf;\n  } // encode ExternalIdentity\n} // ExternalIdentity\n\n// LoginStatus is a login status of the user\nexport class LoginStatus {\n  // IsLocked tells us if user is locked\n  public IsLocked: bool;\n  // LockedMessage contains the message in case if user is locked\n  public LockedMessage: string = \"\";\n  // LockedTime contains time when user was locked\n  public LockedTime: google.protobuf.Timestamp =\n    new google.protobuf.Timestamp();\n  // LockExpires contains time when this lock will expire\n  public LockExpires: google.protobuf.Timestamp =\n    new google.protobuf.Timestamp();\n  /**\n   * RecoveryAttemptLockExpires contains the time when this lock will expire\n   *  from reaching MaxAccountRecoveryAttempts. This field is used to determine\n   *  if a user got locked from recovery attempts.\n   */\n  public RecoveryAttemptLockExpires: google.protobuf.Timestamp =\n    new google.protobuf.Timestamp();\n\n  // Decodes LoginStatus from an ArrayBuffer\n  static decode(buf: ArrayBuffer): LoginStatus {\n    return LoginStatus.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes LoginStatus from a DataView\n  static decodeDataView(view: DataView): LoginStatus {\n    const decoder = new __proto.Decoder(view);\n    const obj = new LoginStatus();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.IsLocked = decoder.bool();\n          break;\n        }\n        case 2: {\n          obj.LockedMessage = decoder.string();\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.LockedTime = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.LockExpires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.RecoveryAttemptLockExpires =\n            google.protobuf.Timestamp.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode LoginStatus\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.IsLocked == 0 ? 0 : 1 + 1;\n    size +=\n      this.LockedMessage.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.LockedMessage.length) +\n          this.LockedMessage.length\n        : 0;\n\n    if (this.LockedTime != null) {\n      const f: google.protobuf.Timestamp = this\n        .LockedTime as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.LockExpires != null) {\n      const f: google.protobuf.Timestamp = this\n        .LockExpires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.RecoveryAttemptLockExpires != null) {\n      const f: google.protobuf.Timestamp = this\n        .RecoveryAttemptLockExpires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes LoginStatus to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes LoginStatus to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.IsLocked != 0) {\n      encoder.uint32(0x8);\n      encoder.bool(this.IsLocked);\n    }\n    if (this.LockedMessage.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.LockedMessage.length);\n      encoder.string(this.LockedMessage);\n    }\n\n    if (this.LockedTime != null) {\n      const f = this.LockedTime as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.LockExpires != null) {\n      const f = this.LockExpires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RecoveryAttemptLockExpires != null) {\n      const f = this.RecoveryAttemptLockExpires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode LoginStatus\n} // LoginStatus\n\n// CreatedBy holds information about the person or agent who created the user\nexport class CreatedBy {\n  // Identity if present means that user was automatically created by identity\n  public Connector: ConnectorRef = new ConnectorRef();\n  // Time specifies when user was created\n  public Time: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // User holds information about user\n  public User: UserRef = new UserRef();\n\n  // Decodes CreatedBy from an ArrayBuffer\n  static decode(buf: ArrayBuffer): CreatedBy {\n    return CreatedBy.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes CreatedBy from a DataView\n  static decodeDataView(view: DataView): CreatedBy {\n    const decoder = new __proto.Decoder(view);\n    const obj = new CreatedBy();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Connector = ConnectorRef.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Time = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserRef.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode CreatedBy\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Connector != null) {\n      const f: ConnectorRef = this.Connector as ConnectorRef;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Time != null) {\n      const f: google.protobuf.Timestamp = this\n        .Time as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserRef = this.User as UserRef;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes CreatedBy to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes CreatedBy to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Connector != null) {\n      const f = this.Connector as ConnectorRef;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Time != null) {\n      const f = this.Time as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserRef;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode CreatedBy\n} // CreatedBy\n\n// LocalAuthSecrets holds sensitive data used to authenticate a local user.\nexport class LocalAuthSecrets {\n  // PasswordHash encodes a combined salt & hash for password verification.\n  public PasswordHash: Array<u8> = new Array<u8>();\n  // Deprecated 2nd factor fields, use MFA below instead.\n  public TOTPKey: string = \"\";\n  public MFA: Array<MFADevice> = new Array<MFADevice>();\n  /**\n   * Webauthn holds settings necessary for webauthn local auth.\n   *  May be null for legacy users or users that haven't yet used webauthn as\n   *  their second factor.\n   */\n  public Webauthn: WebauthnLocalAuth = new WebauthnLocalAuth();\n\n  // Decodes LocalAuthSecrets from an ArrayBuffer\n  static decode(buf: ArrayBuffer): LocalAuthSecrets {\n    return LocalAuthSecrets.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes LocalAuthSecrets from a DataView\n  static decodeDataView(view: DataView): LocalAuthSecrets {\n    const decoder = new __proto.Decoder(view);\n    const obj = new LocalAuthSecrets();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.PasswordHash = decoder.bytes();\n          break;\n        }\n        case 2: {\n          obj.TOTPKey = decoder.string();\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.MFA.push(\n            MFADevice.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.Webauthn = WebauthnLocalAuth.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode LocalAuthSecrets\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.PasswordHash.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PasswordHash.length) +\n          this.PasswordHash.length\n        : 0;\n    size +=\n      this.TOTPKey.length > 0\n        ? 1 + __proto.Sizer.varint64(this.TOTPKey.length) + this.TOTPKey.length\n        : 0;\n\n    for (let n: i32 = 0; n < this.MFA.length; n++) {\n      const messageSize = this.MFA[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Webauthn != null) {\n      const f: WebauthnLocalAuth = this.Webauthn as WebauthnLocalAuth;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes LocalAuthSecrets to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes LocalAuthSecrets to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.PasswordHash.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.PasswordHash.length);\n      encoder.bytes(this.PasswordHash);\n    }\n    if (this.TOTPKey.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.TOTPKey.length);\n      encoder.string(this.TOTPKey);\n    }\n\n    for (let n: i32 = 0; n < this.MFA.length; n++) {\n      const messageSize = this.MFA[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        this.MFA[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Webauthn != null) {\n      const f = this.Webauthn as WebauthnLocalAuth;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode LocalAuthSecrets\n} // LocalAuthSecrets\n\n/**\n * MFADevice is a multi-factor authentication device, such as a security key or\n *  an OTP app.\n */\nexport class MFADevice {\n  // Boilerplate for implementing the Resource interface.\n  public kind: string = \"\";\n  public sub_kind: string = \"\";\n  public version: string = \"\";\n  public metadata: Metadata = new Metadata();\n  // ID is a UUID of this device.\n  public id: string = \"\";\n  public added_at: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  public last_used: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  public totp: TOTPDevice | null;\n  public u2f: U2FDevice | null;\n  public webauthn: WebauthnDevice | null;\n\n  public __device: string = \"\";\n  public __device_index: u8 = 0;\n\n  static readonly DEVICE_TOTP_INDEX: u8 = 8;\n  static readonly DEVICE_U2F_INDEX: u8 = 9;\n  static readonly DEVICE_WEBAUTHN_INDEX: u8 = 10;\n\n  // Decodes MFADevice from an ArrayBuffer\n  static decode(buf: ArrayBuffer): MFADevice {\n    return MFADevice.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes MFADevice from a DataView\n  static decodeDataView(view: DataView): MFADevice {\n    const decoder = new __proto.Decoder(view);\n    const obj = new MFADevice();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.sub_kind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.id = decoder.string();\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.added_at = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.last_used = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.totp = TOTPDevice.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.__device = \"totp\";\n          obj.__device_index = 8;\n          break;\n        }\n        case 9: {\n          const length = decoder.uint32();\n          obj.u2f = U2FDevice.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.__device = \"u2f\";\n          obj.__device_index = 9;\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.webauthn = WebauthnDevice.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.__device = \"webauthn\";\n          obj.__device_index = 10;\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode MFADevice\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.kind.length) + this.kind.length\n        : 0;\n    size +=\n      this.sub_kind.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.sub_kind.length) +\n          this.sub_kind.length\n        : 0;\n    size +=\n      this.version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.version.length) + this.version.length\n        : 0;\n\n    if (this.metadata != null) {\n      const f: Metadata = this.metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.id.length > 0\n        ? 1 + __proto.Sizer.varint64(this.id.length) + this.id.length\n        : 0;\n\n    if (this.added_at != null) {\n      const f: google.protobuf.Timestamp = this\n        .added_at as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.last_used != null) {\n      const f: google.protobuf.Timestamp = this\n        .last_used as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.totp != null) {\n      const f: TOTPDevice = this.totp as TOTPDevice;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.u2f != null) {\n      const f: U2FDevice = this.u2f as U2FDevice;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.webauthn != null) {\n      const f: WebauthnDevice = this.webauthn as WebauthnDevice;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes MFADevice to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes MFADevice to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.kind.length);\n      encoder.string(this.kind);\n    }\n    if (this.sub_kind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.sub_kind.length);\n      encoder.string(this.sub_kind);\n    }\n    if (this.version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.version.length);\n      encoder.string(this.version);\n    }\n\n    if (this.metadata != null) {\n      const f = this.metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.id.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.id.length);\n      encoder.string(this.id);\n    }\n\n    if (this.added_at != null) {\n      const f = this.added_at as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.last_used != null) {\n      const f = this.last_used as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.totp != null) {\n      const f = this.totp as TOTPDevice;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.u2f != null) {\n      const f = this.u2f as U2FDevice;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x4a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.webauthn != null) {\n      const f = this.webauthn as WebauthnDevice;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode MFADevice\n} // MFADevice\n\n// TOTPDevice holds the TOTP-specific fields of MFADevice.\nexport class TOTPDevice {\n  public key: string = \"\";\n\n  // Decodes TOTPDevice from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TOTPDevice {\n    return TOTPDevice.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TOTPDevice from a DataView\n  static decodeDataView(view: DataView): TOTPDevice {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TOTPDevice();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.key = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TOTPDevice\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.key.length > 0\n        ? 1 + __proto.Sizer.varint64(this.key.length) + this.key.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes TOTPDevice to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TOTPDevice to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.key.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.key.length);\n      encoder.string(this.key);\n    }\n\n    return buf;\n  } // encode TOTPDevice\n} // TOTPDevice\n\n// U2FDevice holds the U2F-specific fields of MFADevice.\nexport class U2FDevice {\n  // KeyHandle uniquely identifies a key on a device\n  public key_handle: Array<u8> = new Array<u8>();\n  // PubKey is an DER encoded ecdsa public key\n  public pub_key: Array<u8> = new Array<u8>();\n  // Counter is the latest seen value of the U2F usage counter.\n  public counter: u32;\n\n  // Decodes U2FDevice from an ArrayBuffer\n  static decode(buf: ArrayBuffer): U2FDevice {\n    return U2FDevice.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes U2FDevice from a DataView\n  static decodeDataView(view: DataView): U2FDevice {\n    const decoder = new __proto.Decoder(view);\n    const obj = new U2FDevice();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.key_handle = decoder.bytes();\n          break;\n        }\n        case 2: {\n          obj.pub_key = decoder.bytes();\n          break;\n        }\n        case 3: {\n          obj.counter = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode U2FDevice\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.key_handle.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.key_handle.length) +\n          this.key_handle.length\n        : 0;\n    size +=\n      this.pub_key.length > 0\n        ? 1 + __proto.Sizer.varint64(this.pub_key.length) + this.pub_key.length\n        : 0;\n    size += this.counter == 0 ? 0 : 1 + __proto.Sizer.uint32(this.counter);\n\n    return size;\n  }\n\n  // Encodes U2FDevice to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes U2FDevice to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.key_handle.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.key_handle.length);\n      encoder.bytes(this.key_handle);\n    }\n    if (this.pub_key.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.pub_key.length);\n      encoder.bytes(this.pub_key);\n    }\n    if (this.counter != 0) {\n      encoder.uint32(0x18);\n      encoder.uint32(this.counter);\n    }\n\n    return buf;\n  } // encode U2FDevice\n} // U2FDevice\n\n// WebauthnDevice holds Webauthn-specific fields of MFADevice.\nexport class WebauthnDevice {\n  // Credential ID for the authenticator.\n  public credential_id: Array<u8> = new Array<u8>();\n  /**\n   * Public key encoded in CBOR format.\n   *  Webauthn support various key algorithms; CBOR encoding is used to reflect\n   *  those choices.\n   *  See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter\n   *  reference.\n   */\n  public public_key_cbor: Array<u8> = new Array<u8>();\n  // Attestation format used by the authenticator, if any.\n  public attestation_type: string = \"\";\n  /**\n   * AAGUID is the globally unique identifier of the authenticator model.\n   *  Zeroed for U2F devices.\n   */\n  public aaguid: Array<u8> = new Array<u8>();\n  /**\n   * Signature counter for login operations.\n   *  Actual counter values received from the authenticator are expected to be\n   *  higher than the previously-stored value.\n   */\n  public signature_counter: u32;\n  /**\n   * Raw attestation object, as returned by the authentication during\n   *  registration.\n   *  Absent for legacy entries (Teleport 8.x).\n   */\n  public attestation_object: Array<u8> = new Array<u8>();\n  /**\n   * True if a resident key was requested during registration.\n   *  Marks passwordless-capable devices.\n   *  (Note that resident_key=true represents the server-side / Relying Party\n   *  view of the registration process; the authenticator alone can determine\n   *  if a key is truly resident.)\n   */\n  public resident_key: bool;\n\n  // Decodes WebauthnDevice from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WebauthnDevice {\n    return WebauthnDevice.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WebauthnDevice from a DataView\n  static decodeDataView(view: DataView): WebauthnDevice {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WebauthnDevice();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.credential_id = decoder.bytes();\n          break;\n        }\n        case 2: {\n          obj.public_key_cbor = decoder.bytes();\n          break;\n        }\n        case 3: {\n          obj.attestation_type = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.aaguid = decoder.bytes();\n          break;\n        }\n        case 5: {\n          obj.signature_counter = decoder.uint32();\n          break;\n        }\n        case 6: {\n          obj.attestation_object = decoder.bytes();\n          break;\n        }\n        case 7: {\n          obj.resident_key = decoder.bool();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WebauthnDevice\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.credential_id.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.credential_id.length) +\n          this.credential_id.length\n        : 0;\n    size +=\n      this.public_key_cbor.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.public_key_cbor.length) +\n          this.public_key_cbor.length\n        : 0;\n    size +=\n      this.attestation_type.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.attestation_type.length) +\n          this.attestation_type.length\n        : 0;\n    size +=\n      this.aaguid.length > 0\n        ? 1 + __proto.Sizer.varint64(this.aaguid.length) + this.aaguid.length\n        : 0;\n    size +=\n      this.signature_counter == 0\n        ? 0\n        : 1 + __proto.Sizer.uint32(this.signature_counter);\n    size +=\n      this.attestation_object.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.attestation_object.length) +\n          this.attestation_object.length\n        : 0;\n    size += this.resident_key == 0 ? 0 : 1 + 1;\n\n    return size;\n  }\n\n  // Encodes WebauthnDevice to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WebauthnDevice to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.credential_id.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.credential_id.length);\n      encoder.bytes(this.credential_id);\n    }\n    if (this.public_key_cbor.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.public_key_cbor.length);\n      encoder.bytes(this.public_key_cbor);\n    }\n    if (this.attestation_type.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.attestation_type.length);\n      encoder.string(this.attestation_type);\n    }\n    if (this.aaguid.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.aaguid.length);\n      encoder.bytes(this.aaguid);\n    }\n    if (this.signature_counter != 0) {\n      encoder.uint32(0x28);\n      encoder.uint32(this.signature_counter);\n    }\n    if (this.attestation_object.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.attestation_object.length);\n      encoder.bytes(this.attestation_object);\n    }\n    if (this.resident_key != 0) {\n      encoder.uint32(0x38);\n      encoder.bool(this.resident_key);\n    }\n\n    return buf;\n  } // encode WebauthnDevice\n} // WebauthnDevice\n\n// WebauthnLocalAuth holds settings necessary for local webauthn use.\nexport class WebauthnLocalAuth {\n  /**\n   * UserID is the random user handle generated for the user.\n   *  See https://www.w3.org/TR/webauthn-2/#sctn-user-handle-privacy.\n   */\n  public UserID: Array<u8> = new Array<u8>();\n\n  // Decodes WebauthnLocalAuth from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WebauthnLocalAuth {\n    return WebauthnLocalAuth.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WebauthnLocalAuth from a DataView\n  static decodeDataView(view: DataView): WebauthnLocalAuth {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WebauthnLocalAuth();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.UserID = decoder.bytes();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WebauthnLocalAuth\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.UserID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.UserID.length) + this.UserID.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes WebauthnLocalAuth to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WebauthnLocalAuth to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.UserID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.UserID.length);\n      encoder.bytes(this.UserID);\n    }\n\n    return buf;\n  } // encode WebauthnLocalAuth\n} // WebauthnLocalAuth\n\n// ConnectorRef holds information about OIDC connector\nexport class ConnectorRef {\n  // Type is connector type\n  public Type: string = \"\";\n  // ID is connector ID\n  public ID: string = \"\";\n  // Identity is external identity of the user\n  public Identity: string = \"\";\n\n  // Decodes ConnectorRef from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ConnectorRef {\n    return ConnectorRef.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ConnectorRef from a DataView\n  static decodeDataView(view: DataView): ConnectorRef {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ConnectorRef();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Type = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.ID = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Identity = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ConnectorRef\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Type.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Type.length) + this.Type.length\n        : 0;\n    size +=\n      this.ID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.ID.length) + this.ID.length\n        : 0;\n    size +=\n      this.Identity.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Identity.length) +\n          this.Identity.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ConnectorRef to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ConnectorRef to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Type.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Type.length);\n      encoder.string(this.Type);\n    }\n    if (this.ID.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.ID.length);\n      encoder.string(this.ID);\n    }\n    if (this.Identity.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Identity.length);\n      encoder.string(this.Identity);\n    }\n\n    return buf;\n  } // encode ConnectorRef\n} // ConnectorRef\n\n// UserRef holds references to user\nexport class UserRef {\n  // Name is name of the user\n  public Name: string = \"\";\n\n  // Decodes UserRef from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserRef {\n    return UserRef.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserRef from a DataView\n  static decodeDataView(view: DataView): UserRef {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserRef();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserRef\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes UserRef to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserRef to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n\n    return buf;\n  } // encode UserRef\n} // UserRef\n\n// ReverseTunnelV2 is version 2 of the resource spec of the reverse tunnel\nexport class ReverseTunnelV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is a resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a reverse tunnel specification\n  public Spec: ReverseTunnelSpecV2 = new ReverseTunnelSpecV2();\n\n  // Decodes ReverseTunnelV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ReverseTunnelV2 {\n    return ReverseTunnelV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ReverseTunnelV2 from a DataView\n  static decodeDataView(view: DataView): ReverseTunnelV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ReverseTunnelV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = ReverseTunnelSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ReverseTunnelV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: ReverseTunnelSpecV2 = this.Spec as ReverseTunnelSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ReverseTunnelV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ReverseTunnelV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as ReverseTunnelSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode ReverseTunnelV2\n} // ReverseTunnelV2\n\n// ReverseTunnelSpecV2 is a specification for V2 reverse tunnel\nexport class ReverseTunnelSpecV2 {\n  // ClusterName is a domain name of remote cluster we are connecting to\n  public ClusterName: string = \"\";\n  /**\n   * DialAddrs is a list of remote address to establish a connection to\n   *  it's always SSH over TCP\n   */\n  public DialAddrs: Array<string> = new Array<string>();\n  // Type is the type of reverse tunnel, either proxy or node.\n  public Type: string = \"\";\n\n  // Decodes ReverseTunnelSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ReverseTunnelSpecV2 {\n    return ReverseTunnelSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ReverseTunnelSpecV2 from a DataView\n  static decodeDataView(view: DataView): ReverseTunnelSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ReverseTunnelSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ClusterName = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.DialAddrs.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.Type = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ReverseTunnelSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ClusterName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClusterName.length) +\n          this.ClusterName.length\n        : 0;\n\n    size += __size_string_repeated(this.DialAddrs);\n\n    size +=\n      this.Type.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Type.length) + this.Type.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ReverseTunnelSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ReverseTunnelSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ClusterName.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.ClusterName.length);\n      encoder.string(this.ClusterName);\n    }\n\n    if (this.DialAddrs.length > 0) {\n      for (let n: i32 = 0; n < this.DialAddrs.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.DialAddrs[n].length);\n        encoder.string(this.DialAddrs[n]);\n      }\n    }\n\n    if (this.Type.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Type.length);\n      encoder.string(this.Type);\n    }\n\n    return buf;\n  } // encode ReverseTunnelSpecV2\n} // ReverseTunnelSpecV2\n\n// TunnelConnectionV2 is version 2 of the resource spec of the tunnel connection\nexport class TunnelConnectionV2 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is a resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a tunnel specification\n  public Spec: TunnelConnectionSpecV2 = new TunnelConnectionSpecV2();\n\n  // Decodes TunnelConnectionV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TunnelConnectionV2 {\n    return TunnelConnectionV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TunnelConnectionV2 from a DataView\n  static decodeDataView(view: DataView): TunnelConnectionV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TunnelConnectionV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = TunnelConnectionSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TunnelConnectionV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: TunnelConnectionSpecV2 = this.Spec as TunnelConnectionSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes TunnelConnectionV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TunnelConnectionV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as TunnelConnectionSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode TunnelConnectionV2\n} // TunnelConnectionV2\n\n// TunnelConnectionSpecV2 is a specification for V2 tunnel connection\nexport class TunnelConnectionSpecV2 {\n  // ClusterName is a name of the cluster\n  public ClusterName: string = \"\";\n  // ProxyName is the name of the proxy server\n  public ProxyName: string = \"\";\n  // LastHeartbeat is a time of the last heartbeat\n  public LastHeartbeat: google.protobuf.Timestamp =\n    new google.protobuf.Timestamp();\n  // Type is the type of reverse tunnel, either proxy or node.\n  public Type: string = \"\";\n\n  // Decodes TunnelConnectionSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TunnelConnectionSpecV2 {\n    return TunnelConnectionSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TunnelConnectionSpecV2 from a DataView\n  static decodeDataView(view: DataView): TunnelConnectionSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TunnelConnectionSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ClusterName = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.ProxyName = decoder.string();\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.LastHeartbeat = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.Type = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TunnelConnectionSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ClusterName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClusterName.length) +\n          this.ClusterName.length\n        : 0;\n    size +=\n      this.ProxyName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ProxyName.length) +\n          this.ProxyName.length\n        : 0;\n\n    if (this.LastHeartbeat != null) {\n      const f: google.protobuf.Timestamp = this\n        .LastHeartbeat as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Type.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Type.length) + this.Type.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes TunnelConnectionSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TunnelConnectionSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ClusterName.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.ClusterName.length);\n      encoder.string(this.ClusterName);\n    }\n    if (this.ProxyName.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.ProxyName.length);\n      encoder.string(this.ProxyName);\n    }\n\n    if (this.LastHeartbeat != null) {\n      const f = this.LastHeartbeat as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Type.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.Type.length);\n      encoder.string(this.Type);\n    }\n\n    return buf;\n  } // encode TunnelConnectionSpecV2\n} // TunnelConnectionSpecV2\n\n/**\n * SemaphoreFilter encodes semaphore filtering params.\n *  A semaphore filter matches a semaphore if all nonzero fields\n *  match the corresponding semaphore fileds (e.g. a filter which\n *  specifies only `kind=foo` would match all semaphores of\n *  kind `foo`).\n */\nexport class SemaphoreFilter {\n  // SemaphoreKind is the kind of the semaphore.\n  public SemaphoreKind: string = \"\";\n  // SemaphoreName is the name of the semaphore.\n  public SemaphoreName: string = \"\";\n\n  // Decodes SemaphoreFilter from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SemaphoreFilter {\n    return SemaphoreFilter.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SemaphoreFilter from a DataView\n  static decodeDataView(view: DataView): SemaphoreFilter {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SemaphoreFilter();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.SemaphoreKind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SemaphoreName = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SemaphoreFilter\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.SemaphoreKind.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SemaphoreKind.length) +\n          this.SemaphoreKind.length\n        : 0;\n    size +=\n      this.SemaphoreName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SemaphoreName.length) +\n          this.SemaphoreName.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes SemaphoreFilter to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SemaphoreFilter to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.SemaphoreKind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.SemaphoreKind.length);\n      encoder.string(this.SemaphoreKind);\n    }\n    if (this.SemaphoreName.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SemaphoreName.length);\n      encoder.string(this.SemaphoreName);\n    }\n\n    return buf;\n  } // encode SemaphoreFilter\n} // SemaphoreFilter\n\n// AcquireSemaphoreRequest holds semaphore lease acquisition parameters.\nexport class AcquireSemaphoreRequest {\n  // SemaphoreKind is the kind of the semaphore.\n  public SemaphoreKind: string = \"\";\n  // SemaphoreName is the name of the semaphore.\n  public SemaphoreName: string = \"\";\n  /**\n   * MaxLeases is the maximum number of concurrent leases.  If acquisition\n   *  would cause more than MaxLeases to exist, acquisition must fail.\n   */\n  public MaxLeases: i64;\n  // Expires is the time at which this lease expires.\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // Holder identifies the entitiy holding the lease.\n  public Holder: string = \"\";\n\n  // Decodes AcquireSemaphoreRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AcquireSemaphoreRequest {\n    return AcquireSemaphoreRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AcquireSemaphoreRequest from a DataView\n  static decodeDataView(view: DataView): AcquireSemaphoreRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AcquireSemaphoreRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.SemaphoreKind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SemaphoreName = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.MaxLeases = decoder.int64();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.Holder = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AcquireSemaphoreRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.SemaphoreKind.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SemaphoreKind.length) +\n          this.SemaphoreKind.length\n        : 0;\n    size +=\n      this.SemaphoreName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SemaphoreName.length) +\n          this.SemaphoreName.length\n        : 0;\n    size += this.MaxLeases == 0 ? 0 : 1 + __proto.Sizer.int64(this.MaxLeases);\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Holder.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Holder.length) + this.Holder.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes AcquireSemaphoreRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AcquireSemaphoreRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.SemaphoreKind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.SemaphoreKind.length);\n      encoder.string(this.SemaphoreKind);\n    }\n    if (this.SemaphoreName.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SemaphoreName.length);\n      encoder.string(this.SemaphoreName);\n    }\n    if (this.MaxLeases != 0) {\n      encoder.uint32(0x18);\n      encoder.int64(this.MaxLeases);\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Holder.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.Holder.length);\n      encoder.string(this.Holder);\n    }\n\n    return buf;\n  } // encode AcquireSemaphoreRequest\n} // AcquireSemaphoreRequest\n\n// SemaphoreLease represents lease acquired for semaphore\nexport class SemaphoreLease {\n  // SemaphoreKind is the kind of the semaphore.\n  public SemaphoreKind: string = \"\";\n  // SemaphoreName is the name of the semaphore.\n  public SemaphoreName: string = \"\";\n  // LeaseID uniquely identifies this lease.\n  public LeaseID: string = \"\";\n  // Expires is the time at which this lease expires.\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n\n  // Decodes SemaphoreLease from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SemaphoreLease {\n    return SemaphoreLease.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SemaphoreLease from a DataView\n  static decodeDataView(view: DataView): SemaphoreLease {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SemaphoreLease();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.SemaphoreKind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SemaphoreName = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.LeaseID = decoder.string();\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SemaphoreLease\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.SemaphoreKind.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SemaphoreKind.length) +\n          this.SemaphoreKind.length\n        : 0;\n    size +=\n      this.SemaphoreName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SemaphoreName.length) +\n          this.SemaphoreName.length\n        : 0;\n    size +=\n      this.LeaseID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.LeaseID.length) + this.LeaseID.length\n        : 0;\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SemaphoreLease to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SemaphoreLease to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.SemaphoreKind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.SemaphoreKind.length);\n      encoder.string(this.SemaphoreKind);\n    }\n    if (this.SemaphoreName.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SemaphoreName.length);\n      encoder.string(this.SemaphoreName);\n    }\n    if (this.LeaseID.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.LeaseID.length);\n      encoder.string(this.LeaseID);\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SemaphoreLease\n} // SemaphoreLease\n\n// SemaphoreLeaseRef identifies an existent lease.\nexport class SemaphoreLeaseRef {\n  // LeaseID is the unique ID of the lease.\n  public LeaseID: string = \"\";\n  // Expires is the time at which the lease expires.\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // Holder identifies the lease holder.\n  public Holder: string = \"\";\n\n  // Decodes SemaphoreLeaseRef from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SemaphoreLeaseRef {\n    return SemaphoreLeaseRef.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SemaphoreLeaseRef from a DataView\n  static decodeDataView(view: DataView): SemaphoreLeaseRef {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SemaphoreLeaseRef();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.LeaseID = decoder.string();\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          obj.Holder = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SemaphoreLeaseRef\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.LeaseID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.LeaseID.length) + this.LeaseID.length\n        : 0;\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Holder.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Holder.length) + this.Holder.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes SemaphoreLeaseRef to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SemaphoreLeaseRef to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.LeaseID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.LeaseID.length);\n      encoder.string(this.LeaseID);\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Holder.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Holder.length);\n      encoder.string(this.Holder);\n    }\n\n    return buf;\n  } // encode SemaphoreLeaseRef\n} // SemaphoreLeaseRef\n\n// SemaphoreV3 implements Semaphore interface\nexport class SemaphoreV3 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is version\n  public Version: string = \"\";\n  // Metadata is Semaphore metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec is a lease V3 spec\n  public Spec: SemaphoreSpecV3 = new SemaphoreSpecV3();\n\n  // Decodes SemaphoreV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SemaphoreV3 {\n    return SemaphoreV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SemaphoreV3 from a DataView\n  static decodeDataView(view: DataView): SemaphoreV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SemaphoreV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = SemaphoreSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SemaphoreV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: SemaphoreSpecV3 = this.Spec as SemaphoreSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SemaphoreV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SemaphoreV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as SemaphoreSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SemaphoreV3\n} // SemaphoreV3\n\n// SemaphoreSpecV3 contains the data about lease\nexport class SemaphoreSpecV3 {\n  // Leases is a list of all currently acquired leases.\n  public Leases: Array<SemaphoreLeaseRef> = new Array<SemaphoreLeaseRef>();\n\n  // Decodes SemaphoreSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SemaphoreSpecV3 {\n    return SemaphoreSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SemaphoreSpecV3 from a DataView\n  static decodeDataView(view: DataView): SemaphoreSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SemaphoreSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Leases.push(\n            SemaphoreLeaseRef.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SemaphoreSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.Leases.length; n++) {\n      const messageSize = this.Leases[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SemaphoreSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SemaphoreSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.Leases.length; n++) {\n      const messageSize = this.Leases[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.Leases[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SemaphoreSpecV3\n} // SemaphoreSpecV3\n\n// WebSessionV2 represents an application or UI web session.\nexport class WebSessionV2 {\n  // Kind is a resource kind.\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources.\n  public SubKind: string = \"\";\n  // Version is version.\n  public Version: string = \"\";\n  // Metadata is a resource metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is a tunnel specification.\n  public Spec: WebSessionSpecV2 = new WebSessionSpecV2();\n\n  // Decodes WebSessionV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WebSessionV2 {\n    return WebSessionV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WebSessionV2 from a DataView\n  static decodeDataView(view: DataView): WebSessionV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WebSessionV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = WebSessionSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WebSessionV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: WebSessionSpecV2 = this.Spec as WebSessionSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes WebSessionV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WebSessionV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as WebSessionSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode WebSessionV2\n} // WebSessionV2\n\n// WebSessionSpecV2 is a specification for web session.\nexport class WebSessionSpecV2 {\n  // User is the identity of the user to which the web session belongs.\n  public User: string = \"\";\n  // Pub is the SSH certificate for the user.\n  public Pub: Array<u8> = new Array<u8>();\n  // Priv is the SSH private key for the user.\n  public Priv: Array<u8> = new Array<u8>();\n  // TLSCert is the TLS certificate for the user.\n  public TLSCert: Array<u8> = new Array<u8>();\n  /**\n   * BearerToken is a token that is paired with the session cookie for\n   *  authentication. It is periodically rotated so a stolen cookie itself\n   *  is not enough to steal a session. In addition it is used for CSRF\n   *  mitigation.\n   */\n  public BearerToken: string = \"\";\n  // BearerTokenExpires is the absolute time when the token expires.\n  public BearerTokenExpires: google.protobuf.Timestamp =\n    new google.protobuf.Timestamp();\n  // Expires is the absolute time when the session expires.\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // LoginTime is the time this user recently logged in.\n  public LoginTime: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // IdleTimeout is the max time a user can be inactive in a session.\n  public IdleTimeout: i64;\n\n  // Decodes WebSessionSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WebSessionSpecV2 {\n    return WebSessionSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WebSessionSpecV2 from a DataView\n  static decodeDataView(view: DataView): WebSessionSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WebSessionSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Pub = decoder.bytes();\n          break;\n        }\n        case 3: {\n          obj.Priv = decoder.bytes();\n          break;\n        }\n        case 4: {\n          obj.TLSCert = decoder.bytes();\n          break;\n        }\n        case 5: {\n          obj.BearerToken = decoder.string();\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.BearerTokenExpires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.LoginTime = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 9: {\n          obj.IdleTimeout = decoder.int64();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WebSessionSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size +=\n      this.Pub.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Pub.length) + this.Pub.length\n        : 0;\n    size +=\n      this.Priv.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Priv.length) + this.Priv.length\n        : 0;\n    size +=\n      this.TLSCert.length > 0\n        ? 1 + __proto.Sizer.varint64(this.TLSCert.length) + this.TLSCert.length\n        : 0;\n    size +=\n      this.BearerToken.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.BearerToken.length) +\n          this.BearerToken.length\n        : 0;\n\n    if (this.BearerTokenExpires != null) {\n      const f: google.protobuf.Timestamp = this\n        .BearerTokenExpires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.LoginTime != null) {\n      const f: google.protobuf.Timestamp = this\n        .LoginTime as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.IdleTimeout == 0 ? 0 : 1 + __proto.Sizer.int64(this.IdleTimeout);\n\n    return size;\n  }\n\n  // Encodes WebSessionSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WebSessionSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.Pub.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Pub.length);\n      encoder.bytes(this.Pub);\n    }\n    if (this.Priv.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Priv.length);\n      encoder.bytes(this.Priv);\n    }\n    if (this.TLSCert.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.TLSCert.length);\n      encoder.bytes(this.TLSCert);\n    }\n    if (this.BearerToken.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.BearerToken.length);\n      encoder.string(this.BearerToken);\n    }\n\n    if (this.BearerTokenExpires != null) {\n      const f = this.BearerTokenExpires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.LoginTime != null) {\n      const f = this.LoginTime as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.IdleTimeout != 0) {\n      encoder.uint32(0x48);\n      encoder.int64(this.IdleTimeout);\n    }\n\n    return buf;\n  } // encode WebSessionSpecV2\n} // WebSessionSpecV2\n\n// WebSessionFilter encodes cache watch parameters for filtering web sessions.\nexport class WebSessionFilter {\n  // User is the username to filter web sessions for.\n  public User: string = \"\";\n\n  // Decodes WebSessionFilter from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WebSessionFilter {\n    return WebSessionFilter.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WebSessionFilter from a DataView\n  static decodeDataView(view: DataView): WebSessionFilter {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WebSessionFilter();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WebSessionFilter\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes WebSessionFilter to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WebSessionFilter to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n\n    return buf;\n  } // encode WebSessionFilter\n} // WebSessionFilter\n\n// RemoteClusterV3 represents remote cluster resource specification\nexport class RemoteClusterV3 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources\n  public SubKind: string = \"\";\n  // Version is resource API version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Status is a remote cluster status\n  public Status: RemoteClusterStatusV3 = new RemoteClusterStatusV3();\n\n  // Decodes RemoteClusterV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RemoteClusterV3 {\n    return RemoteClusterV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RemoteClusterV3 from a DataView\n  static decodeDataView(view: DataView): RemoteClusterV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RemoteClusterV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Status = RemoteClusterStatusV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RemoteClusterV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Status != null) {\n      const f: RemoteClusterStatusV3 = this.Status as RemoteClusterStatusV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RemoteClusterV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RemoteClusterV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Status != null) {\n      const f = this.Status as RemoteClusterStatusV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RemoteClusterV3\n} // RemoteClusterV3\n\n// RemoteClusterStatusV3 represents status of the remote cluster\nexport class RemoteClusterStatusV3 {\n  // Connection represents connection status, online or offline\n  public Connection: string = \"\";\n  // LastHeartbeat records last heartbeat of the cluster\n  public LastHeartbeat: google.protobuf.Timestamp =\n    new google.protobuf.Timestamp();\n\n  // Decodes RemoteClusterStatusV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RemoteClusterStatusV3 {\n    return RemoteClusterStatusV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RemoteClusterStatusV3 from a DataView\n  static decodeDataView(view: DataView): RemoteClusterStatusV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RemoteClusterStatusV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Connection = decoder.string();\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.LastHeartbeat = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RemoteClusterStatusV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Connection.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Connection.length) +\n          this.Connection.length\n        : 0;\n\n    if (this.LastHeartbeat != null) {\n      const f: google.protobuf.Timestamp = this\n        .LastHeartbeat as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RemoteClusterStatusV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RemoteClusterStatusV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Connection.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Connection.length);\n      encoder.string(this.Connection);\n    }\n\n    if (this.LastHeartbeat != null) {\n      const f = this.LastHeartbeat as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RemoteClusterStatusV3\n} // RemoteClusterStatusV3\n\n/**\n * KubernetesCluster is a named kubernetes API endpoint handled by a Server.\n *\n *  TODO: deprecate and convert all usage to KubernetesClusterV3\n */\nexport class KubernetesCluster {\n  // Name is the name of this kubernetes cluster.\n  public Name: string = \"\";\n  /**\n   * StaticLabels is map of static labels associated with this cluster.\n   *  Used for RBAC.\n   */\n  public StaticLabels: Map<string, string> = new Map<string, string>();\n  /**\n   * DynamicLabels is map of dynamic labels associated with this cluster.\n   *  Used for RBAC.\n   */\n  public DynamicLabels: Map<string, CommandLabelV2> = new Map<\n    string,\n    CommandLabelV2\n  >();\n\n  // Decodes KubernetesCluster from an ArrayBuffer\n  static decode(buf: ArrayBuffer): KubernetesCluster {\n    return KubernetesCluster.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes KubernetesCluster from a DataView\n  static decodeDataView(view: DataView): KubernetesCluster {\n    const decoder = new __proto.Decoder(view);\n    const obj = new KubernetesCluster();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.StaticLabels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          __decodeMap_string_CommandLabelV2(decoder, length, obj.DynamicLabels);\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode KubernetesCluster\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n\n    if (this.StaticLabels.size > 0) {\n      const keys = this.StaticLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.StaticLabels.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const itemSize = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes KubernetesCluster to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes KubernetesCluster to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n\n    if (this.StaticLabels.size > 0) {\n      const keys = this.StaticLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.StaticLabels.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0x12);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const size = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (size > 0) {\n          encoder.uint32(0x1a);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n\n          const messageSize = value.size();\n\n          if (messageSize > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(messageSize);\n            value.encodeU8Array(encoder);\n          }\n        }\n      }\n    }\n\n    return buf;\n  } // encode KubernetesCluster\n} // KubernetesCluster\n\n// KubernetesClusterV3 represents a named kubernetes API endpoint.\nexport class KubernetesClusterV3 {\n  // Kind is the cluster resource kind.\n  public Kind: string = \"\";\n  // SubKind is an optional resource subkind.\n  public SubKind: string = \"\";\n  // Version is the resource version.\n  public Version: string = \"\";\n  // Metadata is the resource metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is the resource spec.\n  public Spec: KubernetesClusterSpecV3 = new KubernetesClusterSpecV3();\n\n  // Decodes KubernetesClusterV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): KubernetesClusterV3 {\n    return KubernetesClusterV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes KubernetesClusterV3 from a DataView\n  static decodeDataView(view: DataView): KubernetesClusterV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new KubernetesClusterV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = KubernetesClusterSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode KubernetesClusterV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: KubernetesClusterSpecV3 = this.Spec as KubernetesClusterSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes KubernetesClusterV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes KubernetesClusterV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as KubernetesClusterSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode KubernetesClusterV3\n} // KubernetesClusterV3\n\n// KubernetesClusterSpecV3 is a specification for a Kubernetes cluster.\nexport class KubernetesClusterSpecV3 {\n  // DynamicLabels are the cluster's dynamic labels.\n  public DynamicLabels: Map<string, CommandLabelV2> = new Map<\n    string,\n    CommandLabelV2\n  >();\n\n  // Decodes KubernetesClusterSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): KubernetesClusterSpecV3 {\n    return KubernetesClusterSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes KubernetesClusterSpecV3 from a DataView\n  static decodeDataView(view: DataView): KubernetesClusterSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new KubernetesClusterSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          __decodeMap_string_CommandLabelV2(decoder, length, obj.DynamicLabels);\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode KubernetesClusterSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const itemSize = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes KubernetesClusterSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes KubernetesClusterSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.DynamicLabels.size > 0) {\n      const keys = this.DynamicLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DynamicLabels.get(key);\n        const size = __sizeMapEntry_string_CommandLabelV2(key, value);\n        if (size > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n\n          const messageSize = value.size();\n\n          if (messageSize > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(messageSize);\n            value.encodeU8Array(encoder);\n          }\n        }\n      }\n    }\n\n    return buf;\n  } // encode KubernetesClusterSpecV3\n} // KubernetesClusterSpecV3\n\n/**\n * WebTokenV3 describes a web token. Web tokens are used as a transport to relay bearer tokens\n *  to the client.\n *  Initially bound to a web session, these have been factored out into a separate resource to\n *  enable separate lifecycle management.\n */\nexport class WebTokenV3 {\n  // Kind is a resource kind\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind\n  public SubKind: string = \"\";\n  // Version is the resource version\n  public Version: string = \"\";\n  // Metadata is resource metadata\n  public Metadata: Metadata = new Metadata();\n  // Spec defines the web token\n  public Spec: WebTokenSpecV3 = new WebTokenSpecV3();\n\n  // Decodes WebTokenV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WebTokenV3 {\n    return WebTokenV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WebTokenV3 from a DataView\n  static decodeDataView(view: DataView): WebTokenV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WebTokenV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = WebTokenSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WebTokenV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: WebTokenSpecV3 = this.Spec as WebTokenSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes WebTokenV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WebTokenV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as WebTokenSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode WebTokenV3\n} // WebTokenV3\n\n// WebTokenSpecV3 is a unique time-limited token bound to a user's web session\nexport class WebTokenSpecV3 {\n  // User specifies the user the token is bound to.\n  public User: string = \"\";\n  // Token specifies the token's value.\n  public Token: string = \"\";\n\n  // Decodes WebTokenSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WebTokenSpecV3 {\n    return WebTokenSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WebTokenSpecV3 from a DataView\n  static decodeDataView(view: DataView): WebTokenSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WebTokenSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Token = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WebTokenSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size +=\n      this.Token.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Token.length) + this.Token.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes WebTokenSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WebTokenSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.Token.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Token.length);\n      encoder.string(this.Token);\n    }\n\n    return buf;\n  } // encode WebTokenSpecV3\n} // WebTokenSpecV3\n\n// GetWebSessionRequest describes a request to query a web session\nexport class GetWebSessionRequest {\n  // User specifies the user the web session is for.\n  public User: string = \"\";\n  // SessionID specifies the web session ID.\n  public SessionID: string = \"\";\n\n  // Decodes GetWebSessionRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): GetWebSessionRequest {\n    return GetWebSessionRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes GetWebSessionRequest from a DataView\n  static decodeDataView(view: DataView): GetWebSessionRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new GetWebSessionRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SessionID = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode GetWebSessionRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size +=\n      this.SessionID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SessionID.length) +\n          this.SessionID.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes GetWebSessionRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes GetWebSessionRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.SessionID.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SessionID.length);\n      encoder.string(this.SessionID);\n    }\n\n    return buf;\n  } // encode GetWebSessionRequest\n} // GetWebSessionRequest\n\n// DeleteWebSessionRequest describes a request to delete a web session\nexport class DeleteWebSessionRequest {\n  // User specifies the user the session is bound to\n  public User: string = \"\";\n  // SessionID specifies the web session ID to delete.\n  public SessionID: string = \"\";\n\n  // Decodes DeleteWebSessionRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DeleteWebSessionRequest {\n    return DeleteWebSessionRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DeleteWebSessionRequest from a DataView\n  static decodeDataView(view: DataView): DeleteWebSessionRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DeleteWebSessionRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SessionID = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DeleteWebSessionRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size +=\n      this.SessionID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SessionID.length) +\n          this.SessionID.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes DeleteWebSessionRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DeleteWebSessionRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.SessionID.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SessionID.length);\n      encoder.string(this.SessionID);\n    }\n\n    return buf;\n  } // encode DeleteWebSessionRequest\n} // DeleteWebSessionRequest\n\n// GetWebTokenRequest describes a request to query a web token\nexport class GetWebTokenRequest {\n  // User specifies the user the token is for.\n  public User: string = \"\";\n  // Token specifies the token to get.\n  public Token: string = \"\";\n\n  // Decodes GetWebTokenRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): GetWebTokenRequest {\n    return GetWebTokenRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes GetWebTokenRequest from a DataView\n  static decodeDataView(view: DataView): GetWebTokenRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new GetWebTokenRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Token = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode GetWebTokenRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size +=\n      this.Token.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Token.length) + this.Token.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes GetWebTokenRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes GetWebTokenRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.Token.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Token.length);\n      encoder.string(this.Token);\n    }\n\n    return buf;\n  } // encode GetWebTokenRequest\n} // GetWebTokenRequest\n\n// DeleteWebTokenRequest describes a request to delete a web token\nexport class DeleteWebTokenRequest {\n  // User specifies the user the token is for.\n  public User: string = \"\";\n  // Token specifies the token to delete.\n  public Token: string = \"\";\n\n  // Decodes DeleteWebTokenRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DeleteWebTokenRequest {\n    return DeleteWebTokenRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DeleteWebTokenRequest from a DataView\n  static decodeDataView(view: DataView): DeleteWebTokenRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DeleteWebTokenRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Token = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DeleteWebTokenRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size +=\n      this.Token.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Token.length) + this.Token.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes DeleteWebTokenRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DeleteWebTokenRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.Token.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Token.length);\n      encoder.string(this.Token);\n    }\n\n    return buf;\n  } // encode DeleteWebTokenRequest\n} // DeleteWebTokenRequest\n\n// ResourceRequest is a request relating to a named resource.\nexport class ResourceRequest {\n  // Name is the name of the resource.\n  public Name: string = \"\";\n\n  // Decodes ResourceRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ResourceRequest {\n    return ResourceRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ResourceRequest from a DataView\n  static decodeDataView(view: DataView): ResourceRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ResourceRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ResourceRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ResourceRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ResourceRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n\n    return buf;\n  } // encode ResourceRequest\n} // ResourceRequest\n\n// ResourceWithSecretsRequest is a request relating to a named resource with secrets.\nexport class ResourceWithSecretsRequest {\n  // Name is the name of the resource.\n  public Name: string = \"\";\n  // WithSecrets specifies whether to load associated secrets.\n  public WithSecrets: bool;\n\n  // Decodes ResourceWithSecretsRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ResourceWithSecretsRequest {\n    return ResourceWithSecretsRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ResourceWithSecretsRequest from a DataView\n  static decodeDataView(view: DataView): ResourceWithSecretsRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ResourceWithSecretsRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.WithSecrets = decoder.bool();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ResourceWithSecretsRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size += this.WithSecrets == 0 ? 0 : 1 + 1;\n\n    return size;\n  }\n\n  // Encodes ResourceWithSecretsRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ResourceWithSecretsRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.WithSecrets != 0) {\n      encoder.uint32(0x10);\n      encoder.bool(this.WithSecrets);\n    }\n\n    return buf;\n  } // encode ResourceWithSecretsRequest\n} // ResourceWithSecretsRequest\n\n// ResourcesWithSecretsRequest is a request relating to resources with secrets.\nexport class ResourcesWithSecretsRequest {\n  // WithSecrets specifies whether to load associated secrets.\n  public WithSecrets: bool;\n\n  // Decodes ResourcesWithSecretsRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ResourcesWithSecretsRequest {\n    return ResourcesWithSecretsRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ResourcesWithSecretsRequest from a DataView\n  static decodeDataView(view: DataView): ResourcesWithSecretsRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ResourcesWithSecretsRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.WithSecrets = decoder.bool();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ResourcesWithSecretsRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.WithSecrets == 0 ? 0 : 1 + 1;\n\n    return size;\n  }\n\n  // Encodes ResourcesWithSecretsRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ResourcesWithSecretsRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.WithSecrets != 0) {\n      encoder.uint32(0x8);\n      encoder.bool(this.WithSecrets);\n    }\n\n    return buf;\n  } // encode ResourcesWithSecretsRequest\n} // ResourcesWithSecretsRequest\n\n// ResourcesInNamespaceRequest is a request relating to a named resource in the given namespace.\nexport class ResourceInNamespaceRequest {\n  // Name is the name of the resource.\n  public Name: string = \"\";\n  // Namespace is the namespace of resources.\n  public Namespace: string = \"\";\n\n  // Decodes ResourceInNamespaceRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ResourceInNamespaceRequest {\n    return ResourceInNamespaceRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ResourceInNamespaceRequest from a DataView\n  static decodeDataView(view: DataView): ResourceInNamespaceRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ResourceInNamespaceRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Namespace = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ResourceInNamespaceRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.Namespace.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Namespace.length) +\n          this.Namespace.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ResourceInNamespaceRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ResourceInNamespaceRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.Namespace.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Namespace.length);\n      encoder.string(this.Namespace);\n    }\n\n    return buf;\n  } // encode ResourceInNamespaceRequest\n} // ResourceInNamespaceRequest\n\n// ResourcesInNamespaceRequest is a request relating to resources in the given namespace.\nexport class ResourcesInNamespaceRequest {\n  // Namespace is the namespace of resources.\n  public Namespace: string = \"\";\n\n  // Decodes ResourcesInNamespaceRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ResourcesInNamespaceRequest {\n    return ResourcesInNamespaceRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ResourcesInNamespaceRequest from a DataView\n  static decodeDataView(view: DataView): ResourcesInNamespaceRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ResourcesInNamespaceRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Namespace = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ResourcesInNamespaceRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Namespace.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Namespace.length) +\n          this.Namespace.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ResourcesInNamespaceRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ResourcesInNamespaceRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Namespace.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Namespace.length);\n      encoder.string(this.Namespace);\n    }\n\n    return buf;\n  } // encode ResourcesInNamespaceRequest\n} // ResourcesInNamespaceRequest\n\n// OIDCConnectorV3 represents an OIDC connector.\nexport class OIDCConnectorV3 {\n  // Kind is a resource kind.\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources.\n  public SubKind: string = \"\";\n  // Version is a resource version.\n  public Version: string = \"\";\n  // Metadata holds resource metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is an OIDC connector specification.\n  public Spec: OIDCConnectorSpecV3 = new OIDCConnectorSpecV3();\n\n  // Decodes OIDCConnectorV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): OIDCConnectorV3 {\n    return OIDCConnectorV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes OIDCConnectorV3 from a DataView\n  static decodeDataView(view: DataView): OIDCConnectorV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new OIDCConnectorV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = OIDCConnectorSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode OIDCConnectorV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: OIDCConnectorSpecV3 = this.Spec as OIDCConnectorSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes OIDCConnectorV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes OIDCConnectorV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as OIDCConnectorSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode OIDCConnectorV3\n} // OIDCConnectorV3\n\n// OIDCConnectorV3List is a list of OIDC connectors.\nexport class OIDCConnectorV3List {\n  // OIDCConnectors is a list of OIDC connectors.\n  public OIDCConnectors: Array<OIDCConnectorV3> = new Array<OIDCConnectorV3>();\n\n  // Decodes OIDCConnectorV3List from an ArrayBuffer\n  static decode(buf: ArrayBuffer): OIDCConnectorV3List {\n    return OIDCConnectorV3List.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes OIDCConnectorV3List from a DataView\n  static decodeDataView(view: DataView): OIDCConnectorV3List {\n    const decoder = new __proto.Decoder(view);\n    const obj = new OIDCConnectorV3List();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.OIDCConnectors.push(\n            OIDCConnectorV3.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode OIDCConnectorV3List\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.OIDCConnectors.length; n++) {\n      const messageSize = this.OIDCConnectors[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes OIDCConnectorV3List to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes OIDCConnectorV3List to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.OIDCConnectors.length; n++) {\n      const messageSize = this.OIDCConnectors[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.OIDCConnectors[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode OIDCConnectorV3List\n} // OIDCConnectorV3List\n\n/**\n * OIDCConnectorSpecV3 is an OIDC connector specification.\n *\n *  It specifies configuration for Open ID Connect compatible external\n *  identity provider: https://openid.net/specs/openid-connect-core-1_0.html\n */\nexport class OIDCConnectorSpecV3 {\n  // IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.\n  public IssuerURL: string = \"\";\n  // ClientID is the id of the authentication client (Teleport Auth server).\n  public ClientID: string = \"\";\n  // ClientSecret is used to authenticate the client.\n  public ClientSecret: string = \"\";\n  /**\n   * RedirectURL is a URL that will redirect the client's browser\n   *  back to the identity provider after successful authentication.\n   *  This should match the URL on the Provider's side.\n   */\n  public RedirectURL: string = \"\";\n  /**\n   * ACR is an Authentication Context Class Reference value. The meaning of the ACR\n   *  value is context-specific and varies for identity providers.\n   */\n  public ACR: string = \"\";\n  // Provider is the external identity provider.\n  public Provider: string = \"\";\n  // Display is the friendly name for this provider.\n  public Display: string = \"\";\n  // Scope specifies additional scopes set by provider.\n  public Scope: Array<string> = new Array<string>();\n  /**\n   * Prompt is an optional OIDC prompt. An empty string omits prompt.\n   *  If not specified, it defaults to select_account for backwards compatibility.\n   */\n  public Prompt: string = \"\";\n  // ClaimsToRoles specifies a dynamic mapping from claims to roles.\n  public ClaimsToRoles: Array<ClaimMapping> = new Array<ClaimMapping>();\n  // GoogleServiceAccountURI is a path to a google service account uri.\n  public GoogleServiceAccountURI: string = \"\";\n  // GoogleServiceAccount is a string containing google service account credentials.\n  public GoogleServiceAccount: string = \"\";\n  // GoogleAdminEmail is the email of a google admin to impersonate.\n  public GoogleAdminEmail: string = \"\";\n\n  // Decodes OIDCConnectorSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): OIDCConnectorSpecV3 {\n    return OIDCConnectorSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes OIDCConnectorSpecV3 from a DataView\n  static decodeDataView(view: DataView): OIDCConnectorSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new OIDCConnectorSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.IssuerURL = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.ClientID = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.ClientSecret = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.RedirectURL = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.ACR = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.Provider = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.Display = decoder.string();\n          break;\n        }\n        case 8: {\n          obj.Scope.push(decoder.string());\n          break;\n        }\n        case 9: {\n          obj.Prompt = decoder.string();\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.ClaimsToRoles.push(\n            ClaimMapping.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 11: {\n          obj.GoogleServiceAccountURI = decoder.string();\n          break;\n        }\n        case 12: {\n          obj.GoogleServiceAccount = decoder.string();\n          break;\n        }\n        case 13: {\n          obj.GoogleAdminEmail = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode OIDCConnectorSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.IssuerURL.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.IssuerURL.length) +\n          this.IssuerURL.length\n        : 0;\n    size +=\n      this.ClientID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClientID.length) +\n          this.ClientID.length\n        : 0;\n    size +=\n      this.ClientSecret.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClientSecret.length) +\n          this.ClientSecret.length\n        : 0;\n    size +=\n      this.RedirectURL.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RedirectURL.length) +\n          this.RedirectURL.length\n        : 0;\n    size +=\n      this.ACR.length > 0\n        ? 1 + __proto.Sizer.varint64(this.ACR.length) + this.ACR.length\n        : 0;\n    size +=\n      this.Provider.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Provider.length) +\n          this.Provider.length\n        : 0;\n    size +=\n      this.Display.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Display.length) + this.Display.length\n        : 0;\n\n    size += __size_string_repeated(this.Scope);\n\n    size +=\n      this.Prompt.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Prompt.length) + this.Prompt.length\n        : 0;\n\n    for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {\n      const messageSize = this.ClaimsToRoles[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.GoogleServiceAccountURI.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.GoogleServiceAccountURI.length) +\n          this.GoogleServiceAccountURI.length\n        : 0;\n    size +=\n      this.GoogleServiceAccount.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.GoogleServiceAccount.length) +\n          this.GoogleServiceAccount.length\n        : 0;\n    size +=\n      this.GoogleAdminEmail.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.GoogleAdminEmail.length) +\n          this.GoogleAdminEmail.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes OIDCConnectorSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes OIDCConnectorSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.IssuerURL.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.IssuerURL.length);\n      encoder.string(this.IssuerURL);\n    }\n    if (this.ClientID.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.ClientID.length);\n      encoder.string(this.ClientID);\n    }\n    if (this.ClientSecret.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.ClientSecret.length);\n      encoder.string(this.ClientSecret);\n    }\n    if (this.RedirectURL.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.RedirectURL.length);\n      encoder.string(this.RedirectURL);\n    }\n    if (this.ACR.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.ACR.length);\n      encoder.string(this.ACR);\n    }\n    if (this.Provider.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.Provider.length);\n      encoder.string(this.Provider);\n    }\n    if (this.Display.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.Display.length);\n      encoder.string(this.Display);\n    }\n\n    if (this.Scope.length > 0) {\n      for (let n: i32 = 0; n < this.Scope.length; n++) {\n        encoder.uint32(0x42);\n        encoder.uint32(this.Scope[n].length);\n        encoder.string(this.Scope[n]);\n      }\n    }\n\n    if (this.Prompt.length > 0) {\n      encoder.uint32(0x4a);\n      encoder.uint32(this.Prompt.length);\n      encoder.string(this.Prompt);\n    }\n\n    for (let n: i32 = 0; n < this.ClaimsToRoles.length; n++) {\n      const messageSize = this.ClaimsToRoles[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        this.ClaimsToRoles[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.GoogleServiceAccountURI.length > 0) {\n      encoder.uint32(0x5a);\n      encoder.uint32(this.GoogleServiceAccountURI.length);\n      encoder.string(this.GoogleServiceAccountURI);\n    }\n    if (this.GoogleServiceAccount.length > 0) {\n      encoder.uint32(0x62);\n      encoder.uint32(this.GoogleServiceAccount.length);\n      encoder.string(this.GoogleServiceAccount);\n    }\n    if (this.GoogleAdminEmail.length > 0) {\n      encoder.uint32(0x6a);\n      encoder.uint32(this.GoogleAdminEmail.length);\n      encoder.string(this.GoogleAdminEmail);\n    }\n\n    return buf;\n  } // encode OIDCConnectorSpecV3\n} // OIDCConnectorSpecV3\n\n// SAMLConnectorV2 represents a SAML connector.\nexport class SAMLConnectorV2 {\n  // Kind is a resource kind.\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources.\n  public SubKind: string = \"\";\n  // Version is a resource version.\n  public Version: string = \"\";\n  // Metadata holds resource metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is an SAML connector specification.\n  public Spec: SAMLConnectorSpecV2 = new SAMLConnectorSpecV2();\n\n  // Decodes SAMLConnectorV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SAMLConnectorV2 {\n    return SAMLConnectorV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SAMLConnectorV2 from a DataView\n  static decodeDataView(view: DataView): SAMLConnectorV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SAMLConnectorV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = SAMLConnectorSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SAMLConnectorV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: SAMLConnectorSpecV2 = this.Spec as SAMLConnectorSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SAMLConnectorV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SAMLConnectorV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as SAMLConnectorSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SAMLConnectorV2\n} // SAMLConnectorV2\n\n// SAMLConnectorV2List is a list of SAML connectors.\nexport class SAMLConnectorV2List {\n  // SAMLConnectors is a list of SAML connectors.\n  public SAMLConnectors: Array<SAMLConnectorV2> = new Array<SAMLConnectorV2>();\n\n  // Decodes SAMLConnectorV2List from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SAMLConnectorV2List {\n    return SAMLConnectorV2List.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SAMLConnectorV2List from a DataView\n  static decodeDataView(view: DataView): SAMLConnectorV2List {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SAMLConnectorV2List();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.SAMLConnectors.push(\n            SAMLConnectorV2.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SAMLConnectorV2List\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.SAMLConnectors.length; n++) {\n      const messageSize = this.SAMLConnectors[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SAMLConnectorV2List to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SAMLConnectorV2List to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.SAMLConnectors.length; n++) {\n      const messageSize = this.SAMLConnectors[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.SAMLConnectors[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SAMLConnectorV2List\n} // SAMLConnectorV2List\n\n// SAMLConnectorSpecV2 is a SAML connector specification.\nexport class SAMLConnectorSpecV2 {\n  // Issuer is the identity provider issuer.\n  public Issuer: string = \"\";\n  // SSO is the URL of the identity provider's SSO service.\n  public SSO: string = \"\";\n  /**\n   * Cert is the identity provider certificate PEM.\n   *  IDP signs <Response> responses using this certificate.\n   */\n  public Cert: string = \"\";\n  // Display controls how this connector is displayed.\n  public Display: string = \"\";\n  /**\n   * AssertionConsumerService is a URL for assertion consumer service\n   *  on the service provider (Teleport's side).\n   */\n  public AssertionConsumerService: string = \"\";\n  // Audience uniquely identifies our service provider.\n  public Audience: string = \"\";\n  // ServiceProviderIssuer is the issuer of the service provider (Teleport).\n  public ServiceProviderIssuer: string = \"\";\n  /**\n   * EntityDescriptor is XML with descriptor. It can be used to supply configuration\n   *  parameters in one XML file rather than supplying them in the individual elements.\n   */\n  public EntityDescriptor: string = \"\";\n  // EntityDescriptorURL is a URL that supplies a configuration XML.\n  public EntityDescriptorURL: string = \"\";\n  // AttributesToRoles is a list of mappings of attribute statements to roles.\n  public AttributesToRoles: Array<AttributeMapping> =\n    new Array<AttributeMapping>();\n  // SigningKeyPair is an x509 key pair used to sign AuthnRequest.\n  public SigningKeyPair: AsymmetricKeyPair = new AsymmetricKeyPair();\n  // Provider is the external identity provider.\n  public Provider: string = \"\";\n  // EncryptionKeyPair is a key pair used for decrypting SAML assertions.\n  public EncryptionKeyPair: AsymmetricKeyPair = new AsymmetricKeyPair();\n\n  // Decodes SAMLConnectorSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SAMLConnectorSpecV2 {\n    return SAMLConnectorSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SAMLConnectorSpecV2 from a DataView\n  static decodeDataView(view: DataView): SAMLConnectorSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SAMLConnectorSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Issuer = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SSO = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Cert = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.Display = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.AssertionConsumerService = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.Audience = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.ServiceProviderIssuer = decoder.string();\n          break;\n        }\n        case 8: {\n          obj.EntityDescriptor = decoder.string();\n          break;\n        }\n        case 9: {\n          obj.EntityDescriptorURL = decoder.string();\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.AttributesToRoles.push(\n            AttributeMapping.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 11: {\n          const length = decoder.uint32();\n          obj.SigningKeyPair = AsymmetricKeyPair.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 12: {\n          obj.Provider = decoder.string();\n          break;\n        }\n        case 13: {\n          const length = decoder.uint32();\n          obj.EncryptionKeyPair = AsymmetricKeyPair.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SAMLConnectorSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Issuer.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Issuer.length) + this.Issuer.length\n        : 0;\n    size +=\n      this.SSO.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SSO.length) + this.SSO.length\n        : 0;\n    size +=\n      this.Cert.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Cert.length) + this.Cert.length\n        : 0;\n    size +=\n      this.Display.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Display.length) + this.Display.length\n        : 0;\n    size +=\n      this.AssertionConsumerService.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.AssertionConsumerService.length) +\n          this.AssertionConsumerService.length\n        : 0;\n    size +=\n      this.Audience.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Audience.length) +\n          this.Audience.length\n        : 0;\n    size +=\n      this.ServiceProviderIssuer.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ServiceProviderIssuer.length) +\n          this.ServiceProviderIssuer.length\n        : 0;\n    size +=\n      this.EntityDescriptor.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.EntityDescriptor.length) +\n          this.EntityDescriptor.length\n        : 0;\n    size +=\n      this.EntityDescriptorURL.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.EntityDescriptorURL.length) +\n          this.EntityDescriptorURL.length\n        : 0;\n\n    for (let n: i32 = 0; n < this.AttributesToRoles.length; n++) {\n      const messageSize = this.AttributesToRoles[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SigningKeyPair != null) {\n      const f: AsymmetricKeyPair = this.SigningKeyPair as AsymmetricKeyPair;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Provider.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Provider.length) +\n          this.Provider.length\n        : 0;\n\n    if (this.EncryptionKeyPair != null) {\n      const f: AsymmetricKeyPair = this.EncryptionKeyPair as AsymmetricKeyPair;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SAMLConnectorSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SAMLConnectorSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Issuer.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Issuer.length);\n      encoder.string(this.Issuer);\n    }\n    if (this.SSO.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SSO.length);\n      encoder.string(this.SSO);\n    }\n    if (this.Cert.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Cert.length);\n      encoder.string(this.Cert);\n    }\n    if (this.Display.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.Display.length);\n      encoder.string(this.Display);\n    }\n    if (this.AssertionConsumerService.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.AssertionConsumerService.length);\n      encoder.string(this.AssertionConsumerService);\n    }\n    if (this.Audience.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.Audience.length);\n      encoder.string(this.Audience);\n    }\n    if (this.ServiceProviderIssuer.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.ServiceProviderIssuer.length);\n      encoder.string(this.ServiceProviderIssuer);\n    }\n    if (this.EntityDescriptor.length > 0) {\n      encoder.uint32(0x42);\n      encoder.uint32(this.EntityDescriptor.length);\n      encoder.string(this.EntityDescriptor);\n    }\n    if (this.EntityDescriptorURL.length > 0) {\n      encoder.uint32(0x4a);\n      encoder.uint32(this.EntityDescriptorURL.length);\n      encoder.string(this.EntityDescriptorURL);\n    }\n\n    for (let n: i32 = 0; n < this.AttributesToRoles.length; n++) {\n      const messageSize = this.AttributesToRoles[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        this.AttributesToRoles[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SigningKeyPair != null) {\n      const f = this.SigningKeyPair as AsymmetricKeyPair;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x5a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Provider.length > 0) {\n      encoder.uint32(0x62);\n      encoder.uint32(this.Provider.length);\n      encoder.string(this.Provider);\n    }\n\n    if (this.EncryptionKeyPair != null) {\n      const f = this.EncryptionKeyPair as AsymmetricKeyPair;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x6a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SAMLConnectorSpecV2\n} // SAMLConnectorSpecV2\n\n// AttributeMapping maps a SAML attribute statement to teleport roles.\nexport class AttributeMapping {\n  // Name is an attribute statement name.\n  public Name: string = \"\";\n  // Value is an attribute statement value to match.\n  public Value: string = \"\";\n  // Roles is a list of static teleport roles to map to.\n  public Roles: Array<string> = new Array<string>();\n\n  // Decodes AttributeMapping from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AttributeMapping {\n    return AttributeMapping.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AttributeMapping from a DataView\n  static decodeDataView(view: DataView): AttributeMapping {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AttributeMapping();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Value = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AttributeMapping\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.Value.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Value.length) + this.Value.length\n        : 0;\n\n    size += __size_string_repeated(this.Roles);\n\n    return size;\n  }\n\n  // Encodes AttributeMapping to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AttributeMapping to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.Value.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Value.length);\n      encoder.string(this.Value);\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x1a);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    return buf;\n  } // encode AttributeMapping\n} // AttributeMapping\n\n/**\n * AsymmetricKeyPair is a combination of a public certificate and\n *  private key that can be used for encryption and signing.\n */\nexport class AsymmetricKeyPair {\n  // PrivateKey is a PEM encoded x509 private key.\n  public PrivateKey: string = \"\";\n  // Cert is a PEM-encoded x509 certificate.\n  public Cert: string = \"\";\n\n  // Decodes AsymmetricKeyPair from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AsymmetricKeyPair {\n    return AsymmetricKeyPair.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AsymmetricKeyPair from a DataView\n  static decodeDataView(view: DataView): AsymmetricKeyPair {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AsymmetricKeyPair();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.PrivateKey = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Cert = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AsymmetricKeyPair\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.PrivateKey.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PrivateKey.length) +\n          this.PrivateKey.length\n        : 0;\n    size +=\n      this.Cert.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Cert.length) + this.Cert.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes AsymmetricKeyPair to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AsymmetricKeyPair to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.PrivateKey.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.PrivateKey.length);\n      encoder.string(this.PrivateKey);\n    }\n    if (this.Cert.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Cert.length);\n      encoder.string(this.Cert);\n    }\n\n    return buf;\n  } // encode AsymmetricKeyPair\n} // AsymmetricKeyPair\n\n// GithubConnectorV3 represents a Github connector.\nexport class GithubConnectorV3 {\n  // Kind is a resource kind.\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources.\n  public SubKind: string = \"\";\n  // Version is a resource version.\n  public Version: string = \"\";\n  // Metadata holds resource metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is an Github connector specification.\n  public Spec: GithubConnectorSpecV3 = new GithubConnectorSpecV3();\n\n  // Decodes GithubConnectorV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): GithubConnectorV3 {\n    return GithubConnectorV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes GithubConnectorV3 from a DataView\n  static decodeDataView(view: DataView): GithubConnectorV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new GithubConnectorV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = GithubConnectorSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode GithubConnectorV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: GithubConnectorSpecV3 = this.Spec as GithubConnectorSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes GithubConnectorV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes GithubConnectorV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as GithubConnectorSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode GithubConnectorV3\n} // GithubConnectorV3\n\n// GithubConnectorV3List is a list of Github connectors.\nexport class GithubConnectorV3List {\n  // GithubConnectors is a list of Github connectors.\n  public GithubConnectors: Array<GithubConnectorV3> =\n    new Array<GithubConnectorV3>();\n\n  // Decodes GithubConnectorV3List from an ArrayBuffer\n  static decode(buf: ArrayBuffer): GithubConnectorV3List {\n    return GithubConnectorV3List.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes GithubConnectorV3List from a DataView\n  static decodeDataView(view: DataView): GithubConnectorV3List {\n    const decoder = new __proto.Decoder(view);\n    const obj = new GithubConnectorV3List();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.GithubConnectors.push(\n            GithubConnectorV3.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode GithubConnectorV3List\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.GithubConnectors.length; n++) {\n      const messageSize = this.GithubConnectors[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes GithubConnectorV3List to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes GithubConnectorV3List to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.GithubConnectors.length; n++) {\n      const messageSize = this.GithubConnectors[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.GithubConnectors[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode GithubConnectorV3List\n} // GithubConnectorV3List\n\n// GithubConnectorSpecV3 is a Github connector specification.\nexport class GithubConnectorSpecV3 {\n  // ClientID is the Github OAuth app client ID.\n  public ClientID: string = \"\";\n  // ClientSecret is the Github OAuth app client secret.\n  public ClientSecret: string = \"\";\n  // RedirectURL is the authorization callback URL.\n  public RedirectURL: string = \"\";\n  // TeamsToLogins maps Github team memberships onto allowed logins/roles.\n  public TeamsToLogins: Array<TeamMapping> = new Array<TeamMapping>();\n  // Display is the connector display name.\n  public Display: string = \"\";\n\n  // Decodes GithubConnectorSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): GithubConnectorSpecV3 {\n    return GithubConnectorSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes GithubConnectorSpecV3 from a DataView\n  static decodeDataView(view: DataView): GithubConnectorSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new GithubConnectorSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ClientID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.ClientSecret = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.RedirectURL = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.TeamsToLogins.push(\n            TeamMapping.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.Display = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode GithubConnectorSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ClientID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClientID.length) +\n          this.ClientID.length\n        : 0;\n    size +=\n      this.ClientSecret.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClientSecret.length) +\n          this.ClientSecret.length\n        : 0;\n    size +=\n      this.RedirectURL.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RedirectURL.length) +\n          this.RedirectURL.length\n        : 0;\n\n    for (let n: i32 = 0; n < this.TeamsToLogins.length; n++) {\n      const messageSize = this.TeamsToLogins[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Display.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Display.length) + this.Display.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes GithubConnectorSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes GithubConnectorSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ClientID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.ClientID.length);\n      encoder.string(this.ClientID);\n    }\n    if (this.ClientSecret.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.ClientSecret.length);\n      encoder.string(this.ClientSecret);\n    }\n    if (this.RedirectURL.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.RedirectURL.length);\n      encoder.string(this.RedirectURL);\n    }\n\n    for (let n: i32 = 0; n < this.TeamsToLogins.length; n++) {\n      const messageSize = this.TeamsToLogins[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        this.TeamsToLogins[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Display.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.Display.length);\n      encoder.string(this.Display);\n    }\n\n    return buf;\n  } // encode GithubConnectorSpecV3\n} // GithubConnectorSpecV3\n\n// TeamMapping represents a single team membership mapping.\nexport class TeamMapping {\n  // Organization is a Github organization a user belongs to.\n  public Organization: string = \"\";\n  // Team is a team within the organization a user belongs to.\n  public Team: string = \"\";\n  // Logins is a list of allowed logins for this org/team.\n  public Logins: Array<string> = new Array<string>();\n  // KubeGroups is a list of allowed kubernetes groups for this org/team.\n  public KubeGroups: Array<string> = new Array<string>();\n  // KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.\n  public KubeUsers: Array<string> = new Array<string>();\n\n  // Decodes TeamMapping from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TeamMapping {\n    return TeamMapping.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TeamMapping from a DataView\n  static decodeDataView(view: DataView): TeamMapping {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TeamMapping();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Organization = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Team = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Logins.push(decoder.string());\n          break;\n        }\n        case 4: {\n          obj.KubeGroups.push(decoder.string());\n          break;\n        }\n        case 5: {\n          obj.KubeUsers.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TeamMapping\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Organization.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Organization.length) +\n          this.Organization.length\n        : 0;\n    size +=\n      this.Team.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Team.length) + this.Team.length\n        : 0;\n\n    size += __size_string_repeated(this.Logins);\n\n    size += __size_string_repeated(this.KubeGroups);\n\n    size += __size_string_repeated(this.KubeUsers);\n\n    return size;\n  }\n\n  // Encodes TeamMapping to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TeamMapping to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Organization.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Organization.length);\n      encoder.string(this.Organization);\n    }\n    if (this.Team.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Team.length);\n      encoder.string(this.Team);\n    }\n\n    if (this.Logins.length > 0) {\n      for (let n: i32 = 0; n < this.Logins.length; n++) {\n        encoder.uint32(0x1a);\n        encoder.uint32(this.Logins[n].length);\n        encoder.string(this.Logins[n]);\n      }\n    }\n\n    if (this.KubeGroups.length > 0) {\n      for (let n: i32 = 0; n < this.KubeGroups.length; n++) {\n        encoder.uint32(0x22);\n        encoder.uint32(this.KubeGroups[n].length);\n        encoder.string(this.KubeGroups[n]);\n      }\n    }\n\n    if (this.KubeUsers.length > 0) {\n      for (let n: i32 = 0; n < this.KubeUsers.length; n++) {\n        encoder.uint32(0x2a);\n        encoder.uint32(this.KubeUsers[n].length);\n        encoder.string(this.KubeUsers[n]);\n      }\n    }\n\n    return buf;\n  } // encode TeamMapping\n} // TeamMapping\n\n// TrustedClusterV2 represents a Trusted Cluster.\nexport class TrustedClusterV2 {\n  // Kind is a resource kind.\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources.\n  public SubKind: string = \"\";\n  // Version is a resource version.\n  public Version: string = \"\";\n  // Metadata holds resource metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is a Trusted Cluster specification.\n  public Spec: TrustedClusterSpecV2 = new TrustedClusterSpecV2();\n\n  // Decodes TrustedClusterV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TrustedClusterV2 {\n    return TrustedClusterV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TrustedClusterV2 from a DataView\n  static decodeDataView(view: DataView): TrustedClusterV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TrustedClusterV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = TrustedClusterSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TrustedClusterV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: TrustedClusterSpecV2 = this.Spec as TrustedClusterSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes TrustedClusterV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TrustedClusterV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as TrustedClusterSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode TrustedClusterV2\n} // TrustedClusterV2\n\n// TrustedClusterV2List is a list of trusted cluster.\nexport class TrustedClusterV2List {\n  // TrustedClusters is a list of trusted cluster.\n  public TrustedClusters: Array<TrustedClusterV2> =\n    new Array<TrustedClusterV2>();\n\n  // Decodes TrustedClusterV2List from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TrustedClusterV2List {\n    return TrustedClusterV2List.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TrustedClusterV2List from a DataView\n  static decodeDataView(view: DataView): TrustedClusterV2List {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TrustedClusterV2List();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.TrustedClusters.push(\n            TrustedClusterV2.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TrustedClusterV2List\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.TrustedClusters.length; n++) {\n      const messageSize = this.TrustedClusters[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes TrustedClusterV2List to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TrustedClusterV2List to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.TrustedClusters.length; n++) {\n      const messageSize = this.TrustedClusters[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.TrustedClusters[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode TrustedClusterV2List\n} // TrustedClusterV2List\n\n// TrustedClusterSpecV2 is a Trusted Cluster specification.\nexport class TrustedClusterSpecV2 {\n  /**\n   * Enabled is a bool that indicates if the TrustedCluster is enabled or disabled.\n   *  Setting Enabled to false has a side effect of deleting the user and host certificate\n   *  authority (CA).\n   */\n  public Enabled: bool;\n  // Roles is a list of roles that users will be assuming when connecting to this cluster.\n  public Roles: Array<string> = new Array<string>();\n  // Token is the authorization token provided by another cluster needed by this cluster to join.\n  public Token: string = \"\";\n  /**\n   * ProxyAddress is the address of the web proxy server of the cluster to join. If not set,\n   *  it is derived from <metadata.name>:<default web proxy server port>.\n   */\n  public ProxyAddress: string = \"\";\n  /**\n   * ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If\n   *  not set, it is derived from <metadata.name>:<default reverse tunnel port>.\n   */\n  public ReverseTunnelAddress: string = \"\";\n  // RoleMap specifies role mappings to remote roles.\n  public RoleMap: Array<RoleMapping> = new Array<RoleMapping>();\n\n  // Decodes TrustedClusterSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TrustedClusterSpecV2 {\n    return TrustedClusterSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TrustedClusterSpecV2 from a DataView\n  static decodeDataView(view: DataView): TrustedClusterSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TrustedClusterSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Enabled = decoder.bool();\n          break;\n        }\n        case 2: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.Token = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.ProxyAddress = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.ReverseTunnelAddress = decoder.string();\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.RoleMap.push(\n            RoleMapping.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TrustedClusterSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.Enabled == 0 ? 0 : 1 + 1;\n\n    size += __size_string_repeated(this.Roles);\n\n    size +=\n      this.Token.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Token.length) + this.Token.length\n        : 0;\n    size +=\n      this.ProxyAddress.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ProxyAddress.length) +\n          this.ProxyAddress.length\n        : 0;\n    size +=\n      this.ReverseTunnelAddress.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ReverseTunnelAddress.length) +\n          this.ReverseTunnelAddress.length\n        : 0;\n\n    for (let n: i32 = 0; n < this.RoleMap.length; n++) {\n      const messageSize = this.RoleMap[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes TrustedClusterSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TrustedClusterSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Enabled != 0) {\n      encoder.uint32(0x8);\n      encoder.bool(this.Enabled);\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    if (this.Token.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Token.length);\n      encoder.string(this.Token);\n    }\n    if (this.ProxyAddress.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.ProxyAddress.length);\n      encoder.string(this.ProxyAddress);\n    }\n    if (this.ReverseTunnelAddress.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.ReverseTunnelAddress.length);\n      encoder.string(this.ReverseTunnelAddress);\n    }\n\n    for (let n: i32 = 0; n < this.RoleMap.length; n++) {\n      const messageSize = this.RoleMap[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        this.RoleMap[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode TrustedClusterSpecV2\n} // TrustedClusterSpecV2\n\n/**\n * LockV2 represents a lock.\n *  Locks are used to restrict access to a Teleport environment by disabling\n *  interactions involving a user, an RBAC role, a node, etc.\n *  See rfd/0009-locking.md for more details.\n */\nexport class LockV2 {\n  // Kind is a resource kind.\n  public Kind: string = \"\";\n  // SubKind is an optional resource sub kind, used in some resources.\n  public SubKind: string = \"\";\n  // Version is a resource version.\n  public Version: string = \"\";\n  // Metadata holds resource metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is a Lock specification.\n  public Spec: LockSpecV2 = new LockSpecV2();\n\n  // Decodes LockV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): LockV2 {\n    return LockV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes LockV2 from a DataView\n  static decodeDataView(view: DataView): LockV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new LockV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = LockSpecV2.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode LockV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: LockSpecV2 = this.Spec as LockSpecV2;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes LockV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes LockV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as LockSpecV2;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode LockV2\n} // LockV2\n\n// LockSpecV2 is a Lock specification.\nexport class LockSpecV2 {\n  // Target describes the set of interactions that the lock applies to.\n  public Target: LockTarget = new LockTarget();\n  // Message is the message displayed to locked-out users.\n  public Message: string = \"\";\n  // Expires if set specifies when the lock ceases to be in force.\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n\n  // Decodes LockSpecV2 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): LockSpecV2 {\n    return LockSpecV2.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes LockSpecV2 from a DataView\n  static decodeDataView(view: DataView): LockSpecV2 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new LockSpecV2();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Target = LockTarget.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          obj.Message = decoder.string();\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode LockSpecV2\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Target != null) {\n      const f: LockTarget = this.Target as LockTarget;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Message.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Message.length) + this.Message.length\n        : 0;\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes LockSpecV2 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes LockSpecV2 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Target != null) {\n      const f = this.Target as LockTarget;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Message.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Message.length);\n      encoder.string(this.Message);\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode LockSpecV2\n} // LockSpecV2\n\n// LockTarget lists the attributes of interactions to be disabled.\nexport class LockTarget {\n  // User specifies the name of a Teleport user.\n  public User: string = \"\";\n  /**\n   * Role specifies the name of an RBAC role known to the root cluster.\n   *  In remote clusters, this constraint is evaluated before translating to local roles.\n   */\n  public Role: string = \"\";\n  // Login specifies the name of a local UNIX user.\n  public Login: string = \"\";\n  /**\n   * Node specifies the UUID of a Teleport node.\n   *  A matching node is also prevented from heartbeating to the auth server.\n   */\n  public Node: string = \"\";\n  // MFADevice specifies the UUID of a user MFA device.\n  public MFADevice: string = \"\";\n  // WindowsDesktop specifies the name of a Windows desktop.\n  public WindowsDesktop: string = \"\";\n  // AccessRequest specifies the UUID of an access request.\n  public AccessRequest: string = \"\";\n\n  // Decodes LockTarget from an ArrayBuffer\n  static decode(buf: ArrayBuffer): LockTarget {\n    return LockTarget.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes LockTarget from a DataView\n  static decodeDataView(view: DataView): LockTarget {\n    const decoder = new __proto.Decoder(view);\n    const obj = new LockTarget();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Role = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Login = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.Node = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.MFADevice = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.WindowsDesktop = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.AccessRequest = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode LockTarget\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size +=\n      this.Role.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Role.length) + this.Role.length\n        : 0;\n    size +=\n      this.Login.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Login.length) + this.Login.length\n        : 0;\n    size +=\n      this.Node.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Node.length) + this.Node.length\n        : 0;\n    size +=\n      this.MFADevice.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.MFADevice.length) +\n          this.MFADevice.length\n        : 0;\n    size +=\n      this.WindowsDesktop.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.WindowsDesktop.length) +\n          this.WindowsDesktop.length\n        : 0;\n    size +=\n      this.AccessRequest.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.AccessRequest.length) +\n          this.AccessRequest.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes LockTarget to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes LockTarget to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.Role.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Role.length);\n      encoder.string(this.Role);\n    }\n    if (this.Login.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Login.length);\n      encoder.string(this.Login);\n    }\n    if (this.Node.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.Node.length);\n      encoder.string(this.Node);\n    }\n    if (this.MFADevice.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.MFADevice.length);\n      encoder.string(this.MFADevice);\n    }\n    if (this.WindowsDesktop.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.WindowsDesktop.length);\n      encoder.string(this.WindowsDesktop);\n    }\n    if (this.AccessRequest.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.AccessRequest.length);\n      encoder.string(this.AccessRequest);\n    }\n\n    return buf;\n  } // encode LockTarget\n} // LockTarget\n\n/**\n * AddressCondition represents a set of addresses. Presently the addresses are specfied\n *  exclusively in terms of IPv4/IPv6 ranges.\n */\nexport class AddressCondition {\n  /**\n   * CIDR is IPv4 or IPv6 address. Valid value are either CIDR ranges (e.g. \"10.0.1.0/24\",\n   *  \"fe::/8\") or a single IP address (e.g \"10.1.2.3\")\n   */\n  public CIDR: string = \"\";\n\n  // Decodes AddressCondition from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AddressCondition {\n    return AddressCondition.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AddressCondition from a DataView\n  static decodeDataView(view: DataView): AddressCondition {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AddressCondition();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.CIDR = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AddressCondition\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.CIDR.length > 0\n        ? 1 + __proto.Sizer.varint64(this.CIDR.length) + this.CIDR.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes AddressCondition to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AddressCondition to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.CIDR.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.CIDR.length);\n      encoder.string(this.CIDR);\n    }\n\n    return buf;\n  } // encode AddressCondition\n} // AddressCondition\n\nexport class NetworkRestrictionsSpecV4 {\n  // Allow lists the addresses that should be allowed.\n  public Allow: Array<AddressCondition> = new Array<AddressCondition>();\n  // Deny lists the addresses that should be denied even if they're allowed by Allow condition.\n  public Deny: Array<AddressCondition> = new Array<AddressCondition>();\n\n  // Decodes NetworkRestrictionsSpecV4 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): NetworkRestrictionsSpecV4 {\n    return NetworkRestrictionsSpecV4.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes NetworkRestrictionsSpecV4 from a DataView\n  static decodeDataView(view: DataView): NetworkRestrictionsSpecV4 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new NetworkRestrictionsSpecV4();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Allow.push(\n            AddressCondition.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Deny.push(\n            AddressCondition.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode NetworkRestrictionsSpecV4\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.Allow.length; n++) {\n      const messageSize = this.Allow[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Deny.length; n++) {\n      const messageSize = this.Deny[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes NetworkRestrictionsSpecV4 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes NetworkRestrictionsSpecV4 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.Allow.length; n++) {\n      const messageSize = this.Allow[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.Allow[n].encodeU8Array(encoder);\n      }\n    }\n\n    for (let n: i32 = 0; n < this.Deny.length; n++) {\n      const messageSize = this.Deny[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        this.Deny[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode NetworkRestrictionsSpecV4\n} // NetworkRestrictionsSpecV4\n\n/**\n * NetworkRestrictions specifies a list of addresses to restrict (block). The deny\n *  list is checked first and the allow lists overrides it. Thus an empty allow\n *  list does not mean that no addresses will be allowed, that will only be the\n *  case if the deny list covers the whole address range.\n */\nexport class NetworkRestrictionsV4 {\n  // Kind is the network restrictions resource kind.\n  public Kind: string = \"\";\n  // SubKind is an optional resource subkind.\n  public SubKind: string = \"\";\n  // Version is the resource version.\n  public Version: string = \"\";\n  // Metadata is the network restrictions metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec contains the network restrictions data\n  public Spec: NetworkRestrictionsSpecV4 = new NetworkRestrictionsSpecV4();\n\n  // Decodes NetworkRestrictionsV4 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): NetworkRestrictionsV4 {\n    return NetworkRestrictionsV4.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes NetworkRestrictionsV4 from a DataView\n  static decodeDataView(view: DataView): NetworkRestrictionsV4 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new NetworkRestrictionsV4();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = NetworkRestrictionsSpecV4.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode NetworkRestrictionsV4\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: NetworkRestrictionsSpecV4 = this\n        .Spec as NetworkRestrictionsSpecV4;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes NetworkRestrictionsV4 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes NetworkRestrictionsV4 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as NetworkRestrictionsSpecV4;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode NetworkRestrictionsV4\n} // NetworkRestrictionsV4\n\n// WindowsDesktopServiceV3 represents a windows desktop access service.\nexport class WindowsDesktopServiceV3 {\n  // Header is the common resource header.\n  public Header: ResourceHeader = new ResourceHeader();\n  // Spec is the windows desktop service spec.\n  public Spec: WindowsDesktopServiceSpecV3 = new WindowsDesktopServiceSpecV3();\n\n  // Decodes WindowsDesktopServiceV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WindowsDesktopServiceV3 {\n    return WindowsDesktopServiceV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WindowsDesktopServiceV3 from a DataView\n  static decodeDataView(view: DataView): WindowsDesktopServiceV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WindowsDesktopServiceV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Header = ResourceHeader.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Spec = WindowsDesktopServiceSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WindowsDesktopServiceV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Header != null) {\n      const f: ResourceHeader = this.Header as ResourceHeader;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: WindowsDesktopServiceSpecV3 = this\n        .Spec as WindowsDesktopServiceSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes WindowsDesktopServiceV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WindowsDesktopServiceV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Header != null) {\n      const f = this.Header as ResourceHeader;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as WindowsDesktopServiceSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode WindowsDesktopServiceV3\n} // WindowsDesktopServiceV3\n\n// WindowsDesktopServiceSpecV3 is the windows desktop service spec.\nexport class WindowsDesktopServiceSpecV3 {\n  // Addr is the address that this service can be reached at.\n  public Addr: string = \"\";\n  // TeleportVersion is teleport binary version running this service.\n  public TeleportVersion: string = \"\";\n  // Hostname is the desktop service hostname.\n  public Hostname: string = \"\";\n\n  // Decodes WindowsDesktopServiceSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WindowsDesktopServiceSpecV3 {\n    return WindowsDesktopServiceSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WindowsDesktopServiceSpecV3 from a DataView\n  static decodeDataView(view: DataView): WindowsDesktopServiceSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WindowsDesktopServiceSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Addr = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.TeleportVersion = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Hostname = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WindowsDesktopServiceSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Addr.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Addr.length) + this.Addr.length\n        : 0;\n    size +=\n      this.TeleportVersion.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.TeleportVersion.length) +\n          this.TeleportVersion.length\n        : 0;\n    size +=\n      this.Hostname.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Hostname.length) +\n          this.Hostname.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes WindowsDesktopServiceSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WindowsDesktopServiceSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Addr.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Addr.length);\n      encoder.string(this.Addr);\n    }\n    if (this.TeleportVersion.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.TeleportVersion.length);\n      encoder.string(this.TeleportVersion);\n    }\n    if (this.Hostname.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Hostname.length);\n      encoder.string(this.Hostname);\n    }\n\n    return buf;\n  } // encode WindowsDesktopServiceSpecV3\n} // WindowsDesktopServiceSpecV3\n\n// WindowsDesktopFilter are filters to apply when searching for windows desktops.\nexport class WindowsDesktopFilter {\n  // HostID is the ID of the host the Windows Desktop Service proxying the desktop.\n  public HostID: string = \"\";\n  // Name is the name of the desktop.\n  public Name: string = \"\";\n\n  // Decodes WindowsDesktopFilter from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WindowsDesktopFilter {\n    return WindowsDesktopFilter.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WindowsDesktopFilter from a DataView\n  static decodeDataView(view: DataView): WindowsDesktopFilter {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WindowsDesktopFilter();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.HostID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Name = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WindowsDesktopFilter\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.HostID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.HostID.length) + this.HostID.length\n        : 0;\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes WindowsDesktopFilter to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WindowsDesktopFilter to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.HostID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.HostID.length);\n      encoder.string(this.HostID);\n    }\n    if (this.Name.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n\n    return buf;\n  } // encode WindowsDesktopFilter\n} // WindowsDesktopFilter\n\n// WindowsDesktopV3 represents a Windows host for desktop access.\nexport class WindowsDesktopV3 {\n  // Header is the common resource header.\n  public Header: ResourceHeader = new ResourceHeader();\n  // Spec is the Windows host spec.\n  public Spec: WindowsDesktopSpecV3 = new WindowsDesktopSpecV3();\n\n  // Decodes WindowsDesktopV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WindowsDesktopV3 {\n    return WindowsDesktopV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WindowsDesktopV3 from a DataView\n  static decodeDataView(view: DataView): WindowsDesktopV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WindowsDesktopV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Header = ResourceHeader.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Spec = WindowsDesktopSpecV3.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WindowsDesktopV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Header != null) {\n      const f: ResourceHeader = this.Header as ResourceHeader;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: WindowsDesktopSpecV3 = this.Spec as WindowsDesktopSpecV3;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes WindowsDesktopV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WindowsDesktopV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Header != null) {\n      const f = this.Header as ResourceHeader;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as WindowsDesktopSpecV3;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode WindowsDesktopV3\n} // WindowsDesktopV3\n\n// WindowsDesktopSpecV3 is the Windows host spec.\nexport class WindowsDesktopSpecV3 {\n  // Addr is the address that this host can be reached at.\n  public Addr: string = \"\";\n  // Domain is the ActiveDirectory domain that this host belongs to.\n  public Domain: string = \"\";\n  // HostID is the ID of the host the Windows Desktop Service proxying the desktop.\n  public HostID: string = \"\";\n\n  // Decodes WindowsDesktopSpecV3 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WindowsDesktopSpecV3 {\n    return WindowsDesktopSpecV3.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WindowsDesktopSpecV3 from a DataView\n  static decodeDataView(view: DataView): WindowsDesktopSpecV3 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WindowsDesktopSpecV3();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Addr = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Domain = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.HostID = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WindowsDesktopSpecV3\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Addr.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Addr.length) + this.Addr.length\n        : 0;\n    size +=\n      this.Domain.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Domain.length) + this.Domain.length\n        : 0;\n    size +=\n      this.HostID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.HostID.length) + this.HostID.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes WindowsDesktopSpecV3 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WindowsDesktopSpecV3 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Addr.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Addr.length);\n      encoder.string(this.Addr);\n    }\n    if (this.Domain.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Domain.length);\n      encoder.string(this.Domain);\n    }\n    if (this.HostID.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.HostID.length);\n      encoder.string(this.HostID);\n    }\n\n    return buf;\n  } // encode WindowsDesktopSpecV3\n} // WindowsDesktopSpecV3\n\n/**\n * RegisterUsingTokenRequest is a request to register with the auth server using\n *  an authentication token\n */\nexport class RegisterUsingTokenRequest {\n  // HostID is a unique host ID, usually a UUID\n  public HostID: string = \"\";\n  // NodeName is a node name\n  public NodeName: string = \"\";\n  // Role is a system role, e.g. Proxy\n  public Role: string = \"\";\n  // Token is the name of an authentication token\n  public Token: string = \"\";\n  // AdditionalPrincipals is a list of additional principals\n  public AdditionalPrincipals: Array<string> = new Array<string>();\n  // DNSNames is a list of DNS names to include in the x509 client certificate\n  public DNSNames: Array<string> = new Array<string>();\n  /**\n   * PublicTLSKey is a PEM encoded public key\n   *  used for TLS setup\n   */\n  public PublicTLSKey: Array<u8> = new Array<u8>();\n  /**\n   * PublicSSHKey is a SSH encoded public key,\n   *  if present will be signed as a return value\n   *  otherwise, new public/private key pair will be generated\n   */\n  public PublicSSHKey: Array<u8> = new Array<u8>();\n  /**\n   * RemoteAddr is the remote address of the host requesting a host certificate.\n   *  It is used to replace 0.0.0.0 in the list of additional principals.\n   */\n  public RemoteAddr: string = \"\";\n  /**\n   * EC2IdentityDocument is used for the EC2 join method to prove the identity\n   *  of a joining EC2 instance.\n   */\n  public EC2IdentityDocument: Array<u8> = new Array<u8>();\n\n  // Decodes RegisterUsingTokenRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RegisterUsingTokenRequest {\n    return RegisterUsingTokenRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RegisterUsingTokenRequest from a DataView\n  static decodeDataView(view: DataView): RegisterUsingTokenRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RegisterUsingTokenRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.HostID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.NodeName = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Role = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.Token = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.AdditionalPrincipals.push(decoder.string());\n          break;\n        }\n        case 6: {\n          obj.DNSNames.push(decoder.string());\n          break;\n        }\n        case 7: {\n          obj.PublicTLSKey = decoder.bytes();\n          break;\n        }\n        case 8: {\n          obj.PublicSSHKey = decoder.bytes();\n          break;\n        }\n        case 9: {\n          obj.RemoteAddr = decoder.string();\n          break;\n        }\n        case 10: {\n          obj.EC2IdentityDocument = decoder.bytes();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RegisterUsingTokenRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.HostID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.HostID.length) + this.HostID.length\n        : 0;\n    size +=\n      this.NodeName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.NodeName.length) +\n          this.NodeName.length\n        : 0;\n    size +=\n      this.Role.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Role.length) + this.Role.length\n        : 0;\n    size +=\n      this.Token.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Token.length) + this.Token.length\n        : 0;\n\n    size += __size_string_repeated(this.AdditionalPrincipals);\n\n    size += __size_string_repeated(this.DNSNames);\n\n    size +=\n      this.PublicTLSKey.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PublicTLSKey.length) +\n          this.PublicTLSKey.length\n        : 0;\n    size +=\n      this.PublicSSHKey.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PublicSSHKey.length) +\n          this.PublicSSHKey.length\n        : 0;\n    size +=\n      this.RemoteAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RemoteAddr.length) +\n          this.RemoteAddr.length\n        : 0;\n    size +=\n      this.EC2IdentityDocument.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.EC2IdentityDocument.length) +\n          this.EC2IdentityDocument.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes RegisterUsingTokenRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RegisterUsingTokenRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.HostID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.HostID.length);\n      encoder.string(this.HostID);\n    }\n    if (this.NodeName.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.NodeName.length);\n      encoder.string(this.NodeName);\n    }\n    if (this.Role.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Role.length);\n      encoder.string(this.Role);\n    }\n    if (this.Token.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.Token.length);\n      encoder.string(this.Token);\n    }\n\n    if (this.AdditionalPrincipals.length > 0) {\n      for (let n: i32 = 0; n < this.AdditionalPrincipals.length; n++) {\n        encoder.uint32(0x2a);\n        encoder.uint32(this.AdditionalPrincipals[n].length);\n        encoder.string(this.AdditionalPrincipals[n]);\n      }\n    }\n\n    if (this.DNSNames.length > 0) {\n      for (let n: i32 = 0; n < this.DNSNames.length; n++) {\n        encoder.uint32(0x32);\n        encoder.uint32(this.DNSNames[n].length);\n        encoder.string(this.DNSNames[n]);\n      }\n    }\n\n    if (this.PublicTLSKey.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.PublicTLSKey.length);\n      encoder.bytes(this.PublicTLSKey);\n    }\n    if (this.PublicSSHKey.length > 0) {\n      encoder.uint32(0x42);\n      encoder.uint32(this.PublicSSHKey.length);\n      encoder.bytes(this.PublicSSHKey);\n    }\n    if (this.RemoteAddr.length > 0) {\n      encoder.uint32(0x4a);\n      encoder.uint32(this.RemoteAddr.length);\n      encoder.string(this.RemoteAddr);\n    }\n    if (this.EC2IdentityDocument.length > 0) {\n      encoder.uint32(0x52);\n      encoder.uint32(this.EC2IdentityDocument.length);\n      encoder.bytes(this.EC2IdentityDocument);\n    }\n\n    return buf;\n  } // encode RegisterUsingTokenRequest\n} // RegisterUsingTokenRequest\n\n/**\n * RecoveryCodes holds a user's recovery code information. Recovery codes allows users to regain\n *  access to their account by restoring their lost password or second factor. Once a recovery code\n *  is successfully verified, the code is mark used (which invalidates it), and lets the user begin\n *  the recovery flow. When a user successfully finishes the recovery flow, users will get a new set\n *  of codes that will replace all the previous ones.\n */\nexport class RecoveryCodesV1 {\n  // Kind is the resource kind.\n  public Kind: string = \"\";\n  // SubKind is an optional resource subkind. Currently unused for this resource.\n  public SubKind: string = \"\";\n  // Version is the resource version.\n  public Version: string = \"\";\n  // Metadata is the resource metadata.\n  public Metadata: Metadata = new Metadata();\n  // Spec is the resource spec.\n  public Spec: RecoveryCodesSpecV1 = new RecoveryCodesSpecV1();\n\n  // Decodes RecoveryCodesV1 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RecoveryCodesV1 {\n    return RecoveryCodesV1.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RecoveryCodesV1 from a DataView\n  static decodeDataView(view: DataView): RecoveryCodesV1 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RecoveryCodesV1();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SubKind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Spec = RecoveryCodesSpecV1.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RecoveryCodesV1\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size +=\n      this.SubKind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SubKind.length) + this.SubKind.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: RecoveryCodesSpecV1 = this.Spec as RecoveryCodesSpecV1;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RecoveryCodesV1 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RecoveryCodesV1 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Kind.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.SubKind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SubKind.length);\n      encoder.string(this.SubKind);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as RecoveryCodesSpecV1;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RecoveryCodesV1\n} // RecoveryCodesV1\n\n// RecoveryCodesSpecV1 is the recovery codes spec.\nexport class RecoveryCodesSpecV1 {\n  // Codes hold a list of numOfRecoveryCodes.\n  public Codes: Array<RecoveryCode> = new Array<RecoveryCode>();\n  /**\n   * Created is when the set of recovery codes were generated. Updated when a new set of recovery\n   *  codes are inserted.\n   */\n  public Created: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n\n  // Decodes RecoveryCodesSpecV1 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RecoveryCodesSpecV1 {\n    return RecoveryCodesSpecV1.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RecoveryCodesSpecV1 from a DataView\n  static decodeDataView(view: DataView): RecoveryCodesSpecV1 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RecoveryCodesSpecV1();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Codes.push(\n            RecoveryCode.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Created = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RecoveryCodesSpecV1\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    for (let n: i32 = 0; n < this.Codes.length; n++) {\n      const messageSize = this.Codes[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Created != null) {\n      const f: google.protobuf.Timestamp = this\n        .Created as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RecoveryCodesSpecV1 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RecoveryCodesSpecV1 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    for (let n: i32 = 0; n < this.Codes.length; n++) {\n      const messageSize = this.Codes[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        this.Codes[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Created != null) {\n      const f = this.Created as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RecoveryCodesSpecV1\n} // RecoveryCodesSpecV1\n\n// RecoveryCode describes a recovery code.\nexport class RecoveryCode {\n  // HashedCode is a bcrypt hash of this recovery code.\n  public HashedCode: Array<u8> = new Array<u8>();\n  // IsUsed determines if this recovery code was used.\n  public IsUsed: bool;\n\n  // Decodes RecoveryCode from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RecoveryCode {\n    return RecoveryCode.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RecoveryCode from a DataView\n  static decodeDataView(view: DataView): RecoveryCode {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RecoveryCode();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.HashedCode = decoder.bytes();\n          break;\n        }\n        case 2: {\n          obj.IsUsed = decoder.bool();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RecoveryCode\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.HashedCode.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.HashedCode.length) +\n          this.HashedCode.length\n        : 0;\n    size += this.IsUsed == 0 ? 0 : 1 + 1;\n\n    return size;\n  }\n\n  // Encodes RecoveryCode to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RecoveryCode to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.HashedCode.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.HashedCode.length);\n      encoder.bytes(this.HashedCode);\n    }\n    if (this.IsUsed != 0) {\n      encoder.uint32(0x10);\n      encoder.bool(this.IsUsed);\n    }\n\n    return buf;\n  } // encode RecoveryCode\n} // RecoveryCode\n\n// SessionTrackerV1 represents a live session resource.\nexport class SessionTrackerV1 {\n  // Header is the common resource header.\n  public Header: ResourceHeader = new ResourceHeader();\n  // Spec is a session specification.\n  public Spec: SessionTrackerSpecV1 = new SessionTrackerSpecV1();\n\n  // Decodes SessionTrackerV1 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionTrackerV1 {\n    return SessionTrackerV1.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionTrackerV1 from a DataView\n  static decodeDataView(view: DataView): SessionTrackerV1 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionTrackerV1();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Header = ResourceHeader.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Spec = SessionTrackerSpecV1.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionTrackerV1\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Header != null) {\n      const f: ResourceHeader = this.Header as ResourceHeader;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Spec != null) {\n      const f: SessionTrackerSpecV1 = this.Spec as SessionTrackerSpecV1;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SessionTrackerV1 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionTrackerV1 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Header != null) {\n      const f = this.Header as ResourceHeader;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Spec != null) {\n      const f = this.Spec as SessionTrackerSpecV1;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SessionTrackerV1\n} // SessionTrackerV1\n\n// SessionTrackerSpecV1 is the specification for a live session.\nexport class SessionTrackerSpecV1 {\n  // SessionID is unique identifier of this session.\n  public SessionID: string = \"\";\n  // Kind describes what kind of session this is.\n  public Kind: string = \"\";\n  // State is the current state of this session.\n  public State: u32;\n  /**\n   * Created encodes the time at which the session was registered with the auth\n   *  server.\n   *\n   *  This should match the timestamp in the corresponding `session.create` event.\n   *  It's thus up to the tracker creator to set the correct timestamp.\n   */\n  public Created: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // Expires encodes the time at which this session expires and becomes invalid.\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // AttachedData is arbitrary attached JSON serialized metadata.\n  public AttachedData: string = \"\";\n  /**\n   * Reason is an arbitrary string that may be used to describe the session and/or it's\n   *  purpose.\n   */\n  public Reason: string = \"\";\n  /**\n   * Invited is a list of invited users, this field is interpreted by different\n   *  clients on a best-effort basis and used for delivering notifications to invited users.\n   */\n  public Invited: Array<string> = new Array<string>();\n  // Hostname identifies the target this session is connected to.\n  public Hostname: string = \"\";\n  // Address is the address of the target this session is connected to.\n  public Address: string = \"\";\n  // ClusterName is the name of the Teleport cluster that this session belongs to.\n  public ClusterName: string = \"\";\n  // Login is the local login/user on the target used by the session.\n  public Login: string = \"\";\n  // Participants is a list of session participants.\n  public Participants: Array<Participant> = new Array<Participant>();\n  // The Kubernetes cluster this session belongs to.\n  public KubernetesCluster: string = \"\";\n  /**\n   * HostUser is the user regarded as the owner of this session, RBAC checks are performed\n   *  against the require policies of this user.\n   *\n   *  This refers to the Teleport user but may not be the same as the sessions initiator.\n   */\n  public HostUser: string = \"\";\n  /**\n   * HostPolicies is a list of RBAC policy sets held by the host user at the time of session\n   *  creation.\n   */\n  public HostPolicies: Array<SessionTrackerPolicySet> =\n    new Array<SessionTrackerPolicySet>();\n\n  // Decodes SessionTrackerSpecV1 from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionTrackerSpecV1 {\n    return SessionTrackerSpecV1.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionTrackerSpecV1 from a DataView\n  static decodeDataView(view: DataView): SessionTrackerSpecV1 {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionTrackerSpecV1();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.SessionID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Kind = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.State = decoder.uint32();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Created = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.AttachedData = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.Reason = decoder.string();\n          break;\n        }\n        case 8: {\n          obj.Invited.push(decoder.string());\n          break;\n        }\n        case 9: {\n          obj.Hostname = decoder.string();\n          break;\n        }\n        case 10: {\n          obj.Address = decoder.string();\n          break;\n        }\n        case 11: {\n          obj.ClusterName = decoder.string();\n          break;\n        }\n        case 12: {\n          obj.Login = decoder.string();\n          break;\n        }\n        case 13: {\n          const length = decoder.uint32();\n          obj.Participants.push(\n            Participant.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 14: {\n          obj.KubernetesCluster = decoder.string();\n          break;\n        }\n        case 15: {\n          obj.HostUser = decoder.string();\n          break;\n        }\n        case 16: {\n          const length = decoder.uint32();\n          obj.HostPolicies.push(\n            SessionTrackerPolicySet.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionTrackerSpecV1\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.SessionID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SessionID.length) +\n          this.SessionID.length\n        : 0;\n    size +=\n      this.Kind.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Kind.length) + this.Kind.length\n        : 0;\n    size += this.State == 0 ? 0 : 1 + __proto.Sizer.uint32(this.State);\n\n    if (this.Created != null) {\n      const f: google.protobuf.Timestamp = this\n        .Created as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.AttachedData.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.AttachedData.length) +\n          this.AttachedData.length\n        : 0;\n    size +=\n      this.Reason.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Reason.length) + this.Reason.length\n        : 0;\n\n    size += __size_string_repeated(this.Invited);\n\n    size +=\n      this.Hostname.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Hostname.length) +\n          this.Hostname.length\n        : 0;\n    size +=\n      this.Address.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Address.length) + this.Address.length\n        : 0;\n    size +=\n      this.ClusterName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClusterName.length) +\n          this.ClusterName.length\n        : 0;\n    size +=\n      this.Login.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Login.length) + this.Login.length\n        : 0;\n\n    for (let n: i32 = 0; n < this.Participants.length; n++) {\n      const messageSize = this.Participants[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.KubernetesCluster.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.KubernetesCluster.length) +\n          this.KubernetesCluster.length\n        : 0;\n    size +=\n      this.HostUser.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.HostUser.length) +\n          this.HostUser.length\n        : 0;\n\n    for (let n: i32 = 0; n < this.HostPolicies.length; n++) {\n      const messageSize = this.HostPolicies[n].size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SessionTrackerSpecV1 to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionTrackerSpecV1 to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.SessionID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.SessionID.length);\n      encoder.string(this.SessionID);\n    }\n    if (this.Kind.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Kind.length);\n      encoder.string(this.Kind);\n    }\n    if (this.State != 0) {\n      encoder.uint32(0x18);\n      encoder.uint32(this.State);\n    }\n\n    if (this.Created != null) {\n      const f = this.Created as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AttachedData.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.AttachedData.length);\n      encoder.string(this.AttachedData);\n    }\n    if (this.Reason.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.Reason.length);\n      encoder.string(this.Reason);\n    }\n\n    if (this.Invited.length > 0) {\n      for (let n: i32 = 0; n < this.Invited.length; n++) {\n        encoder.uint32(0x42);\n        encoder.uint32(this.Invited[n].length);\n        encoder.string(this.Invited[n]);\n      }\n    }\n\n    if (this.Hostname.length > 0) {\n      encoder.uint32(0x4a);\n      encoder.uint32(this.Hostname.length);\n      encoder.string(this.Hostname);\n    }\n    if (this.Address.length > 0) {\n      encoder.uint32(0x52);\n      encoder.uint32(this.Address.length);\n      encoder.string(this.Address);\n    }\n    if (this.ClusterName.length > 0) {\n      encoder.uint32(0x5a);\n      encoder.uint32(this.ClusterName.length);\n      encoder.string(this.ClusterName);\n    }\n    if (this.Login.length > 0) {\n      encoder.uint32(0x62);\n      encoder.uint32(this.Login.length);\n      encoder.string(this.Login);\n    }\n\n    for (let n: i32 = 0; n < this.Participants.length; n++) {\n      const messageSize = this.Participants[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x6a);\n        encoder.uint32(messageSize);\n        this.Participants[n].encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubernetesCluster.length > 0) {\n      encoder.uint32(0x72);\n      encoder.uint32(this.KubernetesCluster.length);\n      encoder.string(this.KubernetesCluster);\n    }\n    if (this.HostUser.length > 0) {\n      encoder.uint32(0x7a);\n      encoder.uint32(this.HostUser.length);\n      encoder.string(this.HostUser);\n    }\n\n    for (let n: i32 = 0; n < this.HostPolicies.length; n++) {\n      const messageSize = this.HostPolicies[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x82);\n        encoder.uint32(messageSize);\n        this.HostPolicies[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SessionTrackerSpecV1\n} // SessionTrackerSpecV1\n\n/**\n * SessionTrackerPolicySet is a set of RBAC policies held by the session tracker\n *  that contain additional metadata from the originating role.\n */\nexport class SessionTrackerPolicySet {\n  // Name is name of the role this policy set originates from.\n  public Name: string = \"\";\n  // Version is version of the role this policy set originates from.\n  public Version: string = \"\";\n  // RequireSessionJoin specifies policies for required users to start a session.\n  public RequireSessionJoin: Array<SessionRequirePolicy> =\n    new Array<SessionRequirePolicy>();\n\n  // Decodes SessionTrackerPolicySet from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionTrackerPolicySet {\n    return SessionTrackerPolicySet.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionTrackerPolicySet from a DataView\n  static decodeDataView(view: DataView): SessionTrackerPolicySet {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionTrackerPolicySet();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Version = decoder.string();\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.RequireSessionJoin.push(\n            SessionRequirePolicy.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionTrackerPolicySet\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.Version.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Version.length) + this.Version.length\n        : 0;\n\n    for (let n: i32 = 0; n < this.RequireSessionJoin.length; n++) {\n      const messageSize = this.RequireSessionJoin[n].size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SessionTrackerPolicySet to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionTrackerPolicySet to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.Version.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Version.length);\n      encoder.string(this.Version);\n    }\n\n    for (let n: i32 = 0; n < this.RequireSessionJoin.length; n++) {\n      const messageSize = this.RequireSessionJoin[n].size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        this.RequireSessionJoin[n].encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SessionTrackerPolicySet\n} // SessionTrackerPolicySet\n\n// Participant stores information about a participant in the session.\nexport class Participant {\n  // ID is a unique UUID of this participant for a given session.\n  public ID: string = \"\";\n  // User is the canonical name of the Teleport user controlling this participant.\n  public User: string = \"\";\n  // Mode is the participant mode.\n  public Mode: string = \"\";\n  // LastActive is the last time this party was active in the session.\n  public LastActive: google.protobuf.Timestamp =\n    new google.protobuf.Timestamp();\n\n  // Decodes Participant from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Participant {\n    return Participant.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Participant from a DataView\n  static decodeDataView(view: DataView): Participant {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Participant();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Mode = decoder.string();\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.LastActive = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Participant\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.ID.length) + this.ID.length\n        : 0;\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size +=\n      this.Mode.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Mode.length) + this.Mode.length\n        : 0;\n\n    if (this.LastActive != null) {\n      const f: google.protobuf.Timestamp = this\n        .LastActive as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes Participant to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Participant to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.ID.length);\n      encoder.string(this.ID);\n    }\n    if (this.User.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.Mode.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Mode.length);\n      encoder.string(this.Mode);\n    }\n\n    if (this.LastActive != null) {\n      const f = this.LastActive as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode Participant\n} // Participant\n\n// SortBy defines a sort criteria.\nexport class SortBy {\n  // IsDesc is a sort direction flag where if true the direction is descending, else ascending.\n  public IsDesc: bool;\n  // Field is the name of an objects field to sort by.\n  public Field: string = \"\";\n\n  // Decodes SortBy from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SortBy {\n    return SortBy.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SortBy from a DataView\n  static decodeDataView(view: DataView): SortBy {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SortBy();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.IsDesc = decoder.bool();\n          break;\n        }\n        case 2: {\n          obj.Field = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SortBy\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.IsDesc == 0 ? 0 : 1 + 1;\n    size +=\n      this.Field.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Field.length) + this.Field.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes SortBy to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SortBy to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.IsDesc != 0) {\n      encoder.uint32(0x8);\n      encoder.bool(this.IsDesc);\n    }\n    if (this.Field.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Field.length);\n      encoder.string(this.Field);\n    }\n\n    return buf;\n  } // encode SortBy\n} // SortBy\n\n// __decodeMap_string_string\n\nfunction __decodeMap_string_string(\n  parentDecoder: __proto.Decoder,\n  length: i32,\n  map: Map<string, string>\n): void {\n  const decoder = new __proto.Decoder(\n    new DataView(\n      parentDecoder.view.buffer,\n      parentDecoder.pos + parentDecoder.view.byteOffset,\n      length\n    )\n  );\n\n  let key: string = \"\";\n  let value: string = \"\";\n\n  while (!decoder.eof()) {\n    const tag = decoder.tag();\n    const number = tag >>> 3;\n\n    switch (number) {\n      case 1: {\n        key = decoder.string();\n        break;\n      }\n\n      case 2: {\n        value = decoder.string();\n        break;\n      }\n\n      default:\n        decoder.skipType(tag & 7);\n        break;\n    }\n  }\n  map.set(key as string, value as string);\n}\n\n// __sizeMapEntry_string_string\n\nfunction __sizeMapEntry_string_string(key: string, value: string): u32 {\n  return (\n    (key.length > 0 ? 1 + __proto.Sizer.varint64(key.length) + key.length : 0) +\n    (value.length > 0\n      ? 1 + __proto.Sizer.varint64(value.length) + value.length\n      : 0)\n  );\n}\n\n// __decodeMap_string_CommandLabelV2\n\nfunction __decodeMap_string_CommandLabelV2(\n  parentDecoder: __proto.Decoder,\n  length: i32,\n  map: Map<string, CommandLabelV2>\n): void {\n  const decoder = new __proto.Decoder(\n    new DataView(\n      parentDecoder.view.buffer,\n      parentDecoder.pos + parentDecoder.view.byteOffset,\n      length\n    )\n  );\n\n  let key: string = \"\";\n  let value: CommandLabelV2 = new CommandLabelV2();\n\n  while (!decoder.eof()) {\n    const tag = decoder.tag();\n    const number = tag >>> 3;\n\n    switch (number) {\n      case 1: {\n        key = decoder.string();\n        break;\n      }\n\n      case 2: {\n        const length = decoder.uint32();\n        value = CommandLabelV2.decodeDataView(\n          new DataView(\n            decoder.view.buffer,\n            decoder.pos + decoder.view.byteOffset,\n            length\n          )\n        );\n        decoder.skip(length);\n\n        break;\n      }\n\n      default:\n        decoder.skipType(tag & 7);\n        break;\n    }\n  }\n  map.set(key as string, value as CommandLabelV2);\n}\n\n// __sizeMapEntry_string_CommandLabelV2\n\nfunction __sizeMapEntry_string_CommandLabelV2(\n  key: string,\n  value: CommandLabelV2\n): u32 {\n  const keySize =\n    key.length > 0 ? 1 + __proto.Sizer.varint64(key.length) + key.length : 0;\n  const valueSize = value.size();\n\n  if (valueSize == 0) {\n    return keySize;\n  }\n\n  return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;\n}\n\n// __size_string_repeated\n\nfunction __size_string_repeated(value: Array<string>): u32 {\n  let size: u32 = 0;\n\n  for (let n: i32 = 0; n < value.length; n++) {\n    size += 1 + __proto.Sizer.varint64(value[n].length) + value[n].length;\n  }\n\n  return size;\n}\n\n// __size_bytes_repeated\n\nfunction __size_bytes_repeated(value: Array<Array<u8>>): u32 {\n  let size: u32 = 0;\n\n  for (let n: i32 = 0; n < value.length; n++) {\n    size += 1 + __proto.Sizer.varint64(value[n].length) + value[n].length;\n  }\n\n  return size;\n}\n\n// __size_uint32_repeated\n\nfunction __size_uint32_repeated(value: Array<u32>): u32 {\n  let size: u32 = 0;\n\n  for (let n: i32 = 0; n < value.length; n++) {\n    size += 1 + __proto.Sizer.uint32(value[n]);\n  }\n\n  return size;\n}\n\n// __decodeMap_string_ThresholdIndexSets\n\nfunction __decodeMap_string_ThresholdIndexSets(\n  parentDecoder: __proto.Decoder,\n  length: i32,\n  map: Map<string, ThresholdIndexSets>\n): void {\n  const decoder = new __proto.Decoder(\n    new DataView(\n      parentDecoder.view.buffer,\n      parentDecoder.pos + parentDecoder.view.byteOffset,\n      length\n    )\n  );\n\n  let key: string = \"\";\n  let value: ThresholdIndexSets = new ThresholdIndexSets();\n\n  while (!decoder.eof()) {\n    const tag = decoder.tag();\n    const number = tag >>> 3;\n\n    switch (number) {\n      case 1: {\n        key = decoder.string();\n        break;\n      }\n\n      case 2: {\n        const length = decoder.uint32();\n        value = ThresholdIndexSets.decodeDataView(\n          new DataView(\n            decoder.view.buffer,\n            decoder.pos + decoder.view.byteOffset,\n            length\n          )\n        );\n        decoder.skip(length);\n\n        break;\n      }\n\n      default:\n        decoder.skipType(tag & 7);\n        break;\n    }\n  }\n  map.set(key as string, value as ThresholdIndexSets);\n}\n\n// __sizeMapEntry_string_ThresholdIndexSets\n\nfunction __sizeMapEntry_string_ThresholdIndexSets(\n  key: string,\n  value: ThresholdIndexSets\n): u32 {\n  const keySize =\n    key.length > 0 ? 1 + __proto.Sizer.varint64(key.length) + key.length : 0;\n  const valueSize = value.size();\n\n  if (valueSize == 0) {\n    return keySize;\n  }\n\n  return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;\n}\n\n// __decodeMap_string_PluginDataEntry\n\nfunction __decodeMap_string_PluginDataEntry(\n  parentDecoder: __proto.Decoder,\n  length: i32,\n  map: Map<string, PluginDataEntry>\n): void {\n  const decoder = new __proto.Decoder(\n    new DataView(\n      parentDecoder.view.buffer,\n      parentDecoder.pos + parentDecoder.view.byteOffset,\n      length\n    )\n  );\n\n  let key: string = \"\";\n  let value: PluginDataEntry = new PluginDataEntry();\n\n  while (!decoder.eof()) {\n    const tag = decoder.tag();\n    const number = tag >>> 3;\n\n    switch (number) {\n      case 1: {\n        key = decoder.string();\n        break;\n      }\n\n      case 2: {\n        const length = decoder.uint32();\n        value = PluginDataEntry.decodeDataView(\n          new DataView(\n            decoder.view.buffer,\n            decoder.pos + decoder.view.byteOffset,\n            length\n          )\n        );\n        decoder.skip(length);\n\n        break;\n      }\n\n      default:\n        decoder.skipType(tag & 7);\n        break;\n    }\n  }\n  map.set(key as string, value as PluginDataEntry);\n}\n\n// __sizeMapEntry_string_PluginDataEntry\n\nfunction __sizeMapEntry_string_PluginDataEntry(\n  key: string,\n  value: PluginDataEntry\n): u32 {\n  const keySize =\n    key.length > 0 ? 1 + __proto.Sizer.varint64(key.length) + key.length : 0;\n  const valueSize = value.size();\n\n  if (valueSize == 0) {\n    return keySize;\n  }\n\n  return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;\n}\n","import * as __proto from \"./__proto\";\n\nimport * as google from \"./google\";\nimport * as wrappers from \"./wrappers\";\n// Action communicates what was done in response to the event\nexport enum EventAction {\n  OBSERVED = 0,\n  DENIED = 1,\n} // EventAction\n// Metadata is a common event metadata\nexport class Metadata {\n  // Index is a monotonicaly incremented index in the event sequence\n  public Index: i64;\n  // Type is the event type\n  public Type: string = \"\";\n  // ID is a unique event identifier\n  public ID: string = \"\";\n  // Code is a unique event code\n  public Code: string = \"\";\n  // Time is event time\n  public Time: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // ClusterName identifies the originating teleport cluster\n  public ClusterName: string = \"\";\n\n  // Decodes Metadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Metadata {\n    return Metadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Metadata from a DataView\n  static decodeDataView(view: DataView): Metadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Metadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Index = decoder.int64();\n          break;\n        }\n        case 2: {\n          obj.Type = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.ID = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.Code = decoder.string();\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Time = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.ClusterName = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Metadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.Index == 0 ? 0 : 1 + __proto.Sizer.int64(this.Index);\n    size +=\n      this.Type.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Type.length) + this.Type.length\n        : 0;\n    size +=\n      this.ID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.ID.length) + this.ID.length\n        : 0;\n    size +=\n      this.Code.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Code.length) + this.Code.length\n        : 0;\n\n    if (this.Time != null) {\n      const f: google.protobuf.Timestamp = this\n        .Time as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.ClusterName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClusterName.length) +\n          this.ClusterName.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes Metadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Metadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Index != 0) {\n      encoder.uint32(0x8);\n      encoder.int64(this.Index);\n    }\n    if (this.Type.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Type.length);\n      encoder.string(this.Type);\n    }\n    if (this.ID.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.ID.length);\n      encoder.string(this.ID);\n    }\n    if (this.Code.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.Code.length);\n      encoder.string(this.Code);\n    }\n\n    if (this.Time != null) {\n      const f = this.Time as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.ClusterName.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.ClusterName.length);\n      encoder.string(this.ClusterName);\n    }\n\n    return buf;\n  } // encode Metadata\n} // Metadata\n\n// SessionCommand is a session command event\nexport class SessionMetadata {\n  // SessionID is a unique UUID of the session.\n  public SessionID: string = \"\";\n  // WithMFA is a UUID of an MFA device used to start this session.\n  public WithMFA: string = \"\";\n\n  // Decodes SessionMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionMetadata {\n    return SessionMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionMetadata from a DataView\n  static decodeDataView(view: DataView): SessionMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.SessionID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.WithMFA = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.SessionID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SessionID.length) +\n          this.SessionID.length\n        : 0;\n    size +=\n      this.WithMFA.length > 0\n        ? 1 + __proto.Sizer.varint64(this.WithMFA.length) + this.WithMFA.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes SessionMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.SessionID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.SessionID.length);\n      encoder.string(this.SessionID);\n    }\n    if (this.WithMFA.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.WithMFA.length);\n      encoder.string(this.WithMFA);\n    }\n\n    return buf;\n  } // encode SessionMetadata\n} // SessionMetadata\n\n// AccessRequestCreate is emitted when access request has been created or updated\nexport class UserMetadata {\n  // User is teleport user name\n  public User: string = \"\";\n  // Login is OS login\n  public Login: string = \"\";\n  // Impersonator is a user acting on behalf of another user\n  public Impersonator: string = \"\";\n  // AWSRoleARN is AWS IAM role user assumes when accessing AWS console.\n  public AWSRoleARN: string = \"\";\n  // AccessRequests are the IDs of access requests created by the user\n  public AccessRequests: Array<string> = new Array<string>();\n\n  // Decodes UserMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserMetadata {\n    return UserMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserMetadata from a DataView\n  static decodeDataView(view: DataView): UserMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Login = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Impersonator = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.AWSRoleARN = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.AccessRequests.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size +=\n      this.Login.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Login.length) + this.Login.length\n        : 0;\n    size +=\n      this.Impersonator.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Impersonator.length) +\n          this.Impersonator.length\n        : 0;\n    size +=\n      this.AWSRoleARN.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.AWSRoleARN.length) +\n          this.AWSRoleARN.length\n        : 0;\n\n    size += __size_string_repeated(this.AccessRequests);\n\n    return size;\n  }\n\n  // Encodes UserMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.Login.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Login.length);\n      encoder.string(this.Login);\n    }\n    if (this.Impersonator.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Impersonator.length);\n      encoder.string(this.Impersonator);\n    }\n    if (this.AWSRoleARN.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.AWSRoleARN.length);\n      encoder.string(this.AWSRoleARN);\n    }\n\n    if (this.AccessRequests.length > 0) {\n      for (let n: i32 = 0; n < this.AccessRequests.length; n++) {\n        encoder.uint32(0x2a);\n        encoder.uint32(this.AccessRequests[n].length);\n        encoder.string(this.AccessRequests[n]);\n      }\n    }\n\n    return buf;\n  } // encode UserMetadata\n} // UserMetadata\n\n// UserTokenCreate is emitted when a user token is created.\nexport class ServerMetadata {\n  // ServerNamespace is a namespace of the server event\n  public ServerNamespace: string = \"\";\n  // ServerID is the UUID of the server the session occurred on.\n  public ServerID: string = \"\";\n  // ServerHostname is the hostname of the server the session occurred on.\n  public ServerHostname: string = \"\";\n  // ServerAddr is the address of the server the session occurred on.\n  public ServerAddr: string = \"\";\n  /**\n   * ServerLabels are the labels (static and dynamic) of the server the\n   *  session occurred on.\n   */\n  public ServerLabels: Map<string, string> = new Map<string, string>();\n\n  // Decodes ServerMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ServerMetadata {\n    return ServerMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ServerMetadata from a DataView\n  static decodeDataView(view: DataView): ServerMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ServerMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ServerNamespace = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.ServerID = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.ServerHostname = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.ServerAddr = decoder.string();\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.ServerLabels);\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ServerMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ServerNamespace.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ServerNamespace.length) +\n          this.ServerNamespace.length\n        : 0;\n    size +=\n      this.ServerID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ServerID.length) +\n          this.ServerID.length\n        : 0;\n    size +=\n      this.ServerHostname.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ServerHostname.length) +\n          this.ServerHostname.length\n        : 0;\n    size +=\n      this.ServerAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ServerAddr.length) +\n          this.ServerAddr.length\n        : 0;\n\n    if (this.ServerLabels.size > 0) {\n      const keys = this.ServerLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.ServerLabels.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes ServerMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ServerMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ServerNamespace.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.ServerNamespace.length);\n      encoder.string(this.ServerNamespace);\n    }\n    if (this.ServerID.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.ServerID.length);\n      encoder.string(this.ServerID);\n    }\n    if (this.ServerHostname.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.ServerHostname.length);\n      encoder.string(this.ServerHostname);\n    }\n    if (this.ServerAddr.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.ServerAddr.length);\n      encoder.string(this.ServerAddr);\n    }\n\n    if (this.ServerLabels.size > 0) {\n      const keys = this.ServerLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.ServerLabels.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0x2a);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    return buf;\n  } // encode ServerMetadata\n} // ServerMetadata\n\n// SAMLConnectorCreate fires when SAML connector is created/updated.\nexport class ConnectionMetadata {\n  // LocalAddr is a target address on the host\n  public LocalAddr: string = \"\";\n  // RemoteAddr is a client (user's) address\n  public RemoteAddr: string = \"\";\n  // Protocol specifies protocol that was captured\n  public Protocol: string = \"\";\n\n  // Decodes ConnectionMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ConnectionMetadata {\n    return ConnectionMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ConnectionMetadata from a DataView\n  static decodeDataView(view: DataView): ConnectionMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ConnectionMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.LocalAddr = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.RemoteAddr = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Protocol = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ConnectionMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.LocalAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.LocalAddr.length) +\n          this.LocalAddr.length\n        : 0;\n    size +=\n      this.RemoteAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RemoteAddr.length) +\n          this.RemoteAddr.length\n        : 0;\n    size +=\n      this.Protocol.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Protocol.length) +\n          this.Protocol.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ConnectionMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ConnectionMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.LocalAddr.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.LocalAddr.length);\n      encoder.string(this.LocalAddr);\n    }\n    if (this.RemoteAddr.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.RemoteAddr.length);\n      encoder.string(this.RemoteAddr);\n    }\n    if (this.Protocol.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Protocol.length);\n      encoder.string(this.Protocol);\n    }\n\n    return buf;\n  } // encode ConnectionMetadata\n} // ConnectionMetadata\n\n// DatabaseMetadata contains common database information.\nexport class KubernetesClusterMetadata {\n  // KubernetesCluster is a kubernetes cluster name.\n  public KubernetesCluster: string = \"\";\n  // KubernetesUsers is a list of kubernetes usernames for the user.\n  public KubernetesUsers: Array<string> = new Array<string>();\n  // KubernetesGroups is a list of kubernetes groups for the user.\n  public KubernetesGroups: Array<string> = new Array<string>();\n\n  // Decodes KubernetesClusterMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): KubernetesClusterMetadata {\n    return KubernetesClusterMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes KubernetesClusterMetadata from a DataView\n  static decodeDataView(view: DataView): KubernetesClusterMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new KubernetesClusterMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.KubernetesCluster = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.KubernetesUsers.push(decoder.string());\n          break;\n        }\n        case 3: {\n          obj.KubernetesGroups.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode KubernetesClusterMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.KubernetesCluster.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.KubernetesCluster.length) +\n          this.KubernetesCluster.length\n        : 0;\n\n    size += __size_string_repeated(this.KubernetesUsers);\n\n    size += __size_string_repeated(this.KubernetesGroups);\n\n    return size;\n  }\n\n  // Encodes KubernetesClusterMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes KubernetesClusterMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.KubernetesCluster.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.KubernetesCluster.length);\n      encoder.string(this.KubernetesCluster);\n    }\n\n    if (this.KubernetesUsers.length > 0) {\n      for (let n: i32 = 0; n < this.KubernetesUsers.length; n++) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.KubernetesUsers[n].length);\n        encoder.string(this.KubernetesUsers[n]);\n      }\n    }\n\n    if (this.KubernetesGroups.length > 0) {\n      for (let n: i32 = 0; n < this.KubernetesGroups.length; n++) {\n        encoder.uint32(0x1a);\n        encoder.uint32(this.KubernetesGroups[n].length);\n        encoder.string(this.KubernetesGroups[n]);\n      }\n    }\n\n    return buf;\n  } // encode KubernetesClusterMetadata\n} // KubernetesClusterMetadata\n\n/**\n * PostgresFunctionCall is emitted when a Postgres client calls internal\n *  database function.\n */\nexport class KubernetesPodMetadata {\n  // KubernetesPodName is the name of the pod.\n  public KubernetesPodName: string = \"\";\n  // KubernetesPodNamespace is the namespace of the pod.\n  public KubernetesPodNamespace: string = \"\";\n  // KubernetesContainerName is the name of the container within the pod.\n  public KubernetesContainerName: string = \"\";\n  // KubernetesContainerImage is the image of the container within the pod.\n  public KubernetesContainerImage: string = \"\";\n  // KubernetesNodeName is the node that runs the pod.\n  public KubernetesNodeName: string = \"\";\n\n  // Decodes KubernetesPodMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): KubernetesPodMetadata {\n    return KubernetesPodMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes KubernetesPodMetadata from a DataView\n  static decodeDataView(view: DataView): KubernetesPodMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new KubernetesPodMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.KubernetesPodName = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.KubernetesPodNamespace = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.KubernetesContainerName = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.KubernetesContainerImage = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.KubernetesNodeName = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode KubernetesPodMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.KubernetesPodName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.KubernetesPodName.length) +\n          this.KubernetesPodName.length\n        : 0;\n    size +=\n      this.KubernetesPodNamespace.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.KubernetesPodNamespace.length) +\n          this.KubernetesPodNamespace.length\n        : 0;\n    size +=\n      this.KubernetesContainerName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.KubernetesContainerName.length) +\n          this.KubernetesContainerName.length\n        : 0;\n    size +=\n      this.KubernetesContainerImage.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.KubernetesContainerImage.length) +\n          this.KubernetesContainerImage.length\n        : 0;\n    size +=\n      this.KubernetesNodeName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.KubernetesNodeName.length) +\n          this.KubernetesNodeName.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes KubernetesPodMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes KubernetesPodMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.KubernetesPodName.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.KubernetesPodName.length);\n      encoder.string(this.KubernetesPodName);\n    }\n    if (this.KubernetesPodNamespace.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.KubernetesPodNamespace.length);\n      encoder.string(this.KubernetesPodNamespace);\n    }\n    if (this.KubernetesContainerName.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.KubernetesContainerName.length);\n      encoder.string(this.KubernetesContainerName);\n    }\n    if (this.KubernetesContainerImage.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.KubernetesContainerImage.length);\n      encoder.string(this.KubernetesContainerImage);\n    }\n    if (this.KubernetesNodeName.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.KubernetesNodeName.length);\n      encoder.string(this.KubernetesNodeName);\n    }\n\n    return buf;\n  } // encode KubernetesPodMetadata\n} // KubernetesPodMetadata\n\n// LockDelete is emitted when a lock is deleted\nexport class SessionStart {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // TerminalSize is expressed as 'W:H'\n  public TerminalSize: string = \"\";\n  /**\n   * KubernetesCluster has information about a kubernetes cluster, if\n   *  applicable.\n   */\n  public KubernetesCluster: KubernetesClusterMetadata =\n    new KubernetesClusterMetadata();\n  // KubernetesPod has information about a kubernetes pod, if applicable.\n  public KubernetesPod: KubernetesPodMetadata = new KubernetesPodMetadata();\n  // InitialCommand is the command used to start this session.\n  public InitialCommand: Array<string> = new Array<string>();\n  // SessionRecording is the type of session recording.\n  public SessionRecording: string = \"\";\n\n  // Decodes SessionStart from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionStart {\n    return SessionStart.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionStart from a DataView\n  static decodeDataView(view: DataView): SessionStart {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionStart();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.TerminalSize = decoder.string();\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.KubernetesCluster = KubernetesClusterMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.KubernetesPod = KubernetesPodMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 9: {\n          obj.InitialCommand.push(decoder.string());\n          break;\n        }\n        case 10: {\n          obj.SessionRecording = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionStart\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.TerminalSize.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.TerminalSize.length) +\n          this.TerminalSize.length\n        : 0;\n\n    if (this.KubernetesCluster != null) {\n      const f: KubernetesClusterMetadata = this\n        .KubernetesCluster as KubernetesClusterMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.KubernetesPod != null) {\n      const f: KubernetesPodMetadata = this\n        .KubernetesPod as KubernetesPodMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.InitialCommand);\n\n    size +=\n      this.SessionRecording.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SessionRecording.length) +\n          this.SessionRecording.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes SessionStart to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionStart to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.TerminalSize.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.TerminalSize.length);\n      encoder.string(this.TerminalSize);\n    }\n\n    if (this.KubernetesCluster != null) {\n      const f = this.KubernetesCluster as KubernetesClusterMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubernetesPod != null) {\n      const f = this.KubernetesPod as KubernetesPodMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.InitialCommand.length > 0) {\n      for (let n: i32 = 0; n < this.InitialCommand.length; n++) {\n        encoder.uint32(0x4a);\n        encoder.uint32(this.InitialCommand[n].length);\n        encoder.string(this.InitialCommand[n]);\n      }\n    }\n\n    if (this.SessionRecording.length > 0) {\n      encoder.uint32(0x52);\n      encoder.uint32(this.SessionRecording.length);\n      encoder.string(this.SessionRecording);\n    }\n\n    return buf;\n  } // encode SessionStart\n} // SessionStart\n\n/**\n * Identity matches github.com/gravitational/teleport/lib/tlsca.Identity except\n *  for RouteToApp and RouteToDatabase which are nullable and Traits which is\n *  represented as a google.protobuf.Struct (still containing a map from string\n *  to strings). Field names match other names already used in other events\n *  rather than the field names in tlsca.Identity.\n */\nexport class SessionJoin {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  /**\n   * KubernetesCluster has information about a kubernetes cluster, if\n   *  applicable.\n   */\n  public KubernetesCluster: KubernetesClusterMetadata =\n    new KubernetesClusterMetadata();\n\n  // Decodes SessionJoin from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionJoin {\n    return SessionJoin.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionJoin from a DataView\n  static decodeDataView(view: DataView): SessionJoin {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionJoin();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.KubernetesCluster = KubernetesClusterMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionJoin\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.KubernetesCluster != null) {\n      const f: KubernetesClusterMetadata = this\n        .KubernetesCluster as KubernetesClusterMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SessionJoin to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionJoin to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubernetesCluster != null) {\n      const f = this.KubernetesCluster as KubernetesClusterMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SessionJoin\n} // SessionJoin\n\n/**\n * MySQLStatementBulkExecute is emitted when a MySQL client executes a bulk\n *  insert of a prepared statement using the prepared statement protocol.\n */\nexport class SessionPrint {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ChunkIndex is a monotonicaly incremented index for ordering print events\n  public ChunkIndex: i64;\n  // Data is data transferred, it is not marshaled to JSON format\n  public Data: Array<u8> = new Array<u8>();\n  /**\n   * Bytes says how many bytes have been written into the session\n   *  during \"print\" event\n   */\n  public Bytes: i64;\n  // DelayMilliseconds is the delay in milliseconds from the start of the session\n  public DelayMilliseconds: i64;\n  // Offset is the offset in bytes in the session file\n  public Offset: i64;\n\n  // Decodes SessionPrint from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionPrint {\n    return SessionPrint.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionPrint from a DataView\n  static decodeDataView(view: DataView): SessionPrint {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionPrint();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          obj.ChunkIndex = decoder.int64();\n          break;\n        }\n        case 3: {\n          obj.Data = decoder.bytes();\n          break;\n        }\n        case 4: {\n          obj.Bytes = decoder.int64();\n          break;\n        }\n        case 5: {\n          obj.DelayMilliseconds = decoder.int64();\n          break;\n        }\n        case 6: {\n          obj.Offset = decoder.int64();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionPrint\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += this.ChunkIndex == 0 ? 0 : 1 + __proto.Sizer.int64(this.ChunkIndex);\n    size +=\n      this.Data.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Data.length) + this.Data.length\n        : 0;\n    size += this.Bytes == 0 ? 0 : 1 + __proto.Sizer.int64(this.Bytes);\n    size +=\n      this.DelayMilliseconds == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.DelayMilliseconds);\n    size += this.Offset == 0 ? 0 : 1 + __proto.Sizer.int64(this.Offset);\n\n    return size;\n  }\n\n  // Encodes SessionPrint to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionPrint to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.ChunkIndex != 0) {\n      encoder.uint32(0x10);\n      encoder.int64(this.ChunkIndex);\n    }\n    if (this.Data.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Data.length);\n      encoder.bytes(this.Data);\n    }\n    if (this.Bytes != 0) {\n      encoder.uint32(0x20);\n      encoder.int64(this.Bytes);\n    }\n    if (this.DelayMilliseconds != 0) {\n      encoder.uint32(0x28);\n      encoder.int64(this.DelayMilliseconds);\n    }\n    if (this.Offset != 0) {\n      encoder.uint32(0x30);\n      encoder.int64(this.Offset);\n    }\n\n    return buf;\n  } // encode SessionPrint\n} // SessionPrint\n\n/**\n * DesktopRecording happens when a Teleport Desktop Protocol message\n *  is captured during a Desktop Access Session.\n */\nexport class DesktopRecording {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // Message is the encoded TDP message.\n  public Message: Array<u8> = new Array<u8>();\n  /**\n   * DelayMilliseconds is the delay in milliseconds from the start of the session\n   *\n   *\n   *  JSON tag intentionally matches SessionPrintEvent\n   */\n  public DelayMilliseconds: i64;\n\n  // Decodes DesktopRecording from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DesktopRecording {\n    return DesktopRecording.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DesktopRecording from a DataView\n  static decodeDataView(view: DataView): DesktopRecording {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DesktopRecording();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          obj.Message = decoder.bytes();\n          break;\n        }\n        case 3: {\n          obj.DelayMilliseconds = decoder.int64();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DesktopRecording\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Message.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Message.length) + this.Message.length\n        : 0;\n    size +=\n      this.DelayMilliseconds == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.DelayMilliseconds);\n\n    return size;\n  }\n\n  // Encodes DesktopRecording to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DesktopRecording to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Message.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Message.length);\n      encoder.bytes(this.Message);\n    }\n    if (this.DelayMilliseconds != 0) {\n      encoder.uint32(0x18);\n      encoder.int64(this.DelayMilliseconds);\n    }\n\n    return buf;\n  } // encode DesktopRecording\n} // DesktopRecording\n\n/**\n * DesktopClipboardReceive is emitted when Teleport receives\n *  clipboard data from a remote desktop.\n */\nexport class DesktopClipboardReceive {\n  // Metadata is common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // Session is common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Connection holds information about the connection.\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // DesktopAddr is the address of the desktop being accessed.\n  public DesktopAddr: string = \"\";\n  // Length is the number of bytes of data received from the remote clipboard.\n  public Length: i32;\n\n  // Decodes DesktopClipboardReceive from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DesktopClipboardReceive {\n    return DesktopClipboardReceive.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DesktopClipboardReceive from a DataView\n  static decodeDataView(view: DataView): DesktopClipboardReceive {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DesktopClipboardReceive();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.DesktopAddr = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.Length = decoder.int32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DesktopClipboardReceive\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.DesktopAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DesktopAddr.length) +\n          this.DesktopAddr.length\n        : 0;\n    size += this.Length == 0 ? 0 : 1 + __proto.Sizer.int32(this.Length);\n\n    return size;\n  }\n\n  // Encodes DesktopClipboardReceive to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DesktopClipboardReceive to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DesktopAddr.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.DesktopAddr.length);\n      encoder.string(this.DesktopAddr);\n    }\n    if (this.Length != 0) {\n      encoder.uint32(0x30);\n      encoder.int32(this.Length);\n    }\n\n    return buf;\n  } // encode DesktopClipboardReceive\n} // DesktopClipboardReceive\n\n/**\n * DesktopClipboardSend is emitted when clipboard data is\n *  sent from a user's workstation to Teleport.\n */\nexport class DesktopClipboardSend {\n  // Metadata is common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // Session is common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Connection holds information about the connection.\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // DesktopAddr is the address of the desktop being accessed.\n  public DesktopAddr: string = \"\";\n  // Length is the number of bytes of data sent.\n  public Length: i32;\n\n  // Decodes DesktopClipboardSend from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DesktopClipboardSend {\n    return DesktopClipboardSend.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DesktopClipboardSend from a DataView\n  static decodeDataView(view: DataView): DesktopClipboardSend {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DesktopClipboardSend();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.DesktopAddr = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.Length = decoder.int32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DesktopClipboardSend\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.DesktopAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DesktopAddr.length) +\n          this.DesktopAddr.length\n        : 0;\n    size += this.Length == 0 ? 0 : 1 + __proto.Sizer.int32(this.Length);\n\n    return size;\n  }\n\n  // Encodes DesktopClipboardSend to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DesktopClipboardSend to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DesktopAddr.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.DesktopAddr.length);\n      encoder.string(this.DesktopAddr);\n    }\n    if (this.Length != 0) {\n      encoder.uint32(0x30);\n      encoder.int32(this.Length);\n    }\n\n    return buf;\n  } // encode DesktopClipboardSend\n} // DesktopClipboardSend\n\n// SessionReject event happens when a user hits a session control restriction.\nexport class SessionReject {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  /**\n   * Reason is a field that specifies reason for event, e.g. in disconnect\n   *  event it explains why server disconnected the client\n   */\n  public Reason: string = \"\";\n  /**\n   * Maximum is an event field specifying a maximal value (e.g. the value\n   *  of `max_connections` for a `session.rejected` event).\n   */\n  public Maximum: i64;\n\n  // Decodes SessionReject from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionReject {\n    return SessionReject.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionReject from a DataView\n  static decodeDataView(view: DataView): SessionReject {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionReject();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.Reason = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.Maximum = decoder.int64();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionReject\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Reason.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Reason.length) + this.Reason.length\n        : 0;\n    size += this.Maximum == 0 ? 0 : 1 + __proto.Sizer.int64(this.Maximum);\n\n    return size;\n  }\n\n  // Encodes SessionReject to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionReject to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Reason.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.Reason.length);\n      encoder.string(this.Reason);\n    }\n    if (this.Maximum != 0) {\n      encoder.uint32(0x30);\n      encoder.int64(this.Maximum);\n    }\n\n    return buf;\n  } // encode SessionReject\n} // SessionReject\n\n// SessionConnect is emitted when a non-Teleport connection is made over net.Dial.\nexport class SessionConnect {\n  public Metadata: Metadata = new Metadata();\n  public Server: ServerMetadata = new ServerMetadata();\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n\n  // Decodes SessionConnect from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionConnect {\n    return SessionConnect.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionConnect from a DataView\n  static decodeDataView(view: DataView): SessionConnect {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionConnect();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionConnect\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SessionConnect to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionConnect to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SessionConnect\n} // SessionConnect\n\n// Resize means that some user resized PTY on the client\nexport class Resize {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // TerminalSize is expressed as 'W:H'\n  public TerminalSize: string = \"\";\n  /**\n   * KubernetesCluster has information about a kubernetes cluster, if\n   *  applicable.\n   */\n  public KubernetesCluster: KubernetesClusterMetadata =\n    new KubernetesClusterMetadata();\n  // KubernetesPod has information about a kubernetes pod, if applicable.\n  public KubernetesPod: KubernetesPodMetadata = new KubernetesPodMetadata();\n\n  // Decodes Resize from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Resize {\n    return Resize.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Resize from a DataView\n  static decodeDataView(view: DataView): Resize {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Resize();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.TerminalSize = decoder.string();\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.KubernetesCluster = KubernetesClusterMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.KubernetesPod = KubernetesPodMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Resize\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.TerminalSize.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.TerminalSize.length) +\n          this.TerminalSize.length\n        : 0;\n\n    if (this.KubernetesCluster != null) {\n      const f: KubernetesClusterMetadata = this\n        .KubernetesCluster as KubernetesClusterMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.KubernetesPod != null) {\n      const f: KubernetesPodMetadata = this\n        .KubernetesPod as KubernetesPodMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes Resize to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Resize to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.TerminalSize.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.TerminalSize.length);\n      encoder.string(this.TerminalSize);\n    }\n\n    if (this.KubernetesCluster != null) {\n      const f = this.KubernetesCluster as KubernetesClusterMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubernetesPod != null) {\n      const f = this.KubernetesPod as KubernetesPodMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode Resize\n} // Resize\n\n// SessionEnd is a session end event\nexport class SessionEnd {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  /**\n   * EnhancedRecording is used to indicate if the recording was an\n   *  enhanced recording or not.\n   */\n  public EnhancedRecording: bool;\n  /**\n   * Interactive is used to indicate if the session was interactive\n   *  (has PTY attached) or not (exec session).\n   */\n  public Interactive: bool;\n  // Participants is a list of participants in the session.\n  public Participants: Array<string> = new Array<string>();\n  // StartTime is the timestamp at which the session began.\n  public StartTime: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // EndTime is the timestamp at which the session ended.\n  public EndTime: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  /**\n   * KubernetesCluster has information about a kubernetes cluster, if\n   *  applicable.\n   */\n  public KubernetesCluster: KubernetesClusterMetadata =\n    new KubernetesClusterMetadata();\n  // KubernetesPod has information about a kubernetes pod, if applicable.\n  public KubernetesPod: KubernetesPodMetadata = new KubernetesPodMetadata();\n  // InitialCommand is the command used to start this session.\n  public InitialCommand: Array<string> = new Array<string>();\n  // SessionRecording is the type of session recording.\n  public SessionRecording: string = \"\";\n\n  // Decodes SessionEnd from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionEnd {\n    return SessionEnd.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionEnd from a DataView\n  static decodeDataView(view: DataView): SessionEnd {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionEnd();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.EnhancedRecording = decoder.bool();\n          break;\n        }\n        case 7: {\n          obj.Interactive = decoder.bool();\n          break;\n        }\n        case 8: {\n          obj.Participants.push(decoder.string());\n          break;\n        }\n        case 9: {\n          const length = decoder.uint32();\n          obj.StartTime = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.EndTime = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 11: {\n          const length = decoder.uint32();\n          obj.KubernetesCluster = KubernetesClusterMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 12: {\n          const length = decoder.uint32();\n          obj.KubernetesPod = KubernetesPodMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 13: {\n          obj.InitialCommand.push(decoder.string());\n          break;\n        }\n        case 14: {\n          obj.SessionRecording = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionEnd\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += this.EnhancedRecording == 0 ? 0 : 1 + 1;\n    size += this.Interactive == 0 ? 0 : 1 + 1;\n\n    size += __size_string_repeated(this.Participants);\n\n    if (this.StartTime != null) {\n      const f: google.protobuf.Timestamp = this\n        .StartTime as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.EndTime != null) {\n      const f: google.protobuf.Timestamp = this\n        .EndTime as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.KubernetesCluster != null) {\n      const f: KubernetesClusterMetadata = this\n        .KubernetesCluster as KubernetesClusterMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.KubernetesPod != null) {\n      const f: KubernetesPodMetadata = this\n        .KubernetesPod as KubernetesPodMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.InitialCommand);\n\n    size +=\n      this.SessionRecording.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SessionRecording.length) +\n          this.SessionRecording.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes SessionEnd to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionEnd to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.EnhancedRecording != 0) {\n      encoder.uint32(0x30);\n      encoder.bool(this.EnhancedRecording);\n    }\n    if (this.Interactive != 0) {\n      encoder.uint32(0x38);\n      encoder.bool(this.Interactive);\n    }\n\n    if (this.Participants.length > 0) {\n      for (let n: i32 = 0; n < this.Participants.length; n++) {\n        encoder.uint32(0x42);\n        encoder.uint32(this.Participants[n].length);\n        encoder.string(this.Participants[n]);\n      }\n    }\n\n    if (this.StartTime != null) {\n      const f = this.StartTime as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x4a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.EndTime != null) {\n      const f = this.EndTime as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubernetesCluster != null) {\n      const f = this.KubernetesCluster as KubernetesClusterMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x5a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubernetesPod != null) {\n      const f = this.KubernetesPod as KubernetesPodMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x62);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.InitialCommand.length > 0) {\n      for (let n: i32 = 0; n < this.InitialCommand.length; n++) {\n        encoder.uint32(0x6a);\n        encoder.uint32(this.InitialCommand[n].length);\n        encoder.string(this.InitialCommand[n]);\n      }\n    }\n\n    if (this.SessionRecording.length > 0) {\n      encoder.uint32(0x72);\n      encoder.uint32(this.SessionRecording.length);\n      encoder.string(this.SessionRecording);\n    }\n\n    return buf;\n  } // encode SessionEnd\n} // SessionEnd\n\n// BPFMetadata is a common BPF process metadata\nexport class BPFMetadata {\n  // PID is the ID of the process.\n  public PID: u64;\n  // CgroupID is the internal cgroupv2 ID of the event.\n  public CgroupID: u64;\n  // Program is name of the executable.\n  public Program: string = \"\";\n\n  // Decodes BPFMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): BPFMetadata {\n    return BPFMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes BPFMetadata from a DataView\n  static decodeDataView(view: DataView): BPFMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new BPFMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.PID = decoder.uint64();\n          break;\n        }\n        case 2: {\n          obj.CgroupID = decoder.uint64();\n          break;\n        }\n        case 3: {\n          obj.Program = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode BPFMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.PID == 0 ? 0 : 1 + __proto.Sizer.uint64(this.PID);\n    size += this.CgroupID == 0 ? 0 : 1 + __proto.Sizer.uint64(this.CgroupID);\n    size +=\n      this.Program.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Program.length) + this.Program.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes BPFMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes BPFMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.PID != 0) {\n      encoder.uint32(0x8);\n      encoder.uint64(this.PID);\n    }\n    if (this.CgroupID != 0) {\n      encoder.uint32(0x10);\n      encoder.uint64(this.CgroupID);\n    }\n    if (this.Program.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Program.length);\n      encoder.string(this.Program);\n    }\n\n    return buf;\n  } // encode BPFMetadata\n} // BPFMetadata\n\n// Status contains common command or operation status fields\nexport class Status {\n  // Success indicates the success or failure of the operation\n  public Success: bool;\n  // Error includes system error message for the failed attempt\n  public Error: string = \"\";\n  // UserMessage is a user-friendly message for successfull or unsuccessfull auth attempt\n  public UserMessage: string = \"\";\n\n  // Decodes Status from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Status {\n    return Status.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Status from a DataView\n  static decodeDataView(view: DataView): Status {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Status();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Success = decoder.bool();\n          break;\n        }\n        case 2: {\n          obj.Error = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.UserMessage = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Status\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += this.Success == 0 ? 0 : 1 + 1;\n    size +=\n      this.Error.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Error.length) + this.Error.length\n        : 0;\n    size +=\n      this.UserMessage.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.UserMessage.length) +\n          this.UserMessage.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes Status to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Status to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Success != 0) {\n      encoder.uint32(0x8);\n      encoder.bool(this.Success);\n    }\n    if (this.Error.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Error.length);\n      encoder.string(this.Error);\n    }\n    if (this.UserMessage.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.UserMessage.length);\n      encoder.string(this.UserMessage);\n    }\n\n    return buf;\n  } // encode Status\n} // Status\n\n// SessionCommand is a session command event\nexport class SessionCommand {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // BPFMetadata is a common BPF subsystem metadata\n  public BPF: BPFMetadata = new BPFMetadata();\n  // PPID is the PID of the parent process.\n  public PPID: u64;\n  // Path is the full path to the executable.\n  public Path: string = \"\";\n  /**\n   * Argv is the list of arguments to the program. Note, the first element does\n   *  not contain the name of the process.\n   */\n  public Argv: Array<string> = new Array<string>();\n  // ReturnCode is the return code of execve.\n  public ReturnCode: i32;\n\n  // Decodes SessionCommand from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionCommand {\n    return SessionCommand.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionCommand from a DataView\n  static decodeDataView(view: DataView): SessionCommand {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionCommand();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.BPF = BPFMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.PPID = decoder.uint64();\n          break;\n        }\n        case 7: {\n          obj.Path = decoder.string();\n          break;\n        }\n        case 8: {\n          obj.Argv.push(decoder.string());\n          break;\n        }\n        case 9: {\n          obj.ReturnCode = decoder.int32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionCommand\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.BPF != null) {\n      const f: BPFMetadata = this.BPF as BPFMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += this.PPID == 0 ? 0 : 1 + __proto.Sizer.uint64(this.PPID);\n    size +=\n      this.Path.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Path.length) + this.Path.length\n        : 0;\n\n    size += __size_string_repeated(this.Argv);\n\n    size += this.ReturnCode == 0 ? 0 : 1 + __proto.Sizer.int32(this.ReturnCode);\n\n    return size;\n  }\n\n  // Encodes SessionCommand to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionCommand to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.BPF != null) {\n      const f = this.BPF as BPFMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.PPID != 0) {\n      encoder.uint32(0x30);\n      encoder.uint64(this.PPID);\n    }\n    if (this.Path.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.Path.length);\n      encoder.string(this.Path);\n    }\n\n    if (this.Argv.length > 0) {\n      for (let n: i32 = 0; n < this.Argv.length; n++) {\n        encoder.uint32(0x42);\n        encoder.uint32(this.Argv[n].length);\n        encoder.string(this.Argv[n]);\n      }\n    }\n\n    if (this.ReturnCode != 0) {\n      encoder.uint32(0x48);\n      encoder.int32(this.ReturnCode);\n    }\n\n    return buf;\n  } // encode SessionCommand\n} // SessionCommand\n\n// SessionDisk is a session disk access event\nexport class SessionDisk {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // BPFMetadata is a common BPF subsystem metadata\n  public BPF: BPFMetadata = new BPFMetadata();\n  // Path is the full path to the executable.\n  public Path: string = \"\";\n  // Flags are the flags passed to open.\n  public Flags: i32;\n  // ReturnCode is the return code of disk open\n  public ReturnCode: i32;\n\n  // Decodes SessionDisk from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionDisk {\n    return SessionDisk.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionDisk from a DataView\n  static decodeDataView(view: DataView): SessionDisk {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionDisk();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.BPF = BPFMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.Path = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.Flags = decoder.int32();\n          break;\n        }\n        case 8: {\n          obj.ReturnCode = decoder.int32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionDisk\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.BPF != null) {\n      const f: BPFMetadata = this.BPF as BPFMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Path.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Path.length) + this.Path.length\n        : 0;\n    size += this.Flags == 0 ? 0 : 1 + __proto.Sizer.int32(this.Flags);\n    size += this.ReturnCode == 0 ? 0 : 1 + __proto.Sizer.int32(this.ReturnCode);\n\n    return size;\n  }\n\n  // Encodes SessionDisk to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionDisk to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.BPF != null) {\n      const f = this.BPF as BPFMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Path.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.Path.length);\n      encoder.string(this.Path);\n    }\n    if (this.Flags != 0) {\n      encoder.uint32(0x38);\n      encoder.int32(this.Flags);\n    }\n    if (this.ReturnCode != 0) {\n      encoder.uint32(0x40);\n      encoder.int32(this.ReturnCode);\n    }\n\n    return buf;\n  } // encode SessionDisk\n} // SessionDisk\n\n// SessionNetwork is a network event\nexport class SessionNetwork {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // BPFMetadata is a common BPF subsystem metadata\n  public BPF: BPFMetadata = new BPFMetadata();\n  // SrcAddr is the source IP address of the connection.\n  public SrcAddr: string = \"\";\n  // DstAddr is the destination IP address of the connection.\n  public DstAddr: string = \"\";\n  // DstPort is the destination port of the connection.\n  public DstPort: i32;\n  // TCPVersion is the version of TCP (4 or 6).\n  public TCPVersion: i32;\n  // Operation denotes what network operation was performed (e.g. connect)\n  public Operation: u32;\n  // Action denotes what happened in response to the event\n  public Action: u32;\n\n  // Decodes SessionNetwork from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionNetwork {\n    return SessionNetwork.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionNetwork from a DataView\n  static decodeDataView(view: DataView): SessionNetwork {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionNetwork();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.BPF = BPFMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.SrcAddr = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.DstAddr = decoder.string();\n          break;\n        }\n        case 8: {\n          obj.DstPort = decoder.int32();\n          break;\n        }\n        case 9: {\n          obj.TCPVersion = decoder.int32();\n          break;\n        }\n        case 10: {\n          obj.Operation = decoder.uint32();\n          break;\n        }\n        case 11: {\n          obj.Action = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionNetwork\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.BPF != null) {\n      const f: BPFMetadata = this.BPF as BPFMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.SrcAddr.length > 0\n        ? 1 + __proto.Sizer.varint64(this.SrcAddr.length) + this.SrcAddr.length\n        : 0;\n    size +=\n      this.DstAddr.length > 0\n        ? 1 + __proto.Sizer.varint64(this.DstAddr.length) + this.DstAddr.length\n        : 0;\n    size += this.DstPort == 0 ? 0 : 1 + __proto.Sizer.int32(this.DstPort);\n    size += this.TCPVersion == 0 ? 0 : 1 + __proto.Sizer.int32(this.TCPVersion);\n    size += this.Operation == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Operation);\n    size += this.Action == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Action);\n\n    return size;\n  }\n\n  // Encodes SessionNetwork to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionNetwork to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.BPF != null) {\n      const f = this.BPF as BPFMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SrcAddr.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.SrcAddr.length);\n      encoder.string(this.SrcAddr);\n    }\n    if (this.DstAddr.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.DstAddr.length);\n      encoder.string(this.DstAddr);\n    }\n    if (this.DstPort != 0) {\n      encoder.uint32(0x40);\n      encoder.int32(this.DstPort);\n    }\n    if (this.TCPVersion != 0) {\n      encoder.uint32(0x48);\n      encoder.int32(this.TCPVersion);\n    }\n    if (this.Operation != 0) {\n      encoder.uint32(0x50);\n      encoder.uint32(this.Operation);\n    }\n    if (this.Action != 0) {\n      encoder.uint32(0x58);\n      encoder.uint32(this.Action);\n    }\n\n    return buf;\n  } // encode SessionNetwork\n} // SessionNetwork\n\n// Operation is the network operation that was performed or attempted\nexport enum SessionNetwork_NetworkOperation {\n  // TCP connection establishment or binding a UDP socket to a remote address\n  CONNECT = 0,\n  // Transmission of data to a remote endpoint\n  SEND = 1,\n} // SessionNetwork_NetworkOperation\n// SessionData is emitted to report session data usage.\nexport class SessionData {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // BytesTransmitted is the amount of bytes transmitted\n  public BytesTransmitted: u64;\n  // BytesReceived is the amount of bytes received\n  public BytesReceived: u64;\n\n  // Decodes SessionData from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionData {\n    return SessionData.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionData from a DataView\n  static decodeDataView(view: DataView): SessionData {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionData();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.BytesTransmitted = decoder.uint64();\n          break;\n        }\n        case 7: {\n          obj.BytesReceived = decoder.uint64();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionData\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.BytesTransmitted == 0\n        ? 0\n        : 1 + __proto.Sizer.uint64(this.BytesTransmitted);\n    size +=\n      this.BytesReceived == 0\n        ? 0\n        : 1 + __proto.Sizer.uint64(this.BytesReceived);\n\n    return size;\n  }\n\n  // Encodes SessionData to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionData to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.BytesTransmitted != 0) {\n      encoder.uint32(0x30);\n      encoder.uint64(this.BytesTransmitted);\n    }\n    if (this.BytesReceived != 0) {\n      encoder.uint32(0x38);\n      encoder.uint64(this.BytesReceived);\n    }\n\n    return buf;\n  } // encode SessionData\n} // SessionData\n\n// SessionLeave is emitted to report that a user left the session\nexport class SessionLeave {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n\n  // Decodes SessionLeave from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionLeave {\n    return SessionLeave.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionLeave from a DataView\n  static decodeDataView(view: DataView): SessionLeave {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionLeave();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionLeave\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SessionLeave to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionLeave to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SessionLeave\n} // SessionLeave\n\n// UserLogin records a successfull or failed user login event\nexport class UserLogin {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // Status contains common command or operation status fields\n  public Status: Status = new Status();\n  // Method is the event field indicating how the login was performed\n  public Method: string = \"\";\n  // IdentityAttributes is a map of user attributes received from identity provider\n  public IdentityAttributes: google.protobuf.Struct =\n    new google.protobuf.Struct();\n  // MFA is the MFA device used during the login.\n  public MFADevice: MFADeviceMetadata = new MFADeviceMetadata();\n\n  // Decodes UserLogin from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserLogin {\n    return UserLogin.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserLogin from a DataView\n  static decodeDataView(view: DataView): UserLogin {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserLogin();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Status = Status.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.Method = decoder.string();\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.IdentityAttributes = google.protobuf.Struct.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.MFADevice = MFADeviceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserLogin\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Status != null) {\n      const f: Status = this.Status as Status;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Method.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Method.length) + this.Method.length\n        : 0;\n\n    if (this.IdentityAttributes != null) {\n      const f: google.protobuf.Struct = this\n        .IdentityAttributes as google.protobuf.Struct;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.MFADevice != null) {\n      const f: MFADeviceMetadata = this.MFADevice as MFADeviceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes UserLogin to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserLogin to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Status != null) {\n      const f = this.Status as Status;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Method.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.Method.length);\n      encoder.string(this.Method);\n    }\n\n    if (this.IdentityAttributes != null) {\n      const f = this.IdentityAttributes as google.protobuf.Struct;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.MFADevice != null) {\n      const f = this.MFADevice as MFADeviceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode UserLogin\n} // UserLogin\n\n// ResourceMetadata is a common resource metadata\nexport class ResourceMetadata {\n  // ResourceName is a resource name\n  public Name: string = \"\";\n  // Expires is set if resource expires\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // UpdatedBy if set indicates the user who modified the resource\n  public UpdatedBy: string = \"\";\n  /**\n   * TTL is a TTL of reset password token represented as duration, e.g. \"10m\"\n   *  used for compatibility purposes for some events, Expires should be used instead\n   *  as it's more useful (contains exact expiration date/time)\n   */\n  public TTL: string = \"\";\n\n  // Decodes ResourceMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ResourceMetadata {\n    return ResourceMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ResourceMetadata from a DataView\n  static decodeDataView(view: DataView): ResourceMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ResourceMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          obj.UpdatedBy = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.TTL = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ResourceMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.UpdatedBy.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.UpdatedBy.length) +\n          this.UpdatedBy.length\n        : 0;\n    size +=\n      this.TTL.length > 0\n        ? 1 + __proto.Sizer.varint64(this.TTL.length) + this.TTL.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ResourceMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ResourceMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.UpdatedBy.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.UpdatedBy.length);\n      encoder.string(this.UpdatedBy);\n    }\n    if (this.TTL.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.TTL.length);\n      encoder.string(this.TTL);\n    }\n\n    return buf;\n  } // encode ResourceMetadata\n} // ResourceMetadata\n\n// UserCreate is emitted when the user is created or updated (upsert).\nexport class UserCreate {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // Roles is a list of roles for the user.\n  public Roles: Array<string> = new Array<string>();\n  // Connector is the connector used to create the user.\n  public Connector: string = \"\";\n\n  // Decodes UserCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserCreate {\n    return UserCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserCreate from a DataView\n  static decodeDataView(view: DataView): UserCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 5: {\n          obj.Connector = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.Roles);\n\n    size +=\n      this.Connector.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Connector.length) +\n          this.Connector.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes UserCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x22);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    if (this.Connector.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.Connector.length);\n      encoder.string(this.Connector);\n    }\n\n    return buf;\n  } // encode UserCreate\n} // UserCreate\n\n// UserDelete is emitted when a user gets deleted\nexport class UserDelete {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n\n  // Decodes UserDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserDelete {\n    return UserDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserDelete from a DataView\n  static decodeDataView(view: DataView): UserDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes UserDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode UserDelete\n} // UserDelete\n\n// UserPasswordChange is emitted when the user changes their own password.\nexport class UserPasswordChange {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes UserPasswordChange from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserPasswordChange {\n    return UserPasswordChange.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserPasswordChange from a DataView\n  static decodeDataView(view: DataView): UserPasswordChange {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserPasswordChange();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserPasswordChange\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes UserPasswordChange to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserPasswordChange to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode UserPasswordChange\n} // UserPasswordChange\n\n// AccessRequestCreate is emitted when access request has been created or updated\nexport class AccessRequestCreate {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // Roles is a list of roles for the user.\n  public Roles: Array<string> = new Array<string>();\n  // RequestID is access request ID\n  public RequestID: string = \"\";\n  /**\n   * RequestState is access request state (in the access_request.review variant of\n   *  the event this represents the post-review state of the request).\n   */\n  public RequestState: string = \"\";\n  /**\n   * Delegator is used by teleport plugins to indicate the identity\n   *  which caused them to update state.\n   */\n  public Delegator: string = \"\";\n  /**\n   * Reason is an optional description of why the request is being\n   *  created or updated.\n   */\n  public Reason: string = \"\";\n  /**\n   * Annotations is an optional set of attributes supplied by a plugin during\n   *  approval/denail of the request.\n   */\n  public Annotations: google.protobuf.Struct = new google.protobuf.Struct();\n  // Reviewer is the author of the review (only used in the access_request.review event variant).\n  public Reviewer: string = \"\";\n  /**\n   * ProposedState is the state proposed by a review (only used in the access_request.review event\n   *  variant).\n   */\n  public ProposedState: string = \"\";\n\n  // Decodes AccessRequestCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessRequestCreate {\n    return AccessRequestCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessRequestCreate from a DataView\n  static decodeDataView(view: DataView): AccessRequestCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessRequestCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 5: {\n          obj.RequestID = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.RequestState = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.Delegator = decoder.string();\n          break;\n        }\n        case 8: {\n          obj.Reason = decoder.string();\n          break;\n        }\n        case 9: {\n          const length = decoder.uint32();\n          obj.Annotations = google.protobuf.Struct.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 10: {\n          obj.Reviewer = decoder.string();\n          break;\n        }\n        case 11: {\n          obj.ProposedState = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessRequestCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.Roles);\n\n    size +=\n      this.RequestID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RequestID.length) +\n          this.RequestID.length\n        : 0;\n    size +=\n      this.RequestState.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RequestState.length) +\n          this.RequestState.length\n        : 0;\n    size +=\n      this.Delegator.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Delegator.length) +\n          this.Delegator.length\n        : 0;\n    size +=\n      this.Reason.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Reason.length) + this.Reason.length\n        : 0;\n\n    if (this.Annotations != null) {\n      const f: google.protobuf.Struct = this\n        .Annotations as google.protobuf.Struct;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Reviewer.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Reviewer.length) +\n          this.Reviewer.length\n        : 0;\n    size +=\n      this.ProposedState.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ProposedState.length) +\n          this.ProposedState.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes AccessRequestCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessRequestCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x22);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    if (this.RequestID.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.RequestID.length);\n      encoder.string(this.RequestID);\n    }\n    if (this.RequestState.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.RequestState.length);\n      encoder.string(this.RequestState);\n    }\n    if (this.Delegator.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.Delegator.length);\n      encoder.string(this.Delegator);\n    }\n    if (this.Reason.length > 0) {\n      encoder.uint32(0x42);\n      encoder.uint32(this.Reason.length);\n      encoder.string(this.Reason);\n    }\n\n    if (this.Annotations != null) {\n      const f = this.Annotations as google.protobuf.Struct;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x4a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Reviewer.length > 0) {\n      encoder.uint32(0x52);\n      encoder.uint32(this.Reviewer.length);\n      encoder.string(this.Reviewer);\n    }\n    if (this.ProposedState.length > 0) {\n      encoder.uint32(0x5a);\n      encoder.uint32(this.ProposedState.length);\n      encoder.string(this.ProposedState);\n    }\n\n    return buf;\n  } // encode AccessRequestCreate\n} // AccessRequestCreate\n\n// AccessRequestDelete is emitted when an access request has been deleted.\nexport class AccessRequestDelete {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // RequestID is access request ID\n  public RequestID: string = \"\";\n\n  // Decodes AccessRequestDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AccessRequestDelete {\n    return AccessRequestDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AccessRequestDelete from a DataView\n  static decodeDataView(view: DataView): AccessRequestDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AccessRequestDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          obj.RequestID = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AccessRequestDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.RequestID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RequestID.length) +\n          this.RequestID.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes AccessRequestDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AccessRequestDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RequestID.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.RequestID.length);\n      encoder.string(this.RequestID);\n    }\n\n    return buf;\n  } // encode AccessRequestDelete\n} // AccessRequestDelete\n\n// PortForward is emitted when a user requests port forwarding.\nexport class PortForward {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // Status contains operation success or failure status\n  public Status: Status = new Status();\n  // Addr is a target port forwarding address\n  public Addr: string = \"\";\n\n  // Decodes PortForward from an ArrayBuffer\n  static decode(buf: ArrayBuffer): PortForward {\n    return PortForward.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes PortForward from a DataView\n  static decodeDataView(view: DataView): PortForward {\n    const decoder = new __proto.Decoder(view);\n    const obj = new PortForward();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Status = Status.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.Addr = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode PortForward\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Status != null) {\n      const f: Status = this.Status as Status;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Addr.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Addr.length) + this.Addr.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes PortForward to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes PortForward to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Status != null) {\n      const f = this.Status as Status;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Addr.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.Addr.length);\n      encoder.string(this.Addr);\n    }\n\n    return buf;\n  } // encode PortForward\n} // PortForward\n\n// X11Forward is emitted when a user requests X11 protocol forwarding\nexport class X11Forward {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // Status contains operation success or failure status\n  public Status: Status = new Status();\n\n  // Decodes X11Forward from an ArrayBuffer\n  static decode(buf: ArrayBuffer): X11Forward {\n    return X11Forward.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes X11Forward from a DataView\n  static decodeDataView(view: DataView): X11Forward {\n    const decoder = new __proto.Decoder(view);\n    const obj = new X11Forward();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Status = Status.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode X11Forward\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Status != null) {\n      const f: Status = this.Status as Status;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes X11Forward to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes X11Forward to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Status != null) {\n      const f = this.Status as Status;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode X11Forward\n} // X11Forward\n\n// CommandMetadata specifies common command fields\nexport class CommandMetadata {\n  // Command is the executed command name\n  public Command: string = \"\";\n  // ExitCode specifies command exit code\n  public ExitCode: string = \"\";\n  // Error is an optional exit error, set if command has failed\n  public Error: string = \"\";\n\n  // Decodes CommandMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): CommandMetadata {\n    return CommandMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes CommandMetadata from a DataView\n  static decodeDataView(view: DataView): CommandMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new CommandMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Command = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.ExitCode = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Error = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode CommandMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Command.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Command.length) + this.Command.length\n        : 0;\n    size +=\n      this.ExitCode.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ExitCode.length) +\n          this.ExitCode.length\n        : 0;\n    size +=\n      this.Error.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Error.length) + this.Error.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes CommandMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes CommandMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Command.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Command.length);\n      encoder.string(this.Command);\n    }\n    if (this.ExitCode.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.ExitCode.length);\n      encoder.string(this.ExitCode);\n    }\n    if (this.Error.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Error.length);\n      encoder.string(this.Error);\n    }\n\n    return buf;\n  } // encode CommandMetadata\n} // CommandMetadata\n\n// Exec specifies command exec event\nexport class Exec {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // CommandMetadata is a common command metadata\n  public Command: CommandMetadata = new CommandMetadata();\n  /**\n   * KubernetesCluster has information about a kubernetes cluster, if\n   *  applicable.\n   */\n  public KubernetesCluster: KubernetesClusterMetadata =\n    new KubernetesClusterMetadata();\n  // KubernetesPod has information about a kubernetes pod, if applicable.\n  public KubernetesPod: KubernetesPodMetadata = new KubernetesPodMetadata();\n\n  // Decodes Exec from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Exec {\n    return Exec.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Exec from a DataView\n  static decodeDataView(view: DataView): Exec {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Exec();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.Command = CommandMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.KubernetesCluster = KubernetesClusterMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.KubernetesPod = KubernetesPodMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Exec\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Command != null) {\n      const f: CommandMetadata = this.Command as CommandMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.KubernetesCluster != null) {\n      const f: KubernetesClusterMetadata = this\n        .KubernetesCluster as KubernetesClusterMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.KubernetesPod != null) {\n      const f: KubernetesPodMetadata = this\n        .KubernetesPod as KubernetesPodMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes Exec to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Exec to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Command != null) {\n      const f = this.Command as CommandMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubernetesCluster != null) {\n      const f = this.KubernetesCluster as KubernetesClusterMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubernetesPod != null) {\n      const f = this.KubernetesPod as KubernetesPodMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode Exec\n} // Exec\n\n// SCP is emitted when data transfer has occurred between server and client\nexport class SCP {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // CommandMetadata is a common command metadata\n  public Command: CommandMetadata = new CommandMetadata();\n  // Path is a copy path\n  public Path: string = \"\";\n  // Action is upload or download\n  public Action: string = \"\";\n\n  // Decodes SCP from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SCP {\n    return SCP.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SCP from a DataView\n  static decodeDataView(view: DataView): SCP {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SCP();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.Command = CommandMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          obj.Path = decoder.string();\n          break;\n        }\n        case 8: {\n          obj.Action = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SCP\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Command != null) {\n      const f: CommandMetadata = this.Command as CommandMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Path.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Path.length) + this.Path.length\n        : 0;\n    size +=\n      this.Action.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Action.length) + this.Action.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes SCP to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SCP to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Command != null) {\n      const f = this.Command as CommandMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Path.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.Path.length);\n      encoder.string(this.Path);\n    }\n    if (this.Action.length > 0) {\n      encoder.uint32(0x42);\n      encoder.uint32(this.Action.length);\n      encoder.string(this.Action);\n    }\n\n    return buf;\n  } // encode SCP\n} // SCP\n\n// Subsystem is emitted when a user requests a new subsystem.\nexport class Subsystem {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // Name is a subsystem name\n  public Name: string = \"\";\n  // Error contains error in case of unsucessfull attempt\n  public Error: string = \"\";\n\n  // Decodes Subsystem from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Subsystem {\n    return Subsystem.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Subsystem from a DataView\n  static decodeDataView(view: DataView): Subsystem {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Subsystem();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.Error = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Subsystem\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.Error.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Error.length) + this.Error.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes Subsystem to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Subsystem to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.Error.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.Error.length);\n      encoder.string(this.Error);\n    }\n\n    return buf;\n  } // encode Subsystem\n} // Subsystem\n\n/**\n * ClientDisconnect is emitted when client is disconnected\n *  by the server due to inactivity or any other reason\n */\nexport class ClientDisconnect {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  /**\n   * Reason is a field that specifies reason for event, e.g. in disconnect\n   *  event it explains why server disconnected the client\n   */\n  public Reason: string = \"\";\n\n  // Decodes ClientDisconnect from an ArrayBuffer\n  static decode(buf: ArrayBuffer): ClientDisconnect {\n    return ClientDisconnect.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes ClientDisconnect from a DataView\n  static decodeDataView(view: DataView): ClientDisconnect {\n    const decoder = new __proto.Decoder(view);\n    const obj = new ClientDisconnect();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.Reason = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode ClientDisconnect\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Reason.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Reason.length) + this.Reason.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes ClientDisconnect to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes ClientDisconnect to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Reason.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.Reason.length);\n      encoder.string(this.Reason);\n    }\n\n    return buf;\n  } // encode ClientDisconnect\n} // ClientDisconnect\n\n// AuthAttempt is emitted upon a failed or successfull authentication attempt.\nexport class AuthAttempt {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // Status contains common command or operation status fields\n  public Status: Status = new Status();\n\n  // Decodes AuthAttempt from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AuthAttempt {\n    return AuthAttempt.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AuthAttempt from a DataView\n  static decodeDataView(view: DataView): AuthAttempt {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AuthAttempt();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Status = Status.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AuthAttempt\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Status != null) {\n      const f: Status = this.Status as Status;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AuthAttempt to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AuthAttempt to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Status != null) {\n      const f = this.Status as Status;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AuthAttempt\n} // AuthAttempt\n\n// UserTokenCreate is emitted when a user token is created.\nexport class UserTokenCreate {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes UserTokenCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): UserTokenCreate {\n    return UserTokenCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes UserTokenCreate from a DataView\n  static decodeDataView(view: DataView): UserTokenCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new UserTokenCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode UserTokenCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes UserTokenCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes UserTokenCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode UserTokenCreate\n} // UserTokenCreate\n\n// RoleCreate is emitted when a role is created/updated.\nexport class RoleCreate {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes RoleCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RoleCreate {\n    return RoleCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RoleCreate from a DataView\n  static decodeDataView(view: DataView): RoleCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RoleCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RoleCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RoleCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RoleCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RoleCreate\n} // RoleCreate\n\n// RoleDelete is emitted when a role is deleted\nexport class RoleDelete {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes RoleDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RoleDelete {\n    return RoleDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RoleDelete from a DataView\n  static decodeDataView(view: DataView): RoleDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RoleDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RoleDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RoleDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RoleDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RoleDelete\n} // RoleDelete\n\n// TrustedClusterCreate is the event for creating a trusted cluster.\nexport class TrustedClusterCreate {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes TrustedClusterCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TrustedClusterCreate {\n    return TrustedClusterCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TrustedClusterCreate from a DataView\n  static decodeDataView(view: DataView): TrustedClusterCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TrustedClusterCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TrustedClusterCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes TrustedClusterCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TrustedClusterCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode TrustedClusterCreate\n} // TrustedClusterCreate\n\n// TrustedClusterDelete is the event for removing a trusted cluster.\nexport class TrustedClusterDelete {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes TrustedClusterDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TrustedClusterDelete {\n    return TrustedClusterDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TrustedClusterDelete from a DataView\n  static decodeDataView(view: DataView): TrustedClusterDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TrustedClusterDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TrustedClusterDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes TrustedClusterDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TrustedClusterDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode TrustedClusterDelete\n} // TrustedClusterDelete\n\n/**\n * TrustedClusterTokenCreate is the event for\n *  creating new join token for a trusted cluster.\n */\nexport class TrustedClusterTokenCreate {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes TrustedClusterTokenCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): TrustedClusterTokenCreate {\n    return TrustedClusterTokenCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes TrustedClusterTokenCreate from a DataView\n  static decodeDataView(view: DataView): TrustedClusterTokenCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new TrustedClusterTokenCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode TrustedClusterTokenCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes TrustedClusterTokenCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes TrustedClusterTokenCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode TrustedClusterTokenCreate\n} // TrustedClusterTokenCreate\n\n// GithubConnectorCreate fires when a Github connector is created/updated.\nexport class GithubConnectorCreate {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes GithubConnectorCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): GithubConnectorCreate {\n    return GithubConnectorCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes GithubConnectorCreate from a DataView\n  static decodeDataView(view: DataView): GithubConnectorCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new GithubConnectorCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode GithubConnectorCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes GithubConnectorCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes GithubConnectorCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode GithubConnectorCreate\n} // GithubConnectorCreate\n\n// GithubConnectorDelete fires when a Github connector is deleted.\nexport class GithubConnectorDelete {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes GithubConnectorDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): GithubConnectorDelete {\n    return GithubConnectorDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes GithubConnectorDelete from a DataView\n  static decodeDataView(view: DataView): GithubConnectorDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new GithubConnectorDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode GithubConnectorDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes GithubConnectorDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes GithubConnectorDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode GithubConnectorDelete\n} // GithubConnectorDelete\n\n// OIDCConnectorCreate fires when OIDC connector is created/updated.\nexport class OIDCConnectorCreate {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes OIDCConnectorCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): OIDCConnectorCreate {\n    return OIDCConnectorCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes OIDCConnectorCreate from a DataView\n  static decodeDataView(view: DataView): OIDCConnectorCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new OIDCConnectorCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode OIDCConnectorCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes OIDCConnectorCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes OIDCConnectorCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode OIDCConnectorCreate\n} // OIDCConnectorCreate\n\n// OIDCConnectorDelete fires when OIDC connector is deleted.\nexport class OIDCConnectorDelete {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes OIDCConnectorDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): OIDCConnectorDelete {\n    return OIDCConnectorDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes OIDCConnectorDelete from a DataView\n  static decodeDataView(view: DataView): OIDCConnectorDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new OIDCConnectorDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode OIDCConnectorDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes OIDCConnectorDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes OIDCConnectorDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode OIDCConnectorDelete\n} // OIDCConnectorDelete\n\n// SAMLConnectorCreate fires when SAML connector is created/updated.\nexport class SAMLConnectorCreate {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes SAMLConnectorCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SAMLConnectorCreate {\n    return SAMLConnectorCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SAMLConnectorCreate from a DataView\n  static decodeDataView(view: DataView): SAMLConnectorCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SAMLConnectorCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SAMLConnectorCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SAMLConnectorCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SAMLConnectorCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SAMLConnectorCreate\n} // SAMLConnectorCreate\n\n// SAMLConnectorDelete fires when SAML connector is deleted.\nexport class SAMLConnectorDelete {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes SAMLConnectorDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SAMLConnectorDelete {\n    return SAMLConnectorDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SAMLConnectorDelete from a DataView\n  static decodeDataView(view: DataView): SAMLConnectorDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SAMLConnectorDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SAMLConnectorDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes SAMLConnectorDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SAMLConnectorDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode SAMLConnectorDelete\n} // SAMLConnectorDelete\n\n// KubeRequest specifies a Kubernetes API request event.\nexport class KubeRequest {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // RequestPath is the raw request URL path.\n  public RequestPath: string = \"\";\n  // Verb is the HTTP verb used for this request (e.g. GET, POST, etc)\n  public Verb: string = \"\";\n  // ResourceAPIGroup is the resource API group.\n  public ResourceAPIGroup: string = \"\";\n  // ResourceNamespace is the resource namespace.\n  public ResourceNamespace: string = \"\";\n  // ResourceKind is the API resource kind (e.g. \"pod\", \"service\", etc).\n  public ResourceKind: string = \"\";\n  // ResourceName is the API resource name.\n  public ResourceName: string = \"\";\n  // ResponseCode is the HTTP response code for this request.\n  public ResponseCode: i32;\n  // Kubernetes has information about a kubernetes cluster, if applicable.\n  public Kubernetes: KubernetesClusterMetadata =\n    new KubernetesClusterMetadata();\n\n  // Decodes KubeRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): KubeRequest {\n    return KubeRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes KubeRequest from a DataView\n  static decodeDataView(view: DataView): KubeRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new KubeRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.RequestPath = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.Verb = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.ResourceAPIGroup = decoder.string();\n          break;\n        }\n        case 8: {\n          obj.ResourceNamespace = decoder.string();\n          break;\n        }\n        case 9: {\n          obj.ResourceKind = decoder.string();\n          break;\n        }\n        case 10: {\n          obj.ResourceName = decoder.string();\n          break;\n        }\n        case 11: {\n          obj.ResponseCode = decoder.int32();\n          break;\n        }\n        case 12: {\n          const length = decoder.uint32();\n          obj.Kubernetes = KubernetesClusterMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode KubeRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.RequestPath.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RequestPath.length) +\n          this.RequestPath.length\n        : 0;\n    size +=\n      this.Verb.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Verb.length) + this.Verb.length\n        : 0;\n    size +=\n      this.ResourceAPIGroup.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ResourceAPIGroup.length) +\n          this.ResourceAPIGroup.length\n        : 0;\n    size +=\n      this.ResourceNamespace.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ResourceNamespace.length) +\n          this.ResourceNamespace.length\n        : 0;\n    size +=\n      this.ResourceKind.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ResourceKind.length) +\n          this.ResourceKind.length\n        : 0;\n    size +=\n      this.ResourceName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ResourceName.length) +\n          this.ResourceName.length\n        : 0;\n    size +=\n      this.ResponseCode == 0 ? 0 : 1 + __proto.Sizer.int32(this.ResponseCode);\n\n    if (this.Kubernetes != null) {\n      const f: KubernetesClusterMetadata = this\n        .Kubernetes as KubernetesClusterMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes KubeRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes KubeRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RequestPath.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.RequestPath.length);\n      encoder.string(this.RequestPath);\n    }\n    if (this.Verb.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.Verb.length);\n      encoder.string(this.Verb);\n    }\n    if (this.ResourceAPIGroup.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.ResourceAPIGroup.length);\n      encoder.string(this.ResourceAPIGroup);\n    }\n    if (this.ResourceNamespace.length > 0) {\n      encoder.uint32(0x42);\n      encoder.uint32(this.ResourceNamespace.length);\n      encoder.string(this.ResourceNamespace);\n    }\n    if (this.ResourceKind.length > 0) {\n      encoder.uint32(0x4a);\n      encoder.uint32(this.ResourceKind.length);\n      encoder.string(this.ResourceKind);\n    }\n    if (this.ResourceName.length > 0) {\n      encoder.uint32(0x52);\n      encoder.uint32(this.ResourceName.length);\n      encoder.string(this.ResourceName);\n    }\n    if (this.ResponseCode != 0) {\n      encoder.uint32(0x58);\n      encoder.int32(this.ResponseCode);\n    }\n\n    if (this.Kubernetes != null) {\n      const f = this.Kubernetes as KubernetesClusterMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x62);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode KubeRequest\n} // KubeRequest\n\n// AppMetadata contains common application information.\nexport class AppMetadata {\n  // AppURI is the application endpoint.\n  public AppURI: string = \"\";\n  // AppPublicAddr is the configured application public address.\n  public AppPublicAddr: string = \"\";\n  // AppLabels are the configured application labels.\n  public AppLabels: Map<string, string> = new Map<string, string>();\n  // AppName is the configured application name.\n  public AppName: string = \"\";\n\n  // Decodes AppMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppMetadata {\n    return AppMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppMetadata from a DataView\n  static decodeDataView(view: DataView): AppMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.AppURI = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.AppPublicAddr = decoder.string();\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.AppLabels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.AppName = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.AppURI.length > 0\n        ? 1 + __proto.Sizer.varint64(this.AppURI.length) + this.AppURI.length\n        : 0;\n    size +=\n      this.AppPublicAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.AppPublicAddr.length) +\n          this.AppPublicAddr.length\n        : 0;\n\n    if (this.AppLabels.size > 0) {\n      const keys = this.AppLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.AppLabels.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    size +=\n      this.AppName.length > 0\n        ? 1 + __proto.Sizer.varint64(this.AppName.length) + this.AppName.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes AppMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.AppURI.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.AppURI.length);\n      encoder.string(this.AppURI);\n    }\n    if (this.AppPublicAddr.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.AppPublicAddr.length);\n      encoder.string(this.AppPublicAddr);\n    }\n\n    if (this.AppLabels.size > 0) {\n      const keys = this.AppLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.AppLabels.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0x1a);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    if (this.AppName.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.AppName.length);\n      encoder.string(this.AppName);\n    }\n\n    return buf;\n  } // encode AppMetadata\n} // AppMetadata\n\n// AppCreate is emitted when a new application resource is created.\nexport class AppCreate {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // ResourceMetadata is a common resource event metadata.\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // AppMetadata is a common application resource metadata.\n  public App: AppMetadata = new AppMetadata();\n\n  // Decodes AppCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppCreate {\n    return AppCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppCreate from a DataView\n  static decodeDataView(view: DataView): AppCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.App = AppMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.App != null) {\n      const f: AppMetadata = this.App as AppMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AppCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.App != null) {\n      const f = this.App as AppMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AppCreate\n} // AppCreate\n\n// AppUpdate is emitted when an existing application resource is updated.\nexport class AppUpdate {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // ResourceMetadata is a common resource event metadata.\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // AppMetadata is a common application resource metadata.\n  public App: AppMetadata = new AppMetadata();\n\n  // Decodes AppUpdate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppUpdate {\n    return AppUpdate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppUpdate from a DataView\n  static decodeDataView(view: DataView): AppUpdate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppUpdate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.App = AppMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppUpdate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.App != null) {\n      const f: AppMetadata = this.App as AppMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AppUpdate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppUpdate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.App != null) {\n      const f = this.App as AppMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AppUpdate\n} // AppUpdate\n\n// AppDelete is emitted when an application resource is deleted.\nexport class AppDelete {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // ResourceMetadata is a common resource event metadata.\n  public Resource: ResourceMetadata = new ResourceMetadata();\n\n  // Decodes AppDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppDelete {\n    return AppDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppDelete from a DataView\n  static decodeDataView(view: DataView): AppDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AppDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AppDelete\n} // AppDelete\n\n// AppSessionStart is emitted when a user is issued an application certificate.\nexport class AppSessionStart {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  /**\n   * PublicAddr is the public address of the application being requested.\n   *  DELETE IN 10.0: this information is also present on the AppMetadata.\n   */\n  public PublicAddr: string = \"\";\n  // App is a common application resource metadata.\n  public App: AppMetadata = new AppMetadata();\n\n  // Decodes AppSessionStart from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppSessionStart {\n    return AppSessionStart.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppSessionStart from a DataView\n  static decodeDataView(view: DataView): AppSessionStart {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppSessionStart();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          obj.PublicAddr = decoder.string();\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.App = AppMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppSessionStart\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.PublicAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PublicAddr.length) +\n          this.PublicAddr.length\n        : 0;\n\n    if (this.App != null) {\n      const f: AppMetadata = this.App as AppMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AppSessionStart to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppSessionStart to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.PublicAddr.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.PublicAddr.length);\n      encoder.string(this.PublicAddr);\n    }\n\n    if (this.App != null) {\n      const f = this.App as AppMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AppSessionStart\n} // AppSessionStart\n\n/**\n * AppSessionChunk is emitted at the start of a 5 minute chunk on each\n *  proxy. This chunk is used to buffer 5 minutes of audit events at a time\n *  for applications.\n */\nexport class AppSessionChunk {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata\n  public Session: SessionMetadata = new SessionMetadata();\n  // ServerMetadata is a common server metadata\n  public Server: ServerMetadata = new ServerMetadata();\n  // ConnectionMetadata holds information about the connection\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  /**\n   * SessionChunkID is the ID of the session that was created for this 5 minute\n   *  application log chunk.\n   */\n  public SessionChunkID: string = \"\";\n  // App is a common application resource metadata.\n  public App: AppMetadata = new AppMetadata();\n\n  // Decodes AppSessionChunk from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppSessionChunk {\n    return AppSessionChunk.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppSessionChunk from a DataView\n  static decodeDataView(view: DataView): AppSessionChunk {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppSessionChunk();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.SessionChunkID = decoder.string();\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.App = AppMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppSessionChunk\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.SessionChunkID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SessionChunkID.length) +\n          this.SessionChunkID.length\n        : 0;\n\n    if (this.App != null) {\n      const f: AppMetadata = this.App as AppMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AppSessionChunk to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppSessionChunk to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionChunkID.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.SessionChunkID.length);\n      encoder.string(this.SessionChunkID);\n    }\n\n    if (this.App != null) {\n      const f = this.App as AppMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AppSessionChunk\n} // AppSessionChunk\n\n// AppSessionRequest is an HTTP request and response.\nexport class AppSessionRequest {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // StatusCode the HTTP response code for the request.\n  public StatusCode: u32;\n  // Path is relative path in the URL.\n  public Path: string = \"\";\n  // RawQuery are the encoded query values.\n  public RawQuery: string = \"\";\n  // Method is the request HTTP method, like GET/POST/DELETE/etc.\n  public Method: string = \"\";\n  // App is a common application resource metadata.\n  public App: AppMetadata = new AppMetadata();\n\n  // Decodes AppSessionRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): AppSessionRequest {\n    return AppSessionRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes AppSessionRequest from a DataView\n  static decodeDataView(view: DataView): AppSessionRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new AppSessionRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          obj.StatusCode = decoder.uint32();\n          break;\n        }\n        case 3: {\n          obj.Path = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.RawQuery = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.Method = decoder.string();\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.App = AppMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode AppSessionRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.StatusCode == 0 ? 0 : 1 + __proto.Sizer.uint32(this.StatusCode);\n    size +=\n      this.Path.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Path.length) + this.Path.length\n        : 0;\n    size +=\n      this.RawQuery.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RawQuery.length) +\n          this.RawQuery.length\n        : 0;\n    size +=\n      this.Method.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Method.length) + this.Method.length\n        : 0;\n\n    if (this.App != null) {\n      const f: AppMetadata = this.App as AppMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes AppSessionRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes AppSessionRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.StatusCode != 0) {\n      encoder.uint32(0x10);\n      encoder.uint32(this.StatusCode);\n    }\n    if (this.Path.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Path.length);\n      encoder.string(this.Path);\n    }\n    if (this.RawQuery.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.RawQuery.length);\n      encoder.string(this.RawQuery);\n    }\n    if (this.Method.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.Method.length);\n      encoder.string(this.Method);\n    }\n\n    if (this.App != null) {\n      const f = this.App as AppMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode AppSessionRequest\n} // AppSessionRequest\n\n// DatabaseMetadata contains common database information.\nexport class DatabaseMetadata {\n  // DatabaseService is the name of the database service proxying the database.\n  public DatabaseService: string = \"\";\n  // DatabaseProtocol is the database type, e.g. postgres or mysql.\n  public DatabaseProtocol: string = \"\";\n  // DatabaseURI is the database URI to connect to.\n  public DatabaseURI: string = \"\";\n  // DatabaseName is the name of the database a user is connecting to.\n  public DatabaseName: string = \"\";\n  // DatabaseUser is the database username used to connect.\n  public DatabaseUser: string = \"\";\n  // DatabaseLabels is the database resource labels.\n  public DatabaseLabels: Map<string, string> = new Map<string, string>();\n  // DatabaseAWSRegion is AWS regions for AWS hosted databases.\n  public DatabaseAWSRegion: string = \"\";\n  // DatabaseAWSRegion is cluster ID for Redshift databases.\n  public DatabaseAWSRedshiftClusterID: string = \"\";\n  // DatabaseGCPProjectID is project ID for GCP hosted databases.\n  public DatabaseGCPProjectID: string = \"\";\n  // DatabaseGCPInstanceID is instance ID for GCP hosted databases.\n  public DatabaseGCPInstanceID: string = \"\";\n\n  // Decodes DatabaseMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseMetadata {\n    return DatabaseMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseMetadata from a DataView\n  static decodeDataView(view: DataView): DatabaseMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.DatabaseService = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.DatabaseProtocol = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.DatabaseURI = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.DatabaseName = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.DatabaseUser = decoder.string();\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.DatabaseLabels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          obj.DatabaseAWSRegion = decoder.string();\n          break;\n        }\n        case 8: {\n          obj.DatabaseAWSRedshiftClusterID = decoder.string();\n          break;\n        }\n        case 9: {\n          obj.DatabaseGCPProjectID = decoder.string();\n          break;\n        }\n        case 10: {\n          obj.DatabaseGCPInstanceID = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.DatabaseService.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DatabaseService.length) +\n          this.DatabaseService.length\n        : 0;\n    size +=\n      this.DatabaseProtocol.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DatabaseProtocol.length) +\n          this.DatabaseProtocol.length\n        : 0;\n    size +=\n      this.DatabaseURI.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DatabaseURI.length) +\n          this.DatabaseURI.length\n        : 0;\n    size +=\n      this.DatabaseName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DatabaseName.length) +\n          this.DatabaseName.length\n        : 0;\n    size +=\n      this.DatabaseUser.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DatabaseUser.length) +\n          this.DatabaseUser.length\n        : 0;\n\n    if (this.DatabaseLabels.size > 0) {\n      const keys = this.DatabaseLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DatabaseLabels.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    size +=\n      this.DatabaseAWSRegion.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DatabaseAWSRegion.length) +\n          this.DatabaseAWSRegion.length\n        : 0;\n    size +=\n      this.DatabaseAWSRedshiftClusterID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DatabaseAWSRedshiftClusterID.length) +\n          this.DatabaseAWSRedshiftClusterID.length\n        : 0;\n    size +=\n      this.DatabaseGCPProjectID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DatabaseGCPProjectID.length) +\n          this.DatabaseGCPProjectID.length\n        : 0;\n    size +=\n      this.DatabaseGCPInstanceID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DatabaseGCPInstanceID.length) +\n          this.DatabaseGCPInstanceID.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes DatabaseMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.DatabaseService.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.DatabaseService.length);\n      encoder.string(this.DatabaseService);\n    }\n    if (this.DatabaseProtocol.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.DatabaseProtocol.length);\n      encoder.string(this.DatabaseProtocol);\n    }\n    if (this.DatabaseURI.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.DatabaseURI.length);\n      encoder.string(this.DatabaseURI);\n    }\n    if (this.DatabaseName.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.DatabaseName.length);\n      encoder.string(this.DatabaseName);\n    }\n    if (this.DatabaseUser.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.DatabaseUser.length);\n      encoder.string(this.DatabaseUser);\n    }\n\n    if (this.DatabaseLabels.size > 0) {\n      const keys = this.DatabaseLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DatabaseLabels.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0x32);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    if (this.DatabaseAWSRegion.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.DatabaseAWSRegion.length);\n      encoder.string(this.DatabaseAWSRegion);\n    }\n    if (this.DatabaseAWSRedshiftClusterID.length > 0) {\n      encoder.uint32(0x42);\n      encoder.uint32(this.DatabaseAWSRedshiftClusterID.length);\n      encoder.string(this.DatabaseAWSRedshiftClusterID);\n    }\n    if (this.DatabaseGCPProjectID.length > 0) {\n      encoder.uint32(0x4a);\n      encoder.uint32(this.DatabaseGCPProjectID.length);\n      encoder.string(this.DatabaseGCPProjectID);\n    }\n    if (this.DatabaseGCPInstanceID.length > 0) {\n      encoder.uint32(0x52);\n      encoder.uint32(this.DatabaseGCPInstanceID.length);\n      encoder.string(this.DatabaseGCPInstanceID);\n    }\n\n    return buf;\n  } // encode DatabaseMetadata\n} // DatabaseMetadata\n\n// DatabaseCreate is emitted when a new database resource is created.\nexport class DatabaseCreate {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // ResourceMetadata is a common resource event metadata.\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // DatabaseMetadata is a common database resource metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n\n  // Decodes DatabaseCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseCreate {\n    return DatabaseCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseCreate from a DataView\n  static decodeDataView(view: DataView): DatabaseCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseCreate\n} // DatabaseCreate\n\n// DatabaseUpdate is emitted when an existing database resource is updated.\nexport class DatabaseUpdate {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // ResourceMetadata is a common resource event metadata.\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // DatabaseMetadata is a common database resource metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n\n  // Decodes DatabaseUpdate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseUpdate {\n    return DatabaseUpdate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseUpdate from a DataView\n  static decodeDataView(view: DataView): DatabaseUpdate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseUpdate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseUpdate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseUpdate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseUpdate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseUpdate\n} // DatabaseUpdate\n\n// DatabaseDelete is emitted when a database resource is deleted.\nexport class DatabaseDelete {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // ResourceMetadata is a common resource event metadata.\n  public Resource: ResourceMetadata = new ResourceMetadata();\n\n  // Decodes DatabaseDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseDelete {\n    return DatabaseDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseDelete from a DataView\n  static decodeDataView(view: DataView): DatabaseDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseDelete\n} // DatabaseDelete\n\n// DatabaseSessionStart is emitted when a user connects to a database.\nexport class DatabaseSessionStart {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // Session is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Server is a common server metadata.\n  public Server: ServerMetadata = new ServerMetadata();\n  // Connection holds information about the connection.\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // Status indicates whether the connection was successful or denied.\n  public Status: Status = new Status();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n\n  // Decodes DatabaseSessionStart from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseSessionStart {\n    return DatabaseSessionStart.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseSessionStart from a DataView\n  static decodeDataView(view: DataView): DatabaseSessionStart {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseSessionStart();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Server = ServerMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.Status = Status.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseSessionStart\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Server != null) {\n      const f: ServerMetadata = this.Server as ServerMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Status != null) {\n      const f: Status = this.Status as Status;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseSessionStart to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseSessionStart to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Server != null) {\n      const f = this.Server as ServerMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Status != null) {\n      const f = this.Status as Status;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseSessionStart\n} // DatabaseSessionStart\n\n// DatabaseSessionQuery is emitted when a user executes a database query.\nexport class DatabaseSessionQuery {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // DatabaseQuery is the executed query string.\n  public DatabaseQuery: string = \"\";\n  // DatabaseQueryParameters are the query parameters for prepared statements.\n  public DatabaseQueryParameters: Array<string> = new Array<string>();\n  // Status indicates whether the query was successfully sent to the database.\n  public Status: Status = new Status();\n\n  // Decodes DatabaseSessionQuery from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseSessionQuery {\n    return DatabaseSessionQuery.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseSessionQuery from a DataView\n  static decodeDataView(view: DataView): DatabaseSessionQuery {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseSessionQuery();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.DatabaseQuery = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.DatabaseQueryParameters.push(decoder.string());\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.Status = Status.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseSessionQuery\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.DatabaseQuery.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DatabaseQuery.length) +\n          this.DatabaseQuery.length\n        : 0;\n\n    size += __size_string_repeated(this.DatabaseQueryParameters);\n\n    if (this.Status != null) {\n      const f: Status = this.Status as Status;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseSessionQuery to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseSessionQuery to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DatabaseQuery.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.DatabaseQuery.length);\n      encoder.string(this.DatabaseQuery);\n    }\n\n    if (this.DatabaseQueryParameters.length > 0) {\n      for (let n: i32 = 0; n < this.DatabaseQueryParameters.length; n++) {\n        encoder.uint32(0x32);\n        encoder.uint32(this.DatabaseQueryParameters[n].length);\n        encoder.string(this.DatabaseQueryParameters[n]);\n      }\n    }\n\n    if (this.Status != null) {\n      const f = this.Status as Status;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseSessionQuery\n} // DatabaseSessionQuery\n\n/**\n * PostgresParse is emitted when a Postgres client creates a prepared statement\n *  using extended query protocol.\n */\nexport class PostgresParse {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // StatementName is the prepared statement name.\n  public StatementName: string = \"\";\n  // Query is the prepared statement query.\n  public Query: string = \"\";\n\n  // Decodes PostgresParse from an ArrayBuffer\n  static decode(buf: ArrayBuffer): PostgresParse {\n    return PostgresParse.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes PostgresParse from a DataView\n  static decodeDataView(view: DataView): PostgresParse {\n    const decoder = new __proto.Decoder(view);\n    const obj = new PostgresParse();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.StatementName = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.Query = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode PostgresParse\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.StatementName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.StatementName.length) +\n          this.StatementName.length\n        : 0;\n    size +=\n      this.Query.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Query.length) + this.Query.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes PostgresParse to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes PostgresParse to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.StatementName.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.StatementName.length);\n      encoder.string(this.StatementName);\n    }\n    if (this.Query.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.Query.length);\n      encoder.string(this.Query);\n    }\n\n    return buf;\n  } // encode PostgresParse\n} // PostgresParse\n\n/**\n * PostgresBind is emitted when a Postgres client readies a prepared statement\n *  for execution and binds it to parameters.\n */\nexport class PostgresBind {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // StatementName is the name of prepared statement that's being bound to parameters.\n  public StatementName: string = \"\";\n  // PortalName is the destination portal name that binds statement to parameters.\n  public PortalName: string = \"\";\n  // Parameters are the query bind parameters.\n  public Parameters: Array<string> = new Array<string>();\n\n  // Decodes PostgresBind from an ArrayBuffer\n  static decode(buf: ArrayBuffer): PostgresBind {\n    return PostgresBind.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes PostgresBind from a DataView\n  static decodeDataView(view: DataView): PostgresBind {\n    const decoder = new __proto.Decoder(view);\n    const obj = new PostgresBind();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.StatementName = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.PortalName = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.Parameters.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode PostgresBind\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.StatementName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.StatementName.length) +\n          this.StatementName.length\n        : 0;\n    size +=\n      this.PortalName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PortalName.length) +\n          this.PortalName.length\n        : 0;\n\n    size += __size_string_repeated(this.Parameters);\n\n    return size;\n  }\n\n  // Encodes PostgresBind to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes PostgresBind to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.StatementName.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.StatementName.length);\n      encoder.string(this.StatementName);\n    }\n    if (this.PortalName.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.PortalName.length);\n      encoder.string(this.PortalName);\n    }\n\n    if (this.Parameters.length > 0) {\n      for (let n: i32 = 0; n < this.Parameters.length; n++) {\n        encoder.uint32(0x3a);\n        encoder.uint32(this.Parameters[n].length);\n        encoder.string(this.Parameters[n]);\n      }\n    }\n\n    return buf;\n  } // encode PostgresBind\n} // PostgresBind\n\n/**\n * PostgresExecute is emitted when a Postgres client executes a previously\n *  bound prepared statement.\n */\nexport class PostgresExecute {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // PortalName is the name of destination portal that's being executed.\n  public PortalName: string = \"\";\n\n  // Decodes PostgresExecute from an ArrayBuffer\n  static decode(buf: ArrayBuffer): PostgresExecute {\n    return PostgresExecute.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes PostgresExecute from a DataView\n  static decodeDataView(view: DataView): PostgresExecute {\n    const decoder = new __proto.Decoder(view);\n    const obj = new PostgresExecute();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.PortalName = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode PostgresExecute\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.PortalName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PortalName.length) +\n          this.PortalName.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes PostgresExecute to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes PostgresExecute to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.PortalName.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.PortalName.length);\n      encoder.string(this.PortalName);\n    }\n\n    return buf;\n  } // encode PostgresExecute\n} // PostgresExecute\n\n/**\n * PostgresClose is emitted when a Postgres client closes an existing prepared\n *  statement.\n */\nexport class PostgresClose {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // StatementName is the name of prepared statement that's being closed.\n  public StatementName: string = \"\";\n  // PortalName is the name of destination portal that's being closed.\n  public PortalName: string = \"\";\n\n  // Decodes PostgresClose from an ArrayBuffer\n  static decode(buf: ArrayBuffer): PostgresClose {\n    return PostgresClose.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes PostgresClose from a DataView\n  static decodeDataView(view: DataView): PostgresClose {\n    const decoder = new __proto.Decoder(view);\n    const obj = new PostgresClose();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.StatementName = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.PortalName = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode PostgresClose\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.StatementName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.StatementName.length) +\n          this.StatementName.length\n        : 0;\n    size +=\n      this.PortalName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PortalName.length) +\n          this.PortalName.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes PostgresClose to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes PostgresClose to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.StatementName.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.StatementName.length);\n      encoder.string(this.StatementName);\n    }\n    if (this.PortalName.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.PortalName.length);\n      encoder.string(this.PortalName);\n    }\n\n    return buf;\n  } // encode PostgresClose\n} // PostgresClose\n\n/**\n * PostgresFunctionCall is emitted when a Postgres client calls internal\n *  database function.\n */\nexport class PostgresFunctionCall {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // FunctionOID is the Postgres object ID of the called function.\n  public FunctionOID: u32;\n  // FunctionArgs contains formatted function arguments.\n  public FunctionArgs: Array<string> = new Array<string>();\n\n  // Decodes PostgresFunctionCall from an ArrayBuffer\n  static decode(buf: ArrayBuffer): PostgresFunctionCall {\n    return PostgresFunctionCall.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes PostgresFunctionCall from a DataView\n  static decodeDataView(view: DataView): PostgresFunctionCall {\n    const decoder = new __proto.Decoder(view);\n    const obj = new PostgresFunctionCall();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.FunctionOID = decoder.uint32();\n          break;\n        }\n        case 6: {\n          obj.FunctionArgs.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode PostgresFunctionCall\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.FunctionOID == 0 ? 0 : 1 + __proto.Sizer.uint32(this.FunctionOID);\n\n    size += __size_string_repeated(this.FunctionArgs);\n\n    return size;\n  }\n\n  // Encodes PostgresFunctionCall to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes PostgresFunctionCall to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.FunctionOID != 0) {\n      encoder.uint32(0x28);\n      encoder.uint32(this.FunctionOID);\n    }\n\n    if (this.FunctionArgs.length > 0) {\n      for (let n: i32 = 0; n < this.FunctionArgs.length; n++) {\n        encoder.uint32(0x32);\n        encoder.uint32(this.FunctionArgs[n].length);\n        encoder.string(this.FunctionArgs[n]);\n      }\n    }\n\n    return buf;\n  } // encode PostgresFunctionCall\n} // PostgresFunctionCall\n\n// WindowsDesktopSessionStart is emitted when a user connects to a desktop.\nexport class WindowsDesktopSessionStart {\n  // Metadata is common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // Session is common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Connection holds information about the connection.\n  public Connection: ConnectionMetadata = new ConnectionMetadata();\n  // Status indicates whether the connection was successful or denied.\n  public Status: Status = new Status();\n  // WindowsDesktopService is the name of the service proxying the RDP session.\n  public WindowsDesktopService: string = \"\";\n  // DesktopAddr is the address of the desktop being accessed.\n  public DesktopAddr: string = \"\";\n  // Domain is the Active Directory domain of the desktop being accessed.\n  public Domain: string = \"\";\n  // WindowsUser is the Windows username used to connect.\n  public WindowsUser: string = \"\";\n  // DesktopLabels are the labels on the desktop resource.\n  public DesktopLabels: Map<string, string> = new Map<string, string>();\n  // DesktopName is the name of the desktop resource.\n  public DesktopName: string = \"\";\n\n  // Decodes WindowsDesktopSessionStart from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WindowsDesktopSessionStart {\n    return WindowsDesktopSessionStart.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WindowsDesktopSessionStart from a DataView\n  static decodeDataView(view: DataView): WindowsDesktopSessionStart {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WindowsDesktopSessionStart();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Connection = ConnectionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.Status = Status.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 6: {\n          obj.WindowsDesktopService = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.DesktopAddr = decoder.string();\n          break;\n        }\n        case 8: {\n          obj.Domain = decoder.string();\n          break;\n        }\n        case 9: {\n          obj.WindowsUser = decoder.string();\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.DesktopLabels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 11: {\n          obj.DesktopName = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WindowsDesktopSessionStart\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Connection != null) {\n      const f: ConnectionMetadata = this.Connection as ConnectionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Status != null) {\n      const f: Status = this.Status as Status;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.WindowsDesktopService.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.WindowsDesktopService.length) +\n          this.WindowsDesktopService.length\n        : 0;\n    size +=\n      this.DesktopAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DesktopAddr.length) +\n          this.DesktopAddr.length\n        : 0;\n    size +=\n      this.Domain.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Domain.length) + this.Domain.length\n        : 0;\n    size +=\n      this.WindowsUser.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.WindowsUser.length) +\n          this.WindowsUser.length\n        : 0;\n\n    if (this.DesktopLabels.size > 0) {\n      const keys = this.DesktopLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DesktopLabels.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    size +=\n      this.DesktopName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DesktopName.length) +\n          this.DesktopName.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes WindowsDesktopSessionStart to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WindowsDesktopSessionStart to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Connection != null) {\n      const f = this.Connection as ConnectionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Status != null) {\n      const f = this.Status as Status;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.WindowsDesktopService.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.WindowsDesktopService.length);\n      encoder.string(this.WindowsDesktopService);\n    }\n    if (this.DesktopAddr.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.DesktopAddr.length);\n      encoder.string(this.DesktopAddr);\n    }\n    if (this.Domain.length > 0) {\n      encoder.uint32(0x42);\n      encoder.uint32(this.Domain.length);\n      encoder.string(this.Domain);\n    }\n    if (this.WindowsUser.length > 0) {\n      encoder.uint32(0x4a);\n      encoder.uint32(this.WindowsUser.length);\n      encoder.string(this.WindowsUser);\n    }\n\n    if (this.DesktopLabels.size > 0) {\n      const keys = this.DesktopLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DesktopLabels.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0x52);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    if (this.DesktopName.length > 0) {\n      encoder.uint32(0x5a);\n      encoder.uint32(this.DesktopName.length);\n      encoder.string(this.DesktopName);\n    }\n\n    return buf;\n  } // encode WindowsDesktopSessionStart\n} // WindowsDesktopSessionStart\n\n// DatabaseSessionEnd is emitted when a user ends the database session.\nexport class DatabaseSessionEnd {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // Session is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n\n  // Decodes DatabaseSessionEnd from an ArrayBuffer\n  static decode(buf: ArrayBuffer): DatabaseSessionEnd {\n    return DatabaseSessionEnd.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes DatabaseSessionEnd from a DataView\n  static decodeDataView(view: DataView): DatabaseSessionEnd {\n    const decoder = new __proto.Decoder(view);\n    const obj = new DatabaseSessionEnd();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode DatabaseSessionEnd\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes DatabaseSessionEnd to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes DatabaseSessionEnd to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode DatabaseSessionEnd\n} // DatabaseSessionEnd\n\n// MFADeviceMetadata is a common MFA device metadata.\nexport class MFADeviceMetadata {\n  // Name is the user-specified name of the MFA device.\n  public DeviceName: string = \"\";\n  // ID is the UUID of the MFA device generated by Teleport.\n  public DeviceID: string = \"\";\n  // Type is the type of this MFA device.\n  public DeviceType: string = \"\";\n\n  // Decodes MFADeviceMetadata from an ArrayBuffer\n  static decode(buf: ArrayBuffer): MFADeviceMetadata {\n    return MFADeviceMetadata.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes MFADeviceMetadata from a DataView\n  static decodeDataView(view: DataView): MFADeviceMetadata {\n    const decoder = new __proto.Decoder(view);\n    const obj = new MFADeviceMetadata();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.DeviceName = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.DeviceID = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.DeviceType = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode MFADeviceMetadata\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.DeviceName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DeviceName.length) +\n          this.DeviceName.length\n        : 0;\n    size +=\n      this.DeviceID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DeviceID.length) +\n          this.DeviceID.length\n        : 0;\n    size +=\n      this.DeviceType.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DeviceType.length) +\n          this.DeviceType.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes MFADeviceMetadata to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes MFADeviceMetadata to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.DeviceName.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.DeviceName.length);\n      encoder.string(this.DeviceName);\n    }\n    if (this.DeviceID.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.DeviceID.length);\n      encoder.string(this.DeviceID);\n    }\n    if (this.DeviceType.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.DeviceType.length);\n      encoder.string(this.DeviceType);\n    }\n\n    return buf;\n  } // encode MFADeviceMetadata\n} // MFADeviceMetadata\n\n// MFADeviceAdd is emitted when a user adds an MFA device.\nexport class MFADeviceAdd {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // Device is the new MFA device added by the user.\n  public Device: MFADeviceMetadata = new MFADeviceMetadata();\n\n  // Decodes MFADeviceAdd from an ArrayBuffer\n  static decode(buf: ArrayBuffer): MFADeviceAdd {\n    return MFADeviceAdd.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes MFADeviceAdd from a DataView\n  static decodeDataView(view: DataView): MFADeviceAdd {\n    const decoder = new __proto.Decoder(view);\n    const obj = new MFADeviceAdd();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Device = MFADeviceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode MFADeviceAdd\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Device != null) {\n      const f: MFADeviceMetadata = this.Device as MFADeviceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes MFADeviceAdd to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes MFADeviceAdd to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Device != null) {\n      const f = this.Device as MFADeviceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode MFADeviceAdd\n} // MFADeviceAdd\n\n// MFADeviceDelete is emitted when a user deletes an MFA device.\nexport class MFADeviceDelete {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // Device is the MFA device deleted by the user.\n  public Device: MFADeviceMetadata = new MFADeviceMetadata();\n\n  // Decodes MFADeviceDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): MFADeviceDelete {\n    return MFADeviceDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes MFADeviceDelete from a DataView\n  static decodeDataView(view: DataView): MFADeviceDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new MFADeviceDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Device = MFADeviceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode MFADeviceDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Device != null) {\n      const f: MFADeviceMetadata = this.Device as MFADeviceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes MFADeviceDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes MFADeviceDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Device != null) {\n      const f = this.Device as MFADeviceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode MFADeviceDelete\n} // MFADeviceDelete\n\n// BillingInformationUpdate is emitted when a user updates the billing information.\nexport class BillingInformationUpdate {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes BillingInformationUpdate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): BillingInformationUpdate {\n    return BillingInformationUpdate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes BillingInformationUpdate from a DataView\n  static decodeDataView(view: DataView): BillingInformationUpdate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new BillingInformationUpdate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode BillingInformationUpdate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes BillingInformationUpdate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes BillingInformationUpdate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode BillingInformationUpdate\n} // BillingInformationUpdate\n\n// BillingCardCreate is emitted when a user creates or updates a credit card.\nexport class BillingCardCreate {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes BillingCardCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): BillingCardCreate {\n    return BillingCardCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes BillingCardCreate from a DataView\n  static decodeDataView(view: DataView): BillingCardCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new BillingCardCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode BillingCardCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes BillingCardCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes BillingCardCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode BillingCardCreate\n} // BillingCardCreate\n\n// BillingCardDelete is emitted when a user deletes a credit card.\nexport class BillingCardDelete {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes BillingCardDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): BillingCardDelete {\n    return BillingCardDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes BillingCardDelete from a DataView\n  static decodeDataView(view: DataView): BillingCardDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new BillingCardDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode BillingCardDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes BillingCardDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes BillingCardDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode BillingCardDelete\n} // BillingCardDelete\n\n/**\n * LockCreate is emitted when a lock is created/updated.\n *  Locks are used to restrict access to a Teleport environment by disabling\n *  interactions involving a user, an RBAC role, a node, etc.\n *  See rfd/0009-locking.md for more details.\n */\nexport class LockCreate {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes LockCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): LockCreate {\n    return LockCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes LockCreate from a DataView\n  static decodeDataView(view: DataView): LockCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new LockCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode LockCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes LockCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes LockCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode LockCreate\n} // LockCreate\n\n// LockDelete is emitted when a lock is deleted\nexport class LockDelete {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // ResourceMetadata is a common resource event metadata\n  public Resource: ResourceMetadata = new ResourceMetadata();\n  // User is a common user event metadata\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes LockDelete from an ArrayBuffer\n  static decode(buf: ArrayBuffer): LockDelete {\n    return LockDelete.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes LockDelete from a DataView\n  static decodeDataView(view: DataView): LockDelete {\n    const decoder = new __proto.Decoder(view);\n    const obj = new LockDelete();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Resource = ResourceMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode LockDelete\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resource != null) {\n      const f: ResourceMetadata = this.Resource as ResourceMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes LockDelete to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes LockDelete to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resource != null) {\n      const f = this.Resource as ResourceMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode LockDelete\n} // LockDelete\n\n// RecoveryCodeGenerate is emitted when a user's new recovery codes are generated and updated.\nexport class RecoveryCodeGenerate {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n\n  // Decodes RecoveryCodeGenerate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RecoveryCodeGenerate {\n    return RecoveryCodeGenerate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RecoveryCodeGenerate from a DataView\n  static decodeDataView(view: DataView): RecoveryCodeGenerate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RecoveryCodeGenerate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RecoveryCodeGenerate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RecoveryCodeGenerate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RecoveryCodeGenerate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RecoveryCodeGenerate\n} // RecoveryCodeGenerate\n\n/**\n * RecoveryCodeUsed is emitted when a user's recovery code was used successfully or\n *  unsuccessfully.\n */\nexport class RecoveryCodeUsed {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // Status contains fields to indicate whether attempt was successful or not.\n  public Status: Status = new Status();\n\n  // Decodes RecoveryCodeUsed from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RecoveryCodeUsed {\n    return RecoveryCodeUsed.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RecoveryCodeUsed from a DataView\n  static decodeDataView(view: DataView): RecoveryCodeUsed {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RecoveryCodeUsed();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Status = Status.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RecoveryCodeUsed\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Status != null) {\n      const f: Status = this.Status as Status;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RecoveryCodeUsed to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RecoveryCodeUsed to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Status != null) {\n      const f = this.Status as Status;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RecoveryCodeUsed\n} // RecoveryCodeUsed\n\n// WindowsDesktopSessionEnd is emitted when a user ends a Windows desktop session.\nexport class WindowsDesktopSessionEnd {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // Session is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // WindowsDesktopService is the name of the service proxying the RDP session.\n  public WindowsDesktopService: string = \"\";\n  // DesktopAddr is the address of the desktop being accessed.\n  public DesktopAddr: string = \"\";\n  // Domain is the Active Directory domain of the desktop being accessed.\n  public Domain: string = \"\";\n  // WindowsUser is the Windows username used to connect.\n  public WindowsUser: string = \"\";\n  // DesktopLabels are the labels on the desktop resource.\n  public DesktopLabels: Map<string, string> = new Map<string, string>();\n  // StartTime is the timestamp at which the session began.\n  public StartTime: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // EndTime is the timestamp at which the session ended.\n  public EndTime: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  // DesktopName is the name of the desktop resource.\n  public DesktopName: string = \"\";\n  // Recorded is true if the session was recorded, false otherwise.\n  public Recorded: bool;\n  // Participants is a list of participants in the session.\n  public Participants: Array<string> = new Array<string>();\n\n  // Decodes WindowsDesktopSessionEnd from an ArrayBuffer\n  static decode(buf: ArrayBuffer): WindowsDesktopSessionEnd {\n    return WindowsDesktopSessionEnd.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes WindowsDesktopSessionEnd from a DataView\n  static decodeDataView(view: DataView): WindowsDesktopSessionEnd {\n    const decoder = new __proto.Decoder(view);\n    const obj = new WindowsDesktopSessionEnd();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.WindowsDesktopService = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.DesktopAddr = decoder.string();\n          break;\n        }\n        case 6: {\n          obj.Domain = decoder.string();\n          break;\n        }\n        case 7: {\n          obj.WindowsUser = decoder.string();\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.DesktopLabels);\n          decoder.skip(length);\n\n          break;\n        }\n        case 9: {\n          const length = decoder.uint32();\n          obj.StartTime = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.EndTime = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 11: {\n          obj.DesktopName = decoder.string();\n          break;\n        }\n        case 12: {\n          obj.Recorded = decoder.bool();\n          break;\n        }\n        case 13: {\n          obj.Participants.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode WindowsDesktopSessionEnd\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.WindowsDesktopService.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.WindowsDesktopService.length) +\n          this.WindowsDesktopService.length\n        : 0;\n    size +=\n      this.DesktopAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DesktopAddr.length) +\n          this.DesktopAddr.length\n        : 0;\n    size +=\n      this.Domain.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Domain.length) + this.Domain.length\n        : 0;\n    size +=\n      this.WindowsUser.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.WindowsUser.length) +\n          this.WindowsUser.length\n        : 0;\n\n    if (this.DesktopLabels.size > 0) {\n      const keys = this.DesktopLabels.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DesktopLabels.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    if (this.StartTime != null) {\n      const f: google.protobuf.Timestamp = this\n        .StartTime as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.EndTime != null) {\n      const f: google.protobuf.Timestamp = this\n        .EndTime as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.DesktopName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.DesktopName.length) +\n          this.DesktopName.length\n        : 0;\n    size += this.Recorded == 0 ? 0 : 1 + 1;\n\n    size += __size_string_repeated(this.Participants);\n\n    return size;\n  }\n\n  // Encodes WindowsDesktopSessionEnd to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes WindowsDesktopSessionEnd to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.WindowsDesktopService.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.WindowsDesktopService.length);\n      encoder.string(this.WindowsDesktopService);\n    }\n    if (this.DesktopAddr.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.DesktopAddr.length);\n      encoder.string(this.DesktopAddr);\n    }\n    if (this.Domain.length > 0) {\n      encoder.uint32(0x32);\n      encoder.uint32(this.Domain.length);\n      encoder.string(this.Domain);\n    }\n    if (this.WindowsUser.length > 0) {\n      encoder.uint32(0x3a);\n      encoder.uint32(this.WindowsUser.length);\n      encoder.string(this.WindowsUser);\n    }\n\n    if (this.DesktopLabels.size > 0) {\n      const keys = this.DesktopLabels.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.DesktopLabels.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0x42);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    if (this.StartTime != null) {\n      const f = this.StartTime as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x4a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.EndTime != null) {\n      const f = this.EndTime as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DesktopName.length > 0) {\n      encoder.uint32(0x5a);\n      encoder.uint32(this.DesktopName.length);\n      encoder.string(this.DesktopName);\n    }\n    if (this.Recorded != 0) {\n      encoder.uint32(0x60);\n      encoder.bool(this.Recorded);\n    }\n\n    if (this.Participants.length > 0) {\n      for (let n: i32 = 0; n < this.Participants.length; n++) {\n        encoder.uint32(0x6a);\n        encoder.uint32(this.Participants[n].length);\n        encoder.string(this.Participants[n]);\n      }\n    }\n\n    return buf;\n  } // encode WindowsDesktopSessionEnd\n} // WindowsDesktopSessionEnd\n\n// CertificateCreate is emitted when a certificate is issued.\nexport class CertificateCreate {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // CertificateType is the type of certificate that was just issued.\n  public CertificateType: string = \"\";\n  // Identity is the identity associated with the certificate, as interpreted by Teleport.\n  public Identity: Identity = new Identity();\n\n  // Decodes CertificateCreate from an ArrayBuffer\n  static decode(buf: ArrayBuffer): CertificateCreate {\n    return CertificateCreate.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes CertificateCreate from a DataView\n  static decodeDataView(view: DataView): CertificateCreate {\n    const decoder = new __proto.Decoder(view);\n    const obj = new CertificateCreate();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          obj.CertificateType = decoder.string();\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Identity = Identity.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode CertificateCreate\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.CertificateType.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.CertificateType.length) +\n          this.CertificateType.length\n        : 0;\n\n    if (this.Identity != null) {\n      const f: Identity = this.Identity as Identity;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes CertificateCreate to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes CertificateCreate to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.CertificateType.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.CertificateType.length);\n      encoder.string(this.CertificateType);\n    }\n\n    if (this.Identity != null) {\n      const f = this.Identity as Identity;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode CertificateCreate\n} // CertificateCreate\n\n/**\n * RenewableCertificateGenerationMismatch is emitted when a renewable\n *  certificiate's generation counter fails to validate, possibly indicating a\n *  stolen certificate and an invalid renewal attempt.\n */\nexport class RenewableCertificateGenerationMismatch {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // UserMetadata is a common user event metadata.\n  public UserMetadata: UserMetadata = new UserMetadata();\n\n  // Decodes RenewableCertificateGenerationMismatch from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RenewableCertificateGenerationMismatch {\n    return RenewableCertificateGenerationMismatch.decodeDataView(\n      new DataView(buf)\n    );\n  }\n\n  // Decodes RenewableCertificateGenerationMismatch from a DataView\n  static decodeDataView(\n    view: DataView\n  ): RenewableCertificateGenerationMismatch {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RenewableCertificateGenerationMismatch();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.UserMetadata = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RenewableCertificateGenerationMismatch\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.UserMetadata != null) {\n      const f: UserMetadata = this.UserMetadata as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes RenewableCertificateGenerationMismatch to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RenewableCertificateGenerationMismatch to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.UserMetadata != null) {\n      const f = this.UserMetadata as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode RenewableCertificateGenerationMismatch\n} // RenewableCertificateGenerationMismatch\n\n// Unknown is a fallback event used when we don't recognize an event from the backend.\nexport class Unknown {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // UnknownType is the event type extracted from the unknown event.\n  public UnknownType: string = \"\";\n  // UnknownCode is the event code extracted from the unknown event.\n  public UnknownCode: string = \"\";\n  // Data is the serialized JSON data of the unknown event.\n  public Data: string = \"\";\n\n  // Decodes Unknown from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Unknown {\n    return Unknown.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Unknown from a DataView\n  static decodeDataView(view: DataView): Unknown {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Unknown();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          obj.UnknownType = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.UnknownCode = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.Data = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Unknown\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.UnknownType.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.UnknownType.length) +\n          this.UnknownType.length\n        : 0;\n    size +=\n      this.UnknownCode.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.UnknownCode.length) +\n          this.UnknownCode.length\n        : 0;\n    size +=\n      this.Data.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Data.length) + this.Data.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes Unknown to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Unknown to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.UnknownType.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.UnknownType.length);\n      encoder.string(this.UnknownType);\n    }\n    if (this.UnknownCode.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.UnknownCode.length);\n      encoder.string(this.UnknownCode);\n    }\n    if (this.Data.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.Data.length);\n      encoder.string(this.Data);\n    }\n\n    return buf;\n  } // encode Unknown\n} // Unknown\n\n// OneOf is a union of one of audit events submitted to the auth service\nexport class OneOf {\n  public UserLogin: UserLogin | null;\n  public UserCreate: UserCreate | null;\n  public UserDelete: UserDelete | null;\n  public UserPasswordChange: UserPasswordChange | null;\n  public SessionStart: SessionStart | null;\n  public SessionJoin: SessionJoin | null;\n  public SessionPrint: SessionPrint | null;\n  public SessionReject: SessionReject | null;\n  public Resize: Resize | null;\n  public SessionEnd: SessionEnd | null;\n  public SessionCommand: SessionCommand | null;\n  public SessionDisk: SessionDisk | null;\n  public SessionNetwork: SessionNetwork | null;\n  public SessionData: SessionData | null;\n  public SessionLeave: SessionLeave | null;\n  public PortForward: PortForward | null;\n  public X11Forward: X11Forward | null;\n  public SCP: SCP | null;\n  public Exec: Exec | null;\n  public Subsystem: Subsystem | null;\n  public ClientDisconnect: ClientDisconnect | null;\n  public AuthAttempt: AuthAttempt | null;\n  public AccessRequestCreate: AccessRequestCreate | null;\n  public UserTokenCreate: UserTokenCreate | null;\n  public RoleCreate: RoleCreate | null;\n  public RoleDelete: RoleDelete | null;\n  public TrustedClusterCreate: TrustedClusterCreate | null;\n  public TrustedClusterDelete: TrustedClusterDelete | null;\n  public TrustedClusterTokenCreate: TrustedClusterTokenCreate | null;\n  public GithubConnectorCreate: GithubConnectorCreate | null;\n  public GithubConnectorDelete: GithubConnectorDelete | null;\n  public OIDCConnectorCreate: OIDCConnectorCreate | null;\n  public OIDCConnectorDelete: OIDCConnectorDelete | null;\n  public SAMLConnectorCreate: SAMLConnectorCreate | null;\n  public SAMLConnectorDelete: SAMLConnectorDelete | null;\n  public KubeRequest: KubeRequest | null;\n  public AppSessionStart: AppSessionStart | null;\n  public AppSessionChunk: AppSessionChunk | null;\n  public AppSessionRequest: AppSessionRequest | null;\n  public DatabaseSessionStart: DatabaseSessionStart | null;\n  public DatabaseSessionEnd: DatabaseSessionEnd | null;\n  public DatabaseSessionQuery: DatabaseSessionQuery | null;\n  public SessionUpload: SessionUpload | null;\n  public MFADeviceAdd: MFADeviceAdd | null;\n  public MFADeviceDelete: MFADeviceDelete | null;\n  public BillingInformationUpdate: BillingInformationUpdate | null;\n  public BillingCardCreate: BillingCardCreate | null;\n  public BillingCardDelete: BillingCardDelete | null;\n  public LockCreate: LockCreate | null;\n  public LockDelete: LockDelete | null;\n  public RecoveryCodeGenerate: RecoveryCodeGenerate | null;\n  public RecoveryCodeUsed: RecoveryCodeUsed | null;\n  public DatabaseCreate: DatabaseCreate | null;\n  public DatabaseUpdate: DatabaseUpdate | null;\n  public DatabaseDelete: DatabaseDelete | null;\n  public AppCreate: AppCreate | null;\n  public AppUpdate: AppUpdate | null;\n  public AppDelete: AppDelete | null;\n  public WindowsDesktopSessionStart: WindowsDesktopSessionStart | null;\n  public WindowsDesktopSessionEnd: WindowsDesktopSessionEnd | null;\n  public PostgresParse: PostgresParse | null;\n  public PostgresBind: PostgresBind | null;\n  public PostgresExecute: PostgresExecute | null;\n  public PostgresClose: PostgresClose | null;\n  public PostgresFunctionCall: PostgresFunctionCall | null;\n  public AccessRequestDelete: AccessRequestDelete | null;\n  public SessionConnect: SessionConnect | null;\n  public CertificateCreate: CertificateCreate | null;\n  public DesktopRecording: DesktopRecording | null;\n  public DesktopClipboardSend: DesktopClipboardSend | null;\n  public DesktopClipboardReceive: DesktopClipboardReceive | null;\n  public MySQLStatementPrepare: MySQLStatementPrepare | null;\n  public MySQLStatementExecute: MySQLStatementExecute | null;\n  public MySQLStatementSendLongData: MySQLStatementSendLongData | null;\n  public MySQLStatementClose: MySQLStatementClose | null;\n  public MySQLStatementReset: MySQLStatementReset | null;\n  public MySQLStatementFetch: MySQLStatementFetch | null;\n  public MySQLStatementBulkExecute: MySQLStatementBulkExecute | null;\n  public RenewableCertificateGenerationMismatch: RenewableCertificateGenerationMismatch | null;\n  public Unknown: Unknown | null;\n\n  public type: string = \"\";\n  public type_index: u8 = 0;\n\n  static readonly EVENT_USER_LOGIN_INDEX: u8 = 1;\n  static readonly EVENT_USER_CREATE_INDEX: u8 = 2;\n  static readonly EVENT_USER_DELETE_INDEX: u8 = 3;\n  static readonly EVENT_USER_PASSWORD_CHANGE_INDEX: u8 = 4;\n  static readonly EVENT_SESSION_START_INDEX: u8 = 5;\n  static readonly EVENT_SESSION_JOIN_INDEX: u8 = 6;\n  static readonly EVENT_SESSION_PRINT_INDEX: u8 = 7;\n  static readonly EVENT_SESSION_REJECT_INDEX: u8 = 8;\n  static readonly EVENT_RESIZE_INDEX: u8 = 9;\n  static readonly EVENT_SESSION_END_INDEX: u8 = 10;\n  static readonly EVENT_SESSION_COMMAND_INDEX: u8 = 11;\n  static readonly EVENT_SESSION_DISK_INDEX: u8 = 12;\n  static readonly EVENT_SESSION_NETWORK_INDEX: u8 = 13;\n  static readonly EVENT_SESSION_DATA_INDEX: u8 = 14;\n  static readonly EVENT_SESSION_LEAVE_INDEX: u8 = 15;\n  static readonly EVENT_PORT_FORWARD_INDEX: u8 = 16;\n  static readonly EVENT_X11_FORWARD_INDEX: u8 = 17;\n  static readonly EVENT_SCP_INDEX: u8 = 18;\n  static readonly EVENT_EXEC_INDEX: u8 = 19;\n  static readonly EVENT_SUBSYSTEM_INDEX: u8 = 20;\n  static readonly EVENT_CLIENT_DISCONNECT_INDEX: u8 = 21;\n  static readonly EVENT_AUTH_ATTEMPT_INDEX: u8 = 22;\n  static readonly EVENT_ACCESS_REQUEST_CREATE_INDEX: u8 = 23;\n  static readonly EVENT_USER_TOKEN_CREATE_INDEX: u8 = 24;\n  static readonly EVENT_ROLE_CREATE_INDEX: u8 = 25;\n  static readonly EVENT_ROLE_DELETE_INDEX: u8 = 26;\n  static readonly EVENT_TRUSTED_CLUSTER_CREATE_INDEX: u8 = 27;\n  static readonly EVENT_TRUSTED_CLUSTER_DELETE_INDEX: u8 = 28;\n  static readonly EVENT_TRUSTED_CLUSTER_TOKEN_CREATE_INDEX: u8 = 29;\n  static readonly EVENT_GITHUB_CONNECTOR_CREATE_INDEX: u8 = 30;\n  static readonly EVENT_GITHUB_CONNECTOR_DELETE_INDEX: u8 = 31;\n  static readonly EVENT_OIDC_CONNECTOR_CREATE_INDEX: u8 = 32;\n  static readonly EVENT_OIDC_CONNECTOR_DELETE_INDEX: u8 = 33;\n  static readonly EVENT_SAML_CONNECTOR_CREATE_INDEX: u8 = 34;\n  static readonly EVENT_SAML_CONNECTOR_DELETE_INDEX: u8 = 35;\n  static readonly EVENT_KUBE_REQUEST_INDEX: u8 = 36;\n  static readonly EVENT_APP_SESSION_START_INDEX: u8 = 37;\n  static readonly EVENT_APP_SESSION_CHUNK_INDEX: u8 = 38;\n  static readonly EVENT_APP_SESSION_REQUEST_INDEX: u8 = 39;\n  static readonly EVENT_DATABASE_SESSION_START_INDEX: u8 = 40;\n  static readonly EVENT_DATABASE_SESSION_END_INDEX: u8 = 41;\n  static readonly EVENT_DATABASE_SESSION_QUERY_INDEX: u8 = 42;\n  static readonly EVENT_SESSION_UPLOAD_INDEX: u8 = 43;\n  static readonly EVENT_MFA_DEVICE_ADD_INDEX: u8 = 44;\n  static readonly EVENT_MFA_DEVICE_DELETE_INDEX: u8 = 45;\n  static readonly EVENT_BILLING_INFORMATION_UPDATE_INDEX: u8 = 46;\n  static readonly EVENT_BILLING_CARD_CREATE_INDEX: u8 = 47;\n  static readonly EVENT_BILLING_CARD_DELETE_INDEX: u8 = 48;\n  static readonly EVENT_LOCK_CREATE_INDEX: u8 = 49;\n  static readonly EVENT_LOCK_DELETE_INDEX: u8 = 50;\n  static readonly EVENT_RECOVERY_CODE_GENERATE_INDEX: u8 = 51;\n  static readonly EVENT_RECOVERY_CODE_USED_INDEX: u8 = 52;\n  static readonly EVENT_DATABASE_CREATE_INDEX: u8 = 53;\n  static readonly EVENT_DATABASE_UPDATE_INDEX: u8 = 54;\n  static readonly EVENT_DATABASE_DELETE_INDEX: u8 = 55;\n  static readonly EVENT_APP_CREATE_INDEX: u8 = 56;\n  static readonly EVENT_APP_UPDATE_INDEX: u8 = 57;\n  static readonly EVENT_APP_DELETE_INDEX: u8 = 58;\n  static readonly EVENT_WINDOWS_DESKTOP_SESSION_START_INDEX: u8 = 59;\n  static readonly EVENT_WINDOWS_DESKTOP_SESSION_END_INDEX: u8 = 60;\n  static readonly EVENT_POSTGRES_PARSE_INDEX: u8 = 61;\n  static readonly EVENT_POSTGRES_BIND_INDEX: u8 = 62;\n  static readonly EVENT_POSTGRES_EXECUTE_INDEX: u8 = 63;\n  static readonly EVENT_POSTGRES_CLOSE_INDEX: u8 = 64;\n  static readonly EVENT_POSTGRES_FUNCTION_CALL_INDEX: u8 = 65;\n  static readonly EVENT_ACCESS_REQUEST_DELETE_INDEX: u8 = 66;\n  static readonly EVENT_SESSION_CONNECT_INDEX: u8 = 67;\n  static readonly EVENT_CERTIFICATE_CREATE_INDEX: u8 = 68;\n  static readonly EVENT_DESKTOP_RECORDING_INDEX: u8 = 69;\n  static readonly EVENT_DESKTOP_CLIPBOARD_SEND_INDEX: u8 = 70;\n  static readonly EVENT_DESKTOP_CLIPBOARD_RECEIVE_INDEX: u8 = 71;\n  static readonly EVENT_MY_SQL_STATEMENT_PREPARE_INDEX: u8 = 72;\n  static readonly EVENT_MY_SQL_STATEMENT_EXECUTE_INDEX: u8 = 73;\n  static readonly EVENT_MY_SQL_STATEMENT_SEND_LONG_DATA_INDEX: u8 = 74;\n  static readonly EVENT_MY_SQL_STATEMENT_CLOSE_INDEX: u8 = 75;\n  static readonly EVENT_MY_SQL_STATEMENT_RESET_INDEX: u8 = 76;\n  static readonly EVENT_MY_SQL_STATEMENT_FETCH_INDEX: u8 = 77;\n  static readonly EVENT_MY_SQL_STATEMENT_BULK_EXECUTE_INDEX: u8 = 78;\n  static readonly EVENT_RENEWABLE_CERTIFICATE_GENERATION_MISMATCH_INDEX: u8 = 79;\n  static readonly EVENT_UNKNOWN_INDEX: u8 = 80;\n\n  // Decodes OneOf from an ArrayBuffer\n  static decode(buf: ArrayBuffer): OneOf {\n    return OneOf.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes OneOf from a DataView\n  static decodeDataView(view: DataView): OneOf {\n    const decoder = new __proto.Decoder(view);\n    const obj = new OneOf();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.UserLogin = UserLogin.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"UserLogin\";\n          obj.type_index = 1;\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.UserCreate = UserCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"UserCreate\";\n          obj.type_index = 2;\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.UserDelete = UserDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"UserDelete\";\n          obj.type_index = 3;\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.UserPasswordChange = UserPasswordChange.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"UserPasswordChange\";\n          obj.type_index = 4;\n          break;\n        }\n        case 5: {\n          const length = decoder.uint32();\n          obj.SessionStart = SessionStart.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionStart\";\n          obj.type_index = 5;\n          break;\n        }\n        case 6: {\n          const length = decoder.uint32();\n          obj.SessionJoin = SessionJoin.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionJoin\";\n          obj.type_index = 6;\n          break;\n        }\n        case 7: {\n          const length = decoder.uint32();\n          obj.SessionPrint = SessionPrint.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionPrint\";\n          obj.type_index = 7;\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.SessionReject = SessionReject.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionReject\";\n          obj.type_index = 8;\n          break;\n        }\n        case 9: {\n          const length = decoder.uint32();\n          obj.Resize = Resize.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"Resize\";\n          obj.type_index = 9;\n          break;\n        }\n        case 10: {\n          const length = decoder.uint32();\n          obj.SessionEnd = SessionEnd.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionEnd\";\n          obj.type_index = 10;\n          break;\n        }\n        case 11: {\n          const length = decoder.uint32();\n          obj.SessionCommand = SessionCommand.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionCommand\";\n          obj.type_index = 11;\n          break;\n        }\n        case 12: {\n          const length = decoder.uint32();\n          obj.SessionDisk = SessionDisk.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionDisk\";\n          obj.type_index = 12;\n          break;\n        }\n        case 13: {\n          const length = decoder.uint32();\n          obj.SessionNetwork = SessionNetwork.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionNetwork\";\n          obj.type_index = 13;\n          break;\n        }\n        case 14: {\n          const length = decoder.uint32();\n          obj.SessionData = SessionData.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionData\";\n          obj.type_index = 14;\n          break;\n        }\n        case 15: {\n          const length = decoder.uint32();\n          obj.SessionLeave = SessionLeave.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionLeave\";\n          obj.type_index = 15;\n          break;\n        }\n        case 16: {\n          const length = decoder.uint32();\n          obj.PortForward = PortForward.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"PortForward\";\n          obj.type_index = 16;\n          break;\n        }\n        case 17: {\n          const length = decoder.uint32();\n          obj.X11Forward = X11Forward.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"X11Forward\";\n          obj.type_index = 17;\n          break;\n        }\n        case 18: {\n          const length = decoder.uint32();\n          obj.SCP = SCP.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SCP\";\n          obj.type_index = 18;\n          break;\n        }\n        case 19: {\n          const length = decoder.uint32();\n          obj.Exec = Exec.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"Exec\";\n          obj.type_index = 19;\n          break;\n        }\n        case 20: {\n          const length = decoder.uint32();\n          obj.Subsystem = Subsystem.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"Subsystem\";\n          obj.type_index = 20;\n          break;\n        }\n        case 21: {\n          const length = decoder.uint32();\n          obj.ClientDisconnect = ClientDisconnect.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"ClientDisconnect\";\n          obj.type_index = 21;\n          break;\n        }\n        case 22: {\n          const length = decoder.uint32();\n          obj.AuthAttempt = AuthAttempt.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"AuthAttempt\";\n          obj.type_index = 22;\n          break;\n        }\n        case 23: {\n          const length = decoder.uint32();\n          obj.AccessRequestCreate = AccessRequestCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"AccessRequestCreate\";\n          obj.type_index = 23;\n          break;\n        }\n        case 24: {\n          const length = decoder.uint32();\n          obj.UserTokenCreate = UserTokenCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"UserTokenCreate\";\n          obj.type_index = 24;\n          break;\n        }\n        case 25: {\n          const length = decoder.uint32();\n          obj.RoleCreate = RoleCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"RoleCreate\";\n          obj.type_index = 25;\n          break;\n        }\n        case 26: {\n          const length = decoder.uint32();\n          obj.RoleDelete = RoleDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"RoleDelete\";\n          obj.type_index = 26;\n          break;\n        }\n        case 27: {\n          const length = decoder.uint32();\n          obj.TrustedClusterCreate = TrustedClusterCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"TrustedClusterCreate\";\n          obj.type_index = 27;\n          break;\n        }\n        case 28: {\n          const length = decoder.uint32();\n          obj.TrustedClusterDelete = TrustedClusterDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"TrustedClusterDelete\";\n          obj.type_index = 28;\n          break;\n        }\n        case 29: {\n          const length = decoder.uint32();\n          obj.TrustedClusterTokenCreate =\n            TrustedClusterTokenCreate.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n          decoder.skip(length);\n\n          obj.type = \"TrustedClusterTokenCreate\";\n          obj.type_index = 29;\n          break;\n        }\n        case 30: {\n          const length = decoder.uint32();\n          obj.GithubConnectorCreate = GithubConnectorCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"GithubConnectorCreate\";\n          obj.type_index = 30;\n          break;\n        }\n        case 31: {\n          const length = decoder.uint32();\n          obj.GithubConnectorDelete = GithubConnectorDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"GithubConnectorDelete\";\n          obj.type_index = 31;\n          break;\n        }\n        case 32: {\n          const length = decoder.uint32();\n          obj.OIDCConnectorCreate = OIDCConnectorCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"OIDCConnectorCreate\";\n          obj.type_index = 32;\n          break;\n        }\n        case 33: {\n          const length = decoder.uint32();\n          obj.OIDCConnectorDelete = OIDCConnectorDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"OIDCConnectorDelete\";\n          obj.type_index = 33;\n          break;\n        }\n        case 34: {\n          const length = decoder.uint32();\n          obj.SAMLConnectorCreate = SAMLConnectorCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SAMLConnectorCreate\";\n          obj.type_index = 34;\n          break;\n        }\n        case 35: {\n          const length = decoder.uint32();\n          obj.SAMLConnectorDelete = SAMLConnectorDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SAMLConnectorDelete\";\n          obj.type_index = 35;\n          break;\n        }\n        case 36: {\n          const length = decoder.uint32();\n          obj.KubeRequest = KubeRequest.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"KubeRequest\";\n          obj.type_index = 36;\n          break;\n        }\n        case 37: {\n          const length = decoder.uint32();\n          obj.AppSessionStart = AppSessionStart.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"AppSessionStart\";\n          obj.type_index = 37;\n          break;\n        }\n        case 38: {\n          const length = decoder.uint32();\n          obj.AppSessionChunk = AppSessionChunk.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"AppSessionChunk\";\n          obj.type_index = 38;\n          break;\n        }\n        case 39: {\n          const length = decoder.uint32();\n          obj.AppSessionRequest = AppSessionRequest.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"AppSessionRequest\";\n          obj.type_index = 39;\n          break;\n        }\n        case 40: {\n          const length = decoder.uint32();\n          obj.DatabaseSessionStart = DatabaseSessionStart.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"DatabaseSessionStart\";\n          obj.type_index = 40;\n          break;\n        }\n        case 41: {\n          const length = decoder.uint32();\n          obj.DatabaseSessionEnd = DatabaseSessionEnd.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"DatabaseSessionEnd\";\n          obj.type_index = 41;\n          break;\n        }\n        case 42: {\n          const length = decoder.uint32();\n          obj.DatabaseSessionQuery = DatabaseSessionQuery.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"DatabaseSessionQuery\";\n          obj.type_index = 42;\n          break;\n        }\n        case 43: {\n          const length = decoder.uint32();\n          obj.SessionUpload = SessionUpload.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionUpload\";\n          obj.type_index = 43;\n          break;\n        }\n        case 44: {\n          const length = decoder.uint32();\n          obj.MFADeviceAdd = MFADeviceAdd.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"MFADeviceAdd\";\n          obj.type_index = 44;\n          break;\n        }\n        case 45: {\n          const length = decoder.uint32();\n          obj.MFADeviceDelete = MFADeviceDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"MFADeviceDelete\";\n          obj.type_index = 45;\n          break;\n        }\n        case 46: {\n          const length = decoder.uint32();\n          obj.BillingInformationUpdate =\n            BillingInformationUpdate.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n          decoder.skip(length);\n\n          obj.type = \"BillingInformationUpdate\";\n          obj.type_index = 46;\n          break;\n        }\n        case 47: {\n          const length = decoder.uint32();\n          obj.BillingCardCreate = BillingCardCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"BillingCardCreate\";\n          obj.type_index = 47;\n          break;\n        }\n        case 48: {\n          const length = decoder.uint32();\n          obj.BillingCardDelete = BillingCardDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"BillingCardDelete\";\n          obj.type_index = 48;\n          break;\n        }\n        case 49: {\n          const length = decoder.uint32();\n          obj.LockCreate = LockCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"LockCreate\";\n          obj.type_index = 49;\n          break;\n        }\n        case 50: {\n          const length = decoder.uint32();\n          obj.LockDelete = LockDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"LockDelete\";\n          obj.type_index = 50;\n          break;\n        }\n        case 51: {\n          const length = decoder.uint32();\n          obj.RecoveryCodeGenerate = RecoveryCodeGenerate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"RecoveryCodeGenerate\";\n          obj.type_index = 51;\n          break;\n        }\n        case 52: {\n          const length = decoder.uint32();\n          obj.RecoveryCodeUsed = RecoveryCodeUsed.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"RecoveryCodeUsed\";\n          obj.type_index = 52;\n          break;\n        }\n        case 53: {\n          const length = decoder.uint32();\n          obj.DatabaseCreate = DatabaseCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"DatabaseCreate\";\n          obj.type_index = 53;\n          break;\n        }\n        case 54: {\n          const length = decoder.uint32();\n          obj.DatabaseUpdate = DatabaseUpdate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"DatabaseUpdate\";\n          obj.type_index = 54;\n          break;\n        }\n        case 55: {\n          const length = decoder.uint32();\n          obj.DatabaseDelete = DatabaseDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"DatabaseDelete\";\n          obj.type_index = 55;\n          break;\n        }\n        case 56: {\n          const length = decoder.uint32();\n          obj.AppCreate = AppCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"AppCreate\";\n          obj.type_index = 56;\n          break;\n        }\n        case 57: {\n          const length = decoder.uint32();\n          obj.AppUpdate = AppUpdate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"AppUpdate\";\n          obj.type_index = 57;\n          break;\n        }\n        case 58: {\n          const length = decoder.uint32();\n          obj.AppDelete = AppDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"AppDelete\";\n          obj.type_index = 58;\n          break;\n        }\n        case 59: {\n          const length = decoder.uint32();\n          obj.WindowsDesktopSessionStart =\n            WindowsDesktopSessionStart.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n          decoder.skip(length);\n\n          obj.type = \"WindowsDesktopSessionStart\";\n          obj.type_index = 59;\n          break;\n        }\n        case 60: {\n          const length = decoder.uint32();\n          obj.WindowsDesktopSessionEnd =\n            WindowsDesktopSessionEnd.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n          decoder.skip(length);\n\n          obj.type = \"WindowsDesktopSessionEnd\";\n          obj.type_index = 60;\n          break;\n        }\n        case 61: {\n          const length = decoder.uint32();\n          obj.PostgresParse = PostgresParse.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"PostgresParse\";\n          obj.type_index = 61;\n          break;\n        }\n        case 62: {\n          const length = decoder.uint32();\n          obj.PostgresBind = PostgresBind.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"PostgresBind\";\n          obj.type_index = 62;\n          break;\n        }\n        case 63: {\n          const length = decoder.uint32();\n          obj.PostgresExecute = PostgresExecute.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"PostgresExecute\";\n          obj.type_index = 63;\n          break;\n        }\n        case 64: {\n          const length = decoder.uint32();\n          obj.PostgresClose = PostgresClose.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"PostgresClose\";\n          obj.type_index = 64;\n          break;\n        }\n        case 65: {\n          const length = decoder.uint32();\n          obj.PostgresFunctionCall = PostgresFunctionCall.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"PostgresFunctionCall\";\n          obj.type_index = 65;\n          break;\n        }\n        case 66: {\n          const length = decoder.uint32();\n          obj.AccessRequestDelete = AccessRequestDelete.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"AccessRequestDelete\";\n          obj.type_index = 66;\n          break;\n        }\n        case 67: {\n          const length = decoder.uint32();\n          obj.SessionConnect = SessionConnect.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"SessionConnect\";\n          obj.type_index = 67;\n          break;\n        }\n        case 68: {\n          const length = decoder.uint32();\n          obj.CertificateCreate = CertificateCreate.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"CertificateCreate\";\n          obj.type_index = 68;\n          break;\n        }\n        case 69: {\n          const length = decoder.uint32();\n          obj.DesktopRecording = DesktopRecording.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"DesktopRecording\";\n          obj.type_index = 69;\n          break;\n        }\n        case 70: {\n          const length = decoder.uint32();\n          obj.DesktopClipboardSend = DesktopClipboardSend.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"DesktopClipboardSend\";\n          obj.type_index = 70;\n          break;\n        }\n        case 71: {\n          const length = decoder.uint32();\n          obj.DesktopClipboardReceive = DesktopClipboardReceive.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"DesktopClipboardReceive\";\n          obj.type_index = 71;\n          break;\n        }\n        case 72: {\n          const length = decoder.uint32();\n          obj.MySQLStatementPrepare = MySQLStatementPrepare.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"MySQLStatementPrepare\";\n          obj.type_index = 72;\n          break;\n        }\n        case 73: {\n          const length = decoder.uint32();\n          obj.MySQLStatementExecute = MySQLStatementExecute.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"MySQLStatementExecute\";\n          obj.type_index = 73;\n          break;\n        }\n        case 74: {\n          const length = decoder.uint32();\n          obj.MySQLStatementSendLongData =\n            MySQLStatementSendLongData.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n          decoder.skip(length);\n\n          obj.type = \"MySQLStatementSendLongData\";\n          obj.type_index = 74;\n          break;\n        }\n        case 75: {\n          const length = decoder.uint32();\n          obj.MySQLStatementClose = MySQLStatementClose.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"MySQLStatementClose\";\n          obj.type_index = 75;\n          break;\n        }\n        case 76: {\n          const length = decoder.uint32();\n          obj.MySQLStatementReset = MySQLStatementReset.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"MySQLStatementReset\";\n          obj.type_index = 76;\n          break;\n        }\n        case 77: {\n          const length = decoder.uint32();\n          obj.MySQLStatementFetch = MySQLStatementFetch.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"MySQLStatementFetch\";\n          obj.type_index = 77;\n          break;\n        }\n        case 78: {\n          const length = decoder.uint32();\n          obj.MySQLStatementBulkExecute =\n            MySQLStatementBulkExecute.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n          decoder.skip(length);\n\n          obj.type = \"MySQLStatementBulkExecute\";\n          obj.type_index = 78;\n          break;\n        }\n        case 79: {\n          const length = decoder.uint32();\n          obj.RenewableCertificateGenerationMismatch =\n            RenewableCertificateGenerationMismatch.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n          decoder.skip(length);\n\n          obj.type = \"RenewableCertificateGenerationMismatch\";\n          obj.type_index = 79;\n          break;\n        }\n        case 80: {\n          const length = decoder.uint32();\n          obj.Unknown = Unknown.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          obj.type = \"Unknown\";\n          obj.type_index = 80;\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode OneOf\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.UserLogin != null) {\n      const f: UserLogin = this.UserLogin as UserLogin;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.UserCreate != null) {\n      const f: UserCreate = this.UserCreate as UserCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.UserDelete != null) {\n      const f: UserDelete = this.UserDelete as UserDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.UserPasswordChange != null) {\n      const f: UserPasswordChange = this\n        .UserPasswordChange as UserPasswordChange;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionStart != null) {\n      const f: SessionStart = this.SessionStart as SessionStart;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionJoin != null) {\n      const f: SessionJoin = this.SessionJoin as SessionJoin;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionPrint != null) {\n      const f: SessionPrint = this.SessionPrint as SessionPrint;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionReject != null) {\n      const f: SessionReject = this.SessionReject as SessionReject;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Resize != null) {\n      const f: Resize = this.Resize as Resize;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionEnd != null) {\n      const f: SessionEnd = this.SessionEnd as SessionEnd;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionCommand != null) {\n      const f: SessionCommand = this.SessionCommand as SessionCommand;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionDisk != null) {\n      const f: SessionDisk = this.SessionDisk as SessionDisk;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionNetwork != null) {\n      const f: SessionNetwork = this.SessionNetwork as SessionNetwork;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionData != null) {\n      const f: SessionData = this.SessionData as SessionData;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionLeave != null) {\n      const f: SessionLeave = this.SessionLeave as SessionLeave;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.PortForward != null) {\n      const f: PortForward = this.PortForward as PortForward;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.X11Forward != null) {\n      const f: X11Forward = this.X11Forward as X11Forward;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SCP != null) {\n      const f: SCP = this.SCP as SCP;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Exec != null) {\n      const f: Exec = this.Exec as Exec;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Subsystem != null) {\n      const f: Subsystem = this.Subsystem as Subsystem;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.ClientDisconnect != null) {\n      const f: ClientDisconnect = this.ClientDisconnect as ClientDisconnect;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AuthAttempt != null) {\n      const f: AuthAttempt = this.AuthAttempt as AuthAttempt;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AccessRequestCreate != null) {\n      const f: AccessRequestCreate = this\n        .AccessRequestCreate as AccessRequestCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.UserTokenCreate != null) {\n      const f: UserTokenCreate = this.UserTokenCreate as UserTokenCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.RoleCreate != null) {\n      const f: RoleCreate = this.RoleCreate as RoleCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.RoleDelete != null) {\n      const f: RoleDelete = this.RoleDelete as RoleDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.TrustedClusterCreate != null) {\n      const f: TrustedClusterCreate = this\n        .TrustedClusterCreate as TrustedClusterCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.TrustedClusterDelete != null) {\n      const f: TrustedClusterDelete = this\n        .TrustedClusterDelete as TrustedClusterDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.TrustedClusterTokenCreate != null) {\n      const f: TrustedClusterTokenCreate = this\n        .TrustedClusterTokenCreate as TrustedClusterTokenCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.GithubConnectorCreate != null) {\n      const f: GithubConnectorCreate = this\n        .GithubConnectorCreate as GithubConnectorCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.GithubConnectorDelete != null) {\n      const f: GithubConnectorDelete = this\n        .GithubConnectorDelete as GithubConnectorDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.OIDCConnectorCreate != null) {\n      const f: OIDCConnectorCreate = this\n        .OIDCConnectorCreate as OIDCConnectorCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.OIDCConnectorDelete != null) {\n      const f: OIDCConnectorDelete = this\n        .OIDCConnectorDelete as OIDCConnectorDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SAMLConnectorCreate != null) {\n      const f: SAMLConnectorCreate = this\n        .SAMLConnectorCreate as SAMLConnectorCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SAMLConnectorDelete != null) {\n      const f: SAMLConnectorDelete = this\n        .SAMLConnectorDelete as SAMLConnectorDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.KubeRequest != null) {\n      const f: KubeRequest = this.KubeRequest as KubeRequest;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AppSessionStart != null) {\n      const f: AppSessionStart = this.AppSessionStart as AppSessionStart;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AppSessionChunk != null) {\n      const f: AppSessionChunk = this.AppSessionChunk as AppSessionChunk;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AppSessionRequest != null) {\n      const f: AppSessionRequest = this.AppSessionRequest as AppSessionRequest;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.DatabaseSessionStart != null) {\n      const f: DatabaseSessionStart = this\n        .DatabaseSessionStart as DatabaseSessionStart;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.DatabaseSessionEnd != null) {\n      const f: DatabaseSessionEnd = this\n        .DatabaseSessionEnd as DatabaseSessionEnd;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.DatabaseSessionQuery != null) {\n      const f: DatabaseSessionQuery = this\n        .DatabaseSessionQuery as DatabaseSessionQuery;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionUpload != null) {\n      const f: SessionUpload = this.SessionUpload as SessionUpload;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.MFADeviceAdd != null) {\n      const f: MFADeviceAdd = this.MFADeviceAdd as MFADeviceAdd;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.MFADeviceDelete != null) {\n      const f: MFADeviceDelete = this.MFADeviceDelete as MFADeviceDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.BillingInformationUpdate != null) {\n      const f: BillingInformationUpdate = this\n        .BillingInformationUpdate as BillingInformationUpdate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.BillingCardCreate != null) {\n      const f: BillingCardCreate = this.BillingCardCreate as BillingCardCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.BillingCardDelete != null) {\n      const f: BillingCardDelete = this.BillingCardDelete as BillingCardDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.LockCreate != null) {\n      const f: LockCreate = this.LockCreate as LockCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.LockDelete != null) {\n      const f: LockDelete = this.LockDelete as LockDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.RecoveryCodeGenerate != null) {\n      const f: RecoveryCodeGenerate = this\n        .RecoveryCodeGenerate as RecoveryCodeGenerate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.RecoveryCodeUsed != null) {\n      const f: RecoveryCodeUsed = this.RecoveryCodeUsed as RecoveryCodeUsed;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.DatabaseCreate != null) {\n      const f: DatabaseCreate = this.DatabaseCreate as DatabaseCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.DatabaseUpdate != null) {\n      const f: DatabaseUpdate = this.DatabaseUpdate as DatabaseUpdate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.DatabaseDelete != null) {\n      const f: DatabaseDelete = this.DatabaseDelete as DatabaseDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AppCreate != null) {\n      const f: AppCreate = this.AppCreate as AppCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AppUpdate != null) {\n      const f: AppUpdate = this.AppUpdate as AppUpdate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AppDelete != null) {\n      const f: AppDelete = this.AppDelete as AppDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.WindowsDesktopSessionStart != null) {\n      const f: WindowsDesktopSessionStart = this\n        .WindowsDesktopSessionStart as WindowsDesktopSessionStart;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.WindowsDesktopSessionEnd != null) {\n      const f: WindowsDesktopSessionEnd = this\n        .WindowsDesktopSessionEnd as WindowsDesktopSessionEnd;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.PostgresParse != null) {\n      const f: PostgresParse = this.PostgresParse as PostgresParse;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.PostgresBind != null) {\n      const f: PostgresBind = this.PostgresBind as PostgresBind;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.PostgresExecute != null) {\n      const f: PostgresExecute = this.PostgresExecute as PostgresExecute;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.PostgresClose != null) {\n      const f: PostgresClose = this.PostgresClose as PostgresClose;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.PostgresFunctionCall != null) {\n      const f: PostgresFunctionCall = this\n        .PostgresFunctionCall as PostgresFunctionCall;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.AccessRequestDelete != null) {\n      const f: AccessRequestDelete = this\n        .AccessRequestDelete as AccessRequestDelete;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionConnect != null) {\n      const f: SessionConnect = this.SessionConnect as SessionConnect;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.CertificateCreate != null) {\n      const f: CertificateCreate = this.CertificateCreate as CertificateCreate;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.DesktopRecording != null) {\n      const f: DesktopRecording = this.DesktopRecording as DesktopRecording;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.DesktopClipboardSend != null) {\n      const f: DesktopClipboardSend = this\n        .DesktopClipboardSend as DesktopClipboardSend;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.DesktopClipboardReceive != null) {\n      const f: DesktopClipboardReceive = this\n        .DesktopClipboardReceive as DesktopClipboardReceive;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.MySQLStatementPrepare != null) {\n      const f: MySQLStatementPrepare = this\n        .MySQLStatementPrepare as MySQLStatementPrepare;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.MySQLStatementExecute != null) {\n      const f: MySQLStatementExecute = this\n        .MySQLStatementExecute as MySQLStatementExecute;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.MySQLStatementSendLongData != null) {\n      const f: MySQLStatementSendLongData = this\n        .MySQLStatementSendLongData as MySQLStatementSendLongData;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.MySQLStatementClose != null) {\n      const f: MySQLStatementClose = this\n        .MySQLStatementClose as MySQLStatementClose;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.MySQLStatementReset != null) {\n      const f: MySQLStatementReset = this\n        .MySQLStatementReset as MySQLStatementReset;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.MySQLStatementFetch != null) {\n      const f: MySQLStatementFetch = this\n        .MySQLStatementFetch as MySQLStatementFetch;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.MySQLStatementBulkExecute != null) {\n      const f: MySQLStatementBulkExecute = this\n        .MySQLStatementBulkExecute as MySQLStatementBulkExecute;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.RenewableCertificateGenerationMismatch != null) {\n      const f: RenewableCertificateGenerationMismatch = this\n        .RenewableCertificateGenerationMismatch as RenewableCertificateGenerationMismatch;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Unknown != null) {\n      const f: Unknown = this.Unknown as Unknown;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes OneOf to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes OneOf to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.UserLogin != null) {\n      const f = this.UserLogin as UserLogin;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.UserCreate != null) {\n      const f = this.UserCreate as UserCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.UserDelete != null) {\n      const f = this.UserDelete as UserDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.UserPasswordChange != null) {\n      const f = this.UserPasswordChange as UserPasswordChange;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionStart != null) {\n      const f = this.SessionStart as SessionStart;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x2a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionJoin != null) {\n      const f = this.SessionJoin as SessionJoin;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x32);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionPrint != null) {\n      const f = this.SessionPrint as SessionPrint;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x3a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionReject != null) {\n      const f = this.SessionReject as SessionReject;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Resize != null) {\n      const f = this.Resize as Resize;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x4a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionEnd != null) {\n      const f = this.SessionEnd as SessionEnd;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x52);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionCommand != null) {\n      const f = this.SessionCommand as SessionCommand;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x5a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionDisk != null) {\n      const f = this.SessionDisk as SessionDisk;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x62);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionNetwork != null) {\n      const f = this.SessionNetwork as SessionNetwork;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x6a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionData != null) {\n      const f = this.SessionData as SessionData;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x72);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionLeave != null) {\n      const f = this.SessionLeave as SessionLeave;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x7a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.PortForward != null) {\n      const f = this.PortForward as PortForward;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x82);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.X11Forward != null) {\n      const f = this.X11Forward as X11Forward;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x8a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SCP != null) {\n      const f = this.SCP as SCP;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x92);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Exec != null) {\n      const f = this.Exec as Exec;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x9a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Subsystem != null) {\n      const f = this.Subsystem as Subsystem;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.ClientDisconnect != null) {\n      const f = this.ClientDisconnect as ClientDisconnect;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xaa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AuthAttempt != null) {\n      const f = this.AuthAttempt as AuthAttempt;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xb2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AccessRequestCreate != null) {\n      const f = this.AccessRequestCreate as AccessRequestCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xba);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.UserTokenCreate != null) {\n      const f = this.UserTokenCreate as UserTokenCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xc2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RoleCreate != null) {\n      const f = this.RoleCreate as RoleCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xca);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RoleDelete != null) {\n      const f = this.RoleDelete as RoleDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xd2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.TrustedClusterCreate != null) {\n      const f = this.TrustedClusterCreate as TrustedClusterCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xda);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.TrustedClusterDelete != null) {\n      const f = this.TrustedClusterDelete as TrustedClusterDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xe2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.TrustedClusterTokenCreate != null) {\n      const f = this.TrustedClusterTokenCreate as TrustedClusterTokenCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xea);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.GithubConnectorCreate != null) {\n      const f = this.GithubConnectorCreate as GithubConnectorCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xf2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.GithubConnectorDelete != null) {\n      const f = this.GithubConnectorDelete as GithubConnectorDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xfa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.OIDCConnectorCreate != null) {\n      const f = this.OIDCConnectorCreate as OIDCConnectorCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x102);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.OIDCConnectorDelete != null) {\n      const f = this.OIDCConnectorDelete as OIDCConnectorDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x10a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SAMLConnectorCreate != null) {\n      const f = this.SAMLConnectorCreate as SAMLConnectorCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x112);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SAMLConnectorDelete != null) {\n      const f = this.SAMLConnectorDelete as SAMLConnectorDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x11a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.KubeRequest != null) {\n      const f = this.KubeRequest as KubeRequest;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x122);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AppSessionStart != null) {\n      const f = this.AppSessionStart as AppSessionStart;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AppSessionChunk != null) {\n      const f = this.AppSessionChunk as AppSessionChunk;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x132);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AppSessionRequest != null) {\n      const f = this.AppSessionRequest as AppSessionRequest;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x13a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DatabaseSessionStart != null) {\n      const f = this.DatabaseSessionStart as DatabaseSessionStart;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x142);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DatabaseSessionEnd != null) {\n      const f = this.DatabaseSessionEnd as DatabaseSessionEnd;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x14a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DatabaseSessionQuery != null) {\n      const f = this.DatabaseSessionQuery as DatabaseSessionQuery;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x152);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionUpload != null) {\n      const f = this.SessionUpload as SessionUpload;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x15a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.MFADeviceAdd != null) {\n      const f = this.MFADeviceAdd as MFADeviceAdd;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x162);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.MFADeviceDelete != null) {\n      const f = this.MFADeviceDelete as MFADeviceDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x16a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.BillingInformationUpdate != null) {\n      const f = this.BillingInformationUpdate as BillingInformationUpdate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x172);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.BillingCardCreate != null) {\n      const f = this.BillingCardCreate as BillingCardCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x17a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.BillingCardDelete != null) {\n      const f = this.BillingCardDelete as BillingCardDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x182);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.LockCreate != null) {\n      const f = this.LockCreate as LockCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x18a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.LockDelete != null) {\n      const f = this.LockDelete as LockDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x192);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RecoveryCodeGenerate != null) {\n      const f = this.RecoveryCodeGenerate as RecoveryCodeGenerate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x19a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RecoveryCodeUsed != null) {\n      const f = this.RecoveryCodeUsed as RecoveryCodeUsed;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DatabaseCreate != null) {\n      const f = this.DatabaseCreate as DatabaseCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1aa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DatabaseUpdate != null) {\n      const f = this.DatabaseUpdate as DatabaseUpdate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1b2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DatabaseDelete != null) {\n      const f = this.DatabaseDelete as DatabaseDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1ba);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AppCreate != null) {\n      const f = this.AppCreate as AppCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1c2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AppUpdate != null) {\n      const f = this.AppUpdate as AppUpdate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1ca);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AppDelete != null) {\n      const f = this.AppDelete as AppDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1d2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.WindowsDesktopSessionStart != null) {\n      const f = this.WindowsDesktopSessionStart as WindowsDesktopSessionStart;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1da);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.WindowsDesktopSessionEnd != null) {\n      const f = this.WindowsDesktopSessionEnd as WindowsDesktopSessionEnd;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1e2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.PostgresParse != null) {\n      const f = this.PostgresParse as PostgresParse;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1ea);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.PostgresBind != null) {\n      const f = this.PostgresBind as PostgresBind;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1f2);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.PostgresExecute != null) {\n      const f = this.PostgresExecute as PostgresExecute;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1fa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.PostgresClose != null) {\n      const f = this.PostgresClose as PostgresClose;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x202);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.PostgresFunctionCall != null) {\n      const f = this.PostgresFunctionCall as PostgresFunctionCall;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x20a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.AccessRequestDelete != null) {\n      const f = this.AccessRequestDelete as AccessRequestDelete;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x212);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionConnect != null) {\n      const f = this.SessionConnect as SessionConnect;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x21a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.CertificateCreate != null) {\n      const f = this.CertificateCreate as CertificateCreate;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x222);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DesktopRecording != null) {\n      const f = this.DesktopRecording as DesktopRecording;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DesktopClipboardSend != null) {\n      const f = this.DesktopClipboardSend as DesktopClipboardSend;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x232);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DesktopClipboardReceive != null) {\n      const f = this.DesktopClipboardReceive as DesktopClipboardReceive;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x23a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.MySQLStatementPrepare != null) {\n      const f = this.MySQLStatementPrepare as MySQLStatementPrepare;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x242);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.MySQLStatementExecute != null) {\n      const f = this.MySQLStatementExecute as MySQLStatementExecute;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x24a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.MySQLStatementSendLongData != null) {\n      const f = this.MySQLStatementSendLongData as MySQLStatementSendLongData;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x252);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.MySQLStatementClose != null) {\n      const f = this.MySQLStatementClose as MySQLStatementClose;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x25a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.MySQLStatementReset != null) {\n      const f = this.MySQLStatementReset as MySQLStatementReset;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x262);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.MySQLStatementFetch != null) {\n      const f = this.MySQLStatementFetch as MySQLStatementFetch;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x26a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.MySQLStatementBulkExecute != null) {\n      const f = this.MySQLStatementBulkExecute as MySQLStatementBulkExecute;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x272);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RenewableCertificateGenerationMismatch != null) {\n      const f = this\n        .RenewableCertificateGenerationMismatch as RenewableCertificateGenerationMismatch;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x27a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Unknown != null) {\n      const f = this.Unknown as Unknown;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x282);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode OneOf\n} // OneOf\n\n// StreamStatus reflects stream status\nexport class StreamStatus {\n  // UploadID represents upload ID\n  public UploadID: string = \"\";\n  // LastEventIndex updates last event index\n  public LastEventIndex: i64;\n  // LastUploadTime is the time of the last upload\n  public LastUploadTime: google.protobuf.Timestamp =\n    new google.protobuf.Timestamp();\n\n  // Decodes StreamStatus from an ArrayBuffer\n  static decode(buf: ArrayBuffer): StreamStatus {\n    return StreamStatus.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes StreamStatus from a DataView\n  static decodeDataView(view: DataView): StreamStatus {\n    const decoder = new __proto.Decoder(view);\n    const obj = new StreamStatus();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.UploadID = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.LastEventIndex = decoder.int64();\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.LastUploadTime = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode StreamStatus\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.UploadID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.UploadID.length) +\n          this.UploadID.length\n        : 0;\n    size +=\n      this.LastEventIndex == 0\n        ? 0\n        : 1 + __proto.Sizer.int64(this.LastEventIndex);\n\n    if (this.LastUploadTime != null) {\n      const f: google.protobuf.Timestamp = this\n        .LastUploadTime as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes StreamStatus to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes StreamStatus to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.UploadID.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.UploadID.length);\n      encoder.string(this.UploadID);\n    }\n    if (this.LastEventIndex != 0) {\n      encoder.uint32(0x10);\n      encoder.int64(this.LastEventIndex);\n    }\n\n    if (this.LastUploadTime != null) {\n      const f = this.LastUploadTime as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode StreamStatus\n} // StreamStatus\n\n// SessionUpload is a session upload\nexport class SessionUpload {\n  // Metadata is a common event metadata\n  public Metadata: Metadata = new Metadata();\n  // SessionMetadata is a common event session metadata\n  public SessionMetadata: SessionMetadata = new SessionMetadata();\n  // ID is a unique event identifier\n  public UID: string = \"\";\n  // URL is where the url the session event data upload is at\n  public SessionURL: string = \"\";\n\n  // Decodes SessionUpload from an ArrayBuffer\n  static decode(buf: ArrayBuffer): SessionUpload {\n    return SessionUpload.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes SessionUpload from a DataView\n  static decodeDataView(view: DataView): SessionUpload {\n    const decoder = new __proto.Decoder(view);\n    const obj = new SessionUpload();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.SessionMetadata = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.UID = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.SessionURL = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode SessionUpload\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.SessionMetadata != null) {\n      const f: SessionMetadata = this.SessionMetadata as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.UID.length > 0\n        ? 1 + __proto.Sizer.varint64(this.UID.length) + this.UID.length\n        : 0;\n    size +=\n      this.SessionURL.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SessionURL.length) +\n          this.SessionURL.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes SessionUpload to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes SessionUpload to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.SessionMetadata != null) {\n      const f = this.SessionMetadata as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.UID.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.UID.length);\n      encoder.string(this.UID);\n    }\n    if (this.SessionURL.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.SessionURL.length);\n      encoder.string(this.SessionURL);\n    }\n\n    return buf;\n  } // encode SessionUpload\n} // SessionUpload\n\n/**\n * Identity matches github.com/gravitational/teleport/lib/tlsca.Identity except\n *  for RouteToApp and RouteToDatabase which are nullable and Traits which is\n *  represented as a google.protobuf.Struct (still containing a map from string\n *  to strings). Field names match other names already used in other events\n *  rather than the field names in tlsca.Identity.\n */\nexport class Identity {\n  // User is a username or name of the node connection\n  public User: string = \"\";\n  // Impersonator is a username of a user impersonating this user\n  public Impersonator: string = \"\";\n  // Roles is a list of groups (Teleport roles) encoded in the identity\n  public Roles: Array<string> = new Array<string>();\n  // Usage is a list of usage restrictions encoded in the identity\n  public Usage: Array<string> = new Array<string>();\n  // Logins is a list of Unix logins allowed.\n  public Logins: Array<string> = new Array<string>();\n  // KubernetesGroups is a list of Kubernetes groups allowed\n  public KubernetesGroups: Array<string> = new Array<string>();\n  // KubernetesUsers is a list of Kubernetes users allowed\n  public KubernetesUsers: Array<string> = new Array<string>();\n  // Expires specifies whenever the session will expire\n  public Expires: google.protobuf.Timestamp = new google.protobuf.Timestamp();\n  /**\n   * RouteToCluster specifies the target cluster\n   *  if present in the session\n   */\n  public RouteToCluster: string = \"\";\n  /**\n   * KubernetesCluster specifies the target kubernetes cluster for TLS\n   *  identities. This can be empty on older Teleport clients.\n   */\n  public KubernetesCluster: string = \"\";\n  // Traits hold claim data used to populate a role at runtime.\n  public Traits: wrappers.LabelValues = new wrappers.LabelValues();\n  /**\n   * RouteToApp holds routing information for applications. Routing metadata\n   *  allows Teleport web proxy to route HTTP requests to the appropriate\n   *  cluster and Teleport application proxy within the cluster.\n   */\n  public RouteToApp: RouteToApp = new RouteToApp();\n  /**\n   * TeleportCluster is the name of the teleport cluster that this identity\n   *  originated from. For TLS certs this may not be the same as cert issuer,\n   *  in case of multi-hop requests that originate from a remote cluster.\n   */\n  public TeleportCluster: string = \"\";\n  // RouteToDatabase contains routing information for databases.\n  public RouteToDatabase: RouteToDatabase = new RouteToDatabase();\n  // DatabaseNames is a list of allowed database names.\n  public DatabaseNames: Array<string> = new Array<string>();\n  // DatabaseUsers is a list of allowed database users.\n  public DatabaseUsers: Array<string> = new Array<string>();\n  /**\n   * MFADeviceUUID is the UUID of an MFA device when this Identity was\n   *  confirmed immediately after an MFA check.\n   */\n  public MFADeviceUUID: string = \"\";\n  // ClientIP is an observed IP of the client that this Identity represents.\n  public ClientIP: string = \"\";\n  // AWSRoleARNs is a list of allowed AWS role ARNs user can assume.\n  public AWSRoleARNs: Array<string> = new Array<string>();\n  // AccessRequests is a list of UUIDs of active requests for this Identity.\n  public AccessRequests: Array<string> = new Array<string>();\n  /**\n   * DisallowReissue is a flag that, if set, instructs the auth server to\n   *  deny any attempts to reissue new certificates while authenticated with\n   *  this certificate.\n   */\n  public DisallowReissue: bool;\n\n  // Decodes Identity from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Identity {\n    return Identity.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Identity from a DataView\n  static decodeDataView(view: DataView): Identity {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Identity();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.User = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Impersonator = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Roles.push(decoder.string());\n          break;\n        }\n        case 4: {\n          obj.Usage.push(decoder.string());\n          break;\n        }\n        case 5: {\n          obj.Logins.push(decoder.string());\n          break;\n        }\n        case 6: {\n          obj.KubernetesGroups.push(decoder.string());\n          break;\n        }\n        case 7: {\n          obj.KubernetesUsers.push(decoder.string());\n          break;\n        }\n        case 8: {\n          const length = decoder.uint32();\n          obj.Expires = google.protobuf.Timestamp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 9: {\n          obj.RouteToCluster = decoder.string();\n          break;\n        }\n        case 10: {\n          obj.KubernetesCluster = decoder.string();\n          break;\n        }\n        case 11: {\n          const length = decoder.uint32();\n          obj.Traits = wrappers.LabelValues.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 12: {\n          const length = decoder.uint32();\n          obj.RouteToApp = RouteToApp.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 13: {\n          obj.TeleportCluster = decoder.string();\n          break;\n        }\n        case 14: {\n          const length = decoder.uint32();\n          obj.RouteToDatabase = RouteToDatabase.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 15: {\n          obj.DatabaseNames.push(decoder.string());\n          break;\n        }\n        case 16: {\n          obj.DatabaseUsers.push(decoder.string());\n          break;\n        }\n        case 17: {\n          obj.MFADeviceUUID = decoder.string();\n          break;\n        }\n        case 18: {\n          obj.ClientIP = decoder.string();\n          break;\n        }\n        case 19: {\n          obj.AWSRoleARNs.push(decoder.string());\n          break;\n        }\n        case 20: {\n          obj.AccessRequests.push(decoder.string());\n          break;\n        }\n        case 21: {\n          obj.DisallowReissue = decoder.bool();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Identity\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.User.length > 0\n        ? 1 + __proto.Sizer.varint64(this.User.length) + this.User.length\n        : 0;\n    size +=\n      this.Impersonator.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Impersonator.length) +\n          this.Impersonator.length\n        : 0;\n\n    size += __size_string_repeated(this.Roles);\n\n    size += __size_string_repeated(this.Usage);\n\n    size += __size_string_repeated(this.Logins);\n\n    size += __size_string_repeated(this.KubernetesGroups);\n\n    size += __size_string_repeated(this.KubernetesUsers);\n\n    if (this.Expires != null) {\n      const f: google.protobuf.Timestamp = this\n        .Expires as google.protobuf.Timestamp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.RouteToCluster.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.RouteToCluster.length) +\n          this.RouteToCluster.length\n        : 0;\n    size +=\n      this.KubernetesCluster.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.KubernetesCluster.length) +\n          this.KubernetesCluster.length\n        : 0;\n\n    if (this.Traits != null) {\n      const f: wrappers.LabelValues = this.Traits as wrappers.LabelValues;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.RouteToApp != null) {\n      const f: RouteToApp = this.RouteToApp as RouteToApp;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.TeleportCluster.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.TeleportCluster.length) +\n          this.TeleportCluster.length\n        : 0;\n\n    if (this.RouteToDatabase != null) {\n      const f: RouteToDatabase = this.RouteToDatabase as RouteToDatabase;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size += __size_string_repeated(this.DatabaseNames);\n\n    size += __size_string_repeated(this.DatabaseUsers);\n\n    size +=\n      this.MFADeviceUUID.length > 0\n        ? 2 +\n          __proto.Sizer.varint64(this.MFADeviceUUID.length) +\n          this.MFADeviceUUID.length\n        : 0;\n    size +=\n      this.ClientIP.length > 0\n        ? 2 +\n          __proto.Sizer.varint64(this.ClientIP.length) +\n          this.ClientIP.length\n        : 0;\n\n    size += __size_string_repeated(this.AWSRoleARNs);\n\n    size += __size_string_repeated(this.AccessRequests);\n\n    size += this.DisallowReissue == 0 ? 0 : 2 + 1;\n\n    return size;\n  }\n\n  // Encodes Identity to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Identity to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.User.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.User.length);\n      encoder.string(this.User);\n    }\n    if (this.Impersonator.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Impersonator.length);\n      encoder.string(this.Impersonator);\n    }\n\n    if (this.Roles.length > 0) {\n      for (let n: i32 = 0; n < this.Roles.length; n++) {\n        encoder.uint32(0x1a);\n        encoder.uint32(this.Roles[n].length);\n        encoder.string(this.Roles[n]);\n      }\n    }\n\n    if (this.Usage.length > 0) {\n      for (let n: i32 = 0; n < this.Usage.length; n++) {\n        encoder.uint32(0x22);\n        encoder.uint32(this.Usage[n].length);\n        encoder.string(this.Usage[n]);\n      }\n    }\n\n    if (this.Logins.length > 0) {\n      for (let n: i32 = 0; n < this.Logins.length; n++) {\n        encoder.uint32(0x2a);\n        encoder.uint32(this.Logins[n].length);\n        encoder.string(this.Logins[n]);\n      }\n    }\n\n    if (this.KubernetesGroups.length > 0) {\n      for (let n: i32 = 0; n < this.KubernetesGroups.length; n++) {\n        encoder.uint32(0x32);\n        encoder.uint32(this.KubernetesGroups[n].length);\n        encoder.string(this.KubernetesGroups[n]);\n      }\n    }\n\n    if (this.KubernetesUsers.length > 0) {\n      for (let n: i32 = 0; n < this.KubernetesUsers.length; n++) {\n        encoder.uint32(0x3a);\n        encoder.uint32(this.KubernetesUsers[n].length);\n        encoder.string(this.KubernetesUsers[n]);\n      }\n    }\n\n    if (this.Expires != null) {\n      const f = this.Expires as google.protobuf.Timestamp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x42);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RouteToCluster.length > 0) {\n      encoder.uint32(0x4a);\n      encoder.uint32(this.RouteToCluster.length);\n      encoder.string(this.RouteToCluster);\n    }\n    if (this.KubernetesCluster.length > 0) {\n      encoder.uint32(0x52);\n      encoder.uint32(this.KubernetesCluster.length);\n      encoder.string(this.KubernetesCluster);\n    }\n\n    if (this.Traits != null) {\n      const f = this.Traits as wrappers.LabelValues;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x5a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.RouteToApp != null) {\n      const f = this.RouteToApp as RouteToApp;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x62);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.TeleportCluster.length > 0) {\n      encoder.uint32(0x6a);\n      encoder.uint32(this.TeleportCluster.length);\n      encoder.string(this.TeleportCluster);\n    }\n\n    if (this.RouteToDatabase != null) {\n      const f = this.RouteToDatabase as RouteToDatabase;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x72);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.DatabaseNames.length > 0) {\n      for (let n: i32 = 0; n < this.DatabaseNames.length; n++) {\n        encoder.uint32(0x7a);\n        encoder.uint32(this.DatabaseNames[n].length);\n        encoder.string(this.DatabaseNames[n]);\n      }\n    }\n\n    if (this.DatabaseUsers.length > 0) {\n      for (let n: i32 = 0; n < this.DatabaseUsers.length; n++) {\n        encoder.uint32(0x82);\n        encoder.uint32(this.DatabaseUsers[n].length);\n        encoder.string(this.DatabaseUsers[n]);\n      }\n    }\n\n    if (this.MFADeviceUUID.length > 0) {\n      encoder.uint32(0x8a);\n      encoder.uint32(this.MFADeviceUUID.length);\n      encoder.string(this.MFADeviceUUID);\n    }\n    if (this.ClientIP.length > 0) {\n      encoder.uint32(0x92);\n      encoder.uint32(this.ClientIP.length);\n      encoder.string(this.ClientIP);\n    }\n\n    if (this.AWSRoleARNs.length > 0) {\n      for (let n: i32 = 0; n < this.AWSRoleARNs.length; n++) {\n        encoder.uint32(0x9a);\n        encoder.uint32(this.AWSRoleARNs[n].length);\n        encoder.string(this.AWSRoleARNs[n]);\n      }\n    }\n\n    if (this.AccessRequests.length > 0) {\n      for (let n: i32 = 0; n < this.AccessRequests.length; n++) {\n        encoder.uint32(0xa2);\n        encoder.uint32(this.AccessRequests[n].length);\n        encoder.string(this.AccessRequests[n]);\n      }\n    }\n\n    if (this.DisallowReissue != 0) {\n      encoder.uint32(0xa8);\n      encoder.bool(this.DisallowReissue);\n    }\n\n    return buf;\n  } // encode Identity\n} // Identity\n\n// RouteToApp contains parameters for application access certificate requests.\nexport class RouteToApp {\n  // Name is the application name certificate is being requested for.\n  public Name: string = \"\";\n  // SessionID is the ID of the application session.\n  public SessionID: string = \"\";\n  // PublicAddr is the application public address.\n  public PublicAddr: string = \"\";\n  // ClusterName is the cluster where the application resides.\n  public ClusterName: string = \"\";\n  // AWSRoleARN is the AWS role to assume when accessing AWS API.\n  public AWSRoleARN: string = \"\";\n\n  // Decodes RouteToApp from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RouteToApp {\n    return RouteToApp.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RouteToApp from a DataView\n  static decodeDataView(view: DataView): RouteToApp {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RouteToApp();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Name = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.SessionID = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.PublicAddr = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.ClusterName = decoder.string();\n          break;\n        }\n        case 5: {\n          obj.AWSRoleARN = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RouteToApp\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Name.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Name.length) + this.Name.length\n        : 0;\n    size +=\n      this.SessionID.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.SessionID.length) +\n          this.SessionID.length\n        : 0;\n    size +=\n      this.PublicAddr.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.PublicAddr.length) +\n          this.PublicAddr.length\n        : 0;\n    size +=\n      this.ClusterName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ClusterName.length) +\n          this.ClusterName.length\n        : 0;\n    size +=\n      this.AWSRoleARN.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.AWSRoleARN.length) +\n          this.AWSRoleARN.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes RouteToApp to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RouteToApp to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Name.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Name.length);\n      encoder.string(this.Name);\n    }\n    if (this.SessionID.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.SessionID.length);\n      encoder.string(this.SessionID);\n    }\n    if (this.PublicAddr.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.PublicAddr.length);\n      encoder.string(this.PublicAddr);\n    }\n    if (this.ClusterName.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.ClusterName.length);\n      encoder.string(this.ClusterName);\n    }\n    if (this.AWSRoleARN.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.AWSRoleARN.length);\n      encoder.string(this.AWSRoleARN);\n    }\n\n    return buf;\n  } // encode RouteToApp\n} // RouteToApp\n\n// RouteToDatabase combines parameters for database service routing information.\nexport class RouteToDatabase {\n  // ServiceName is the Teleport database proxy service name the cert is for.\n  public ServiceName: string = \"\";\n  // Protocol is the type of the database the cert is for.\n  public Protocol: string = \"\";\n  // Username is an optional database username to embed.\n  public Username: string = \"\";\n  // Database is an optional database name to embed.\n  public Database: string = \"\";\n\n  // Decodes RouteToDatabase from an ArrayBuffer\n  static decode(buf: ArrayBuffer): RouteToDatabase {\n    return RouteToDatabase.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes RouteToDatabase from a DataView\n  static decodeDataView(view: DataView): RouteToDatabase {\n    const decoder = new __proto.Decoder(view);\n    const obj = new RouteToDatabase();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.ServiceName = decoder.string();\n          break;\n        }\n        case 2: {\n          obj.Protocol = decoder.string();\n          break;\n        }\n        case 3: {\n          obj.Username = decoder.string();\n          break;\n        }\n        case 4: {\n          obj.Database = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode RouteToDatabase\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.ServiceName.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.ServiceName.length) +\n          this.ServiceName.length\n        : 0;\n    size +=\n      this.Protocol.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Protocol.length) +\n          this.Protocol.length\n        : 0;\n    size +=\n      this.Username.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Username.length) +\n          this.Username.length\n        : 0;\n    size +=\n      this.Database.length > 0\n        ? 1 +\n          __proto.Sizer.varint64(this.Database.length) +\n          this.Database.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes RouteToDatabase to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes RouteToDatabase to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.ServiceName.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.ServiceName.length);\n      encoder.string(this.ServiceName);\n    }\n    if (this.Protocol.length > 0) {\n      encoder.uint32(0x12);\n      encoder.uint32(this.Protocol.length);\n      encoder.string(this.Protocol);\n    }\n    if (this.Username.length > 0) {\n      encoder.uint32(0x1a);\n      encoder.uint32(this.Username.length);\n      encoder.string(this.Username);\n    }\n    if (this.Database.length > 0) {\n      encoder.uint32(0x22);\n      encoder.uint32(this.Database.length);\n      encoder.string(this.Database);\n    }\n\n    return buf;\n  } // encode RouteToDatabase\n} // RouteToDatabase\n\n/**\n * MySQLStatementPrepare is emitted when a MySQL client creates a prepared\n *  statement using the prepared statement protocol.\n */\nexport class MySQLStatementPrepare {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // Query is the prepared statement query.\n  public Query: string = \"\";\n\n  // Decodes MySQLStatementPrepare from an ArrayBuffer\n  static decode(buf: ArrayBuffer): MySQLStatementPrepare {\n    return MySQLStatementPrepare.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes MySQLStatementPrepare from a DataView\n  static decodeDataView(view: DataView): MySQLStatementPrepare {\n    const decoder = new __proto.Decoder(view);\n    const obj = new MySQLStatementPrepare();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.Query = decoder.string();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode MySQLStatementPrepare\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.Query.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Query.length) + this.Query.length\n        : 0;\n\n    return size;\n  }\n\n  // Encodes MySQLStatementPrepare to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes MySQLStatementPrepare to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Query.length > 0) {\n      encoder.uint32(0x2a);\n      encoder.uint32(this.Query.length);\n      encoder.string(this.Query);\n    }\n\n    return buf;\n  } // encode MySQLStatementPrepare\n} // MySQLStatementPrepare\n\n/**\n * MySQLStatementExecute is emitted when a MySQL client executes a prepared\n *  statement using the prepared statement protocol.\n */\nexport class MySQLStatementExecute {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // StatementID is the identifier of the prepared statement.\n  public StatementID: u32;\n  // Parameters are the parameters used to execute the prepared statement.\n  public Parameters: Array<string> = new Array<string>();\n\n  // Decodes MySQLStatementExecute from an ArrayBuffer\n  static decode(buf: ArrayBuffer): MySQLStatementExecute {\n    return MySQLStatementExecute.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes MySQLStatementExecute from a DataView\n  static decodeDataView(view: DataView): MySQLStatementExecute {\n    const decoder = new __proto.Decoder(view);\n    const obj = new MySQLStatementExecute();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.StatementID = decoder.uint32();\n          break;\n        }\n        case 6: {\n          obj.Parameters.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode MySQLStatementExecute\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.StatementID == 0 ? 0 : 1 + __proto.Sizer.uint32(this.StatementID);\n\n    size += __size_string_repeated(this.Parameters);\n\n    return size;\n  }\n\n  // Encodes MySQLStatementExecute to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes MySQLStatementExecute to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.StatementID != 0) {\n      encoder.uint32(0x28);\n      encoder.uint32(this.StatementID);\n    }\n\n    if (this.Parameters.length > 0) {\n      for (let n: i32 = 0; n < this.Parameters.length; n++) {\n        encoder.uint32(0x32);\n        encoder.uint32(this.Parameters[n].length);\n        encoder.string(this.Parameters[n]);\n      }\n    }\n\n    return buf;\n  } // encode MySQLStatementExecute\n} // MySQLStatementExecute\n\n/**\n * MySQLStatementSendLongData is emitted when a MySQL client sends long bytes\n *  stream using the prepared statement protocol.\n */\nexport class MySQLStatementSendLongData {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // StatementID is the identifier of the prepared statement.\n  public StatementID: u32;\n  // ParameterID is the identifier of the parameter.\n  public ParameterID: u32;\n  // DataSize is the size of the data.\n  public DataSize: u32;\n\n  // Decodes MySQLStatementSendLongData from an ArrayBuffer\n  static decode(buf: ArrayBuffer): MySQLStatementSendLongData {\n    return MySQLStatementSendLongData.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes MySQLStatementSendLongData from a DataView\n  static decodeDataView(view: DataView): MySQLStatementSendLongData {\n    const decoder = new __proto.Decoder(view);\n    const obj = new MySQLStatementSendLongData();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.StatementID = decoder.uint32();\n          break;\n        }\n        case 6: {\n          obj.ParameterID = decoder.uint32();\n          break;\n        }\n        case 7: {\n          obj.DataSize = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode MySQLStatementSendLongData\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.StatementID == 0 ? 0 : 1 + __proto.Sizer.uint32(this.StatementID);\n    size +=\n      this.ParameterID == 0 ? 0 : 1 + __proto.Sizer.uint32(this.ParameterID);\n    size += this.DataSize == 0 ? 0 : 1 + __proto.Sizer.uint32(this.DataSize);\n\n    return size;\n  }\n\n  // Encodes MySQLStatementSendLongData to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes MySQLStatementSendLongData to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.StatementID != 0) {\n      encoder.uint32(0x28);\n      encoder.uint32(this.StatementID);\n    }\n    if (this.ParameterID != 0) {\n      encoder.uint32(0x30);\n      encoder.uint32(this.ParameterID);\n    }\n    if (this.DataSize != 0) {\n      encoder.uint32(0x38);\n      encoder.uint32(this.DataSize);\n    }\n\n    return buf;\n  } // encode MySQLStatementSendLongData\n} // MySQLStatementSendLongData\n\n/**\n * MySQLStatementClose is emitted when a MySQL client deallocates a prepared\n *  statement using the prepared statement protocol.\n */\nexport class MySQLStatementClose {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // StatementID is the identifier of the prepared statement.\n  public StatementID: u32;\n\n  // Decodes MySQLStatementClose from an ArrayBuffer\n  static decode(buf: ArrayBuffer): MySQLStatementClose {\n    return MySQLStatementClose.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes MySQLStatementClose from a DataView\n  static decodeDataView(view: DataView): MySQLStatementClose {\n    const decoder = new __proto.Decoder(view);\n    const obj = new MySQLStatementClose();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.StatementID = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode MySQLStatementClose\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.StatementID == 0 ? 0 : 1 + __proto.Sizer.uint32(this.StatementID);\n\n    return size;\n  }\n\n  // Encodes MySQLStatementClose to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes MySQLStatementClose to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.StatementID != 0) {\n      encoder.uint32(0x28);\n      encoder.uint32(this.StatementID);\n    }\n\n    return buf;\n  } // encode MySQLStatementClose\n} // MySQLStatementClose\n\n/**\n * MySQLStatementReset is emitted when a MySQL client resets the data of a\n *  prepared statement using the prepared statement protocol.\n */\nexport class MySQLStatementReset {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // StatementID is the identifier of the prepared statement.\n  public StatementID: u32;\n\n  // Decodes MySQLStatementReset from an ArrayBuffer\n  static decode(buf: ArrayBuffer): MySQLStatementReset {\n    return MySQLStatementReset.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes MySQLStatementReset from a DataView\n  static decodeDataView(view: DataView): MySQLStatementReset {\n    const decoder = new __proto.Decoder(view);\n    const obj = new MySQLStatementReset();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.StatementID = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode MySQLStatementReset\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.StatementID == 0 ? 0 : 1 + __proto.Sizer.uint32(this.StatementID);\n\n    return size;\n  }\n\n  // Encodes MySQLStatementReset to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes MySQLStatementReset to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.StatementID != 0) {\n      encoder.uint32(0x28);\n      encoder.uint32(this.StatementID);\n    }\n\n    return buf;\n  } // encode MySQLStatementReset\n} // MySQLStatementReset\n\n/**\n * MySQLStatementFetch is emitted when a MySQL client fetches rows from a\n *  prepared statement using the prepared statement protocol.\n */\nexport class MySQLStatementFetch {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // StatementID is the identifier of the prepared statement.\n  public StatementID: u32;\n  // RowsCount is the number of rows to fetch.\n  public RowsCount: u32;\n\n  // Decodes MySQLStatementFetch from an ArrayBuffer\n  static decode(buf: ArrayBuffer): MySQLStatementFetch {\n    return MySQLStatementFetch.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes MySQLStatementFetch from a DataView\n  static decodeDataView(view: DataView): MySQLStatementFetch {\n    const decoder = new __proto.Decoder(view);\n    const obj = new MySQLStatementFetch();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.StatementID = decoder.uint32();\n          break;\n        }\n        case 6: {\n          obj.RowsCount = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode MySQLStatementFetch\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.StatementID == 0 ? 0 : 1 + __proto.Sizer.uint32(this.StatementID);\n    size += this.RowsCount == 0 ? 0 : 1 + __proto.Sizer.uint32(this.RowsCount);\n\n    return size;\n  }\n\n  // Encodes MySQLStatementFetch to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes MySQLStatementFetch to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.StatementID != 0) {\n      encoder.uint32(0x28);\n      encoder.uint32(this.StatementID);\n    }\n    if (this.RowsCount != 0) {\n      encoder.uint32(0x30);\n      encoder.uint32(this.RowsCount);\n    }\n\n    return buf;\n  } // encode MySQLStatementFetch\n} // MySQLStatementFetch\n\n/**\n * MySQLStatementBulkExecute is emitted when a MySQL client executes a bulk\n *  insert of a prepared statement using the prepared statement protocol.\n */\nexport class MySQLStatementBulkExecute {\n  // Metadata is a common event metadata.\n  public Metadata: Metadata = new Metadata();\n  // User is a common user event metadata.\n  public User: UserMetadata = new UserMetadata();\n  // SessionMetadata is a common event session metadata.\n  public Session: SessionMetadata = new SessionMetadata();\n  // Database contains database related metadata.\n  public Database: DatabaseMetadata = new DatabaseMetadata();\n  // StatementID is the identifier of the prepared statement.\n  public StatementID: u32;\n  // Parameters are the parameters used to execute the prepared statement.\n  public Parameters: Array<string> = new Array<string>();\n\n  // Decodes MySQLStatementBulkExecute from an ArrayBuffer\n  static decode(buf: ArrayBuffer): MySQLStatementBulkExecute {\n    return MySQLStatementBulkExecute.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes MySQLStatementBulkExecute from a DataView\n  static decodeDataView(view: DataView): MySQLStatementBulkExecute {\n    const decoder = new __proto.Decoder(view);\n    const obj = new MySQLStatementBulkExecute();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Metadata = Metadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.User = UserMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          obj.Session = SessionMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          const length = decoder.uint32();\n          obj.Database = DatabaseMetadata.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 5: {\n          obj.StatementID = decoder.uint32();\n          break;\n        }\n        case 6: {\n          obj.Parameters.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode MySQLStatementBulkExecute\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Metadata != null) {\n      const f: Metadata = this.Metadata as Metadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.User != null) {\n      const f: UserMetadata = this.User as UserMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Session != null) {\n      const f: SessionMetadata = this.Session as SessionMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Database != null) {\n      const f: DatabaseMetadata = this.Database as DatabaseMetadata;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    size +=\n      this.StatementID == 0 ? 0 : 1 + __proto.Sizer.uint32(this.StatementID);\n\n    size += __size_string_repeated(this.Parameters);\n\n    return size;\n  }\n\n  // Encodes MySQLStatementBulkExecute to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes MySQLStatementBulkExecute to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Metadata != null) {\n      const f = this.Metadata as Metadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.User != null) {\n      const f = this.User as UserMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Session != null) {\n      const f = this.Session as SessionMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Database != null) {\n      const f = this.Database as DatabaseMetadata;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x22);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.StatementID != 0) {\n      encoder.uint32(0x28);\n      encoder.uint32(this.StatementID);\n    }\n\n    if (this.Parameters.length > 0) {\n      for (let n: i32 = 0; n < this.Parameters.length; n++) {\n        encoder.uint32(0x32);\n        encoder.uint32(this.Parameters[n].length);\n        encoder.string(this.Parameters[n]);\n      }\n    }\n\n    return buf;\n  } // encode MySQLStatementBulkExecute\n} // MySQLStatementBulkExecute\n\n// __size_string_repeated\n\nfunction __size_string_repeated(value: Array<string>): u32 {\n  let size: u32 = 0;\n\n  for (let n: i32 = 0; n < value.length; n++) {\n    size += 1 + __proto.Sizer.varint64(value[n].length) + value[n].length;\n  }\n\n  return size;\n}\n\n// __decodeMap_string_string\n\nfunction __decodeMap_string_string(\n  parentDecoder: __proto.Decoder,\n  length: i32,\n  map: Map<string, string>\n): void {\n  const decoder = new __proto.Decoder(\n    new DataView(\n      parentDecoder.view.buffer,\n      parentDecoder.pos + parentDecoder.view.byteOffset,\n      length\n    )\n  );\n\n  let key: string = \"\";\n  let value: string = \"\";\n\n  while (!decoder.eof()) {\n    const tag = decoder.tag();\n    const number = tag >>> 3;\n\n    switch (number) {\n      case 1: {\n        key = decoder.string();\n        break;\n      }\n\n      case 2: {\n        value = decoder.string();\n        break;\n      }\n\n      default:\n        decoder.skipType(tag & 7);\n        break;\n    }\n  }\n  map.set(key as string, value as string);\n}\n\n// __sizeMapEntry_string_string\n\nfunction __sizeMapEntry_string_string(key: string, value: string): u32 {\n  return (\n    (key.length > 0 ? 1 + __proto.Sizer.varint64(key.length) + key.length : 0) +\n    (value.length > 0\n      ? 1 + __proto.Sizer.varint64(value.length) + value.length\n      : 0)\n  );\n}\n","import * as __proto from \"./__proto\";\n\nimport * as events from \"./events\";\n// Severity represents alert severity\nexport enum Severity {\n  DEBUG = 0,\n  INFO = 1,\n  NOTICE = 2,\n  WARNING = 3,\n  ERROR = 4,\n  CRITICAL = 5,\n  ALERT = 6,\n  EMERGENCY = 7,\n} // Severity\n// HandleEventRequest represents the request passing the event\nexport class HandleEventRequest {\n  public Event: events.OneOf = new events.OneOf();\n\n  // Decodes HandleEventRequest from an ArrayBuffer\n  static decode(buf: ArrayBuffer): HandleEventRequest {\n    return HandleEventRequest.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes HandleEventRequest from a DataView\n  static decodeDataView(view: DataView): HandleEventRequest {\n    const decoder = new __proto.Decoder(view);\n    const obj = new HandleEventRequest();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Event = events.OneOf.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode HandleEventRequest\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Event != null) {\n      const f: events.OneOf = this.Event as events.OneOf;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes HandleEventRequest to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes HandleEventRequest to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Event != null) {\n      const f = this.Event as events.OneOf;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode HandleEventRequest\n} // HandleEventRequest\n\n// HandleEventResponse represents the response, returning success status, error message and modified event (optional)\nexport class HandleEventResponse {\n  public Event: events.OneOf = new events.OneOf();\n\n  // Decodes HandleEventResponse from an ArrayBuffer\n  static decode(buf: ArrayBuffer): HandleEventResponse {\n    return HandleEventResponse.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes HandleEventResponse from a DataView\n  static decodeDataView(view: DataView): HandleEventResponse {\n    const decoder = new __proto.Decoder(view);\n    const obj = new HandleEventResponse();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          obj.Event = events.OneOf.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode HandleEventResponse\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Event != null) {\n      const f: events.OneOf = this.Event as events.OneOf;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes HandleEventResponse to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes HandleEventResponse to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Event != null) {\n      const f = this.Event as events.OneOf;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    return buf;\n  } // encode HandleEventResponse\n} // HandleEventResponse\n\n// Alert represents alert struct\nexport class Alert {\n  public Message: string = \"\";\n  public Event: events.OneOf = new events.OneOf();\n  public Metadata: Map<string, string> = new Map<string, string>();\n  public Severity: u32;\n\n  // Decodes Alert from an ArrayBuffer\n  static decode(buf: ArrayBuffer): Alert {\n    return Alert.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes Alert from a DataView\n  static decodeDataView(view: DataView): Alert {\n    const decoder = new __proto.Decoder(view);\n    const obj = new Alert();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Message = decoder.string();\n          break;\n        }\n        case 2: {\n          const length = decoder.uint32();\n          obj.Event = events.OneOf.decodeDataView(\n            new DataView(\n              decoder.view.buffer,\n              decoder.pos + decoder.view.byteOffset,\n              length\n            )\n          );\n          decoder.skip(length);\n\n          break;\n        }\n        case 3: {\n          const length = decoder.uint32();\n          __decodeMap_string_string(decoder, length, obj.Metadata);\n          decoder.skip(length);\n\n          break;\n        }\n        case 4: {\n          obj.Severity = decoder.uint32();\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode Alert\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size +=\n      this.Message.length > 0\n        ? 1 + __proto.Sizer.varint64(this.Message.length) + this.Message.length\n        : 0;\n\n    if (this.Event != null) {\n      const f: events.OneOf = this.Event as events.OneOf;\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n      }\n    }\n\n    if (this.Metadata.size > 0) {\n      const keys = this.Metadata.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Metadata.get(key);\n        const itemSize = __sizeMapEntry_string_string(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    size += this.Severity == 0 ? 0 : 1 + __proto.Sizer.uint32(this.Severity);\n\n    return size;\n  }\n\n  // Encodes Alert to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes Alert to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Message.length > 0) {\n      encoder.uint32(0xa);\n      encoder.uint32(this.Message.length);\n      encoder.string(this.Message);\n    }\n\n    if (this.Event != null) {\n      const f = this.Event as events.OneOf;\n\n      const messageSize = f.size();\n\n      if (messageSize > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(messageSize);\n        f.encodeU8Array(encoder);\n      }\n    }\n\n    if (this.Metadata.size > 0) {\n      const keys = this.Metadata.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Metadata.get(key);\n        const size = __sizeMapEntry_string_string(key, value);\n        if (size > 0) {\n          encoder.uint32(0x1a);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n          if (value.length > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(value.length);\n            encoder.string(value);\n          }\n        }\n      }\n    }\n\n    if (this.Severity != 0) {\n      encoder.uint32(0x20);\n      encoder.uint32(this.Severity);\n    }\n\n    return buf;\n  } // encode Alert\n} // Alert\n\n// __decodeMap_string_string\n\nfunction __decodeMap_string_string(\n  parentDecoder: __proto.Decoder,\n  length: i32,\n  map: Map<string, string>\n): void {\n  const decoder = new __proto.Decoder(\n    new DataView(\n      parentDecoder.view.buffer,\n      parentDecoder.pos + parentDecoder.view.byteOffset,\n      length\n    )\n  );\n\n  let key: string = \"\";\n  let value: string = \"\";\n\n  while (!decoder.eof()) {\n    const tag = decoder.tag();\n    const number = tag >>> 3;\n\n    switch (number) {\n      case 1: {\n        key = decoder.string();\n        break;\n      }\n\n      case 2: {\n        value = decoder.string();\n        break;\n      }\n\n      default:\n        decoder.skipType(tag & 7);\n        break;\n    }\n  }\n  map.set(key as string, value as string);\n}\n\n// __sizeMapEntry_string_string\n\nfunction __sizeMapEntry_string_string(key: string, value: string): u32 {\n  return (\n    (key.length > 0 ? 1 + __proto.Sizer.varint64(key.length) + key.length : 0) +\n    (value.length > 0\n      ? 1 + __proto.Sizer.varint64(value.length) + value.length\n      : 0)\n  );\n}\n","// WASM helper methods for pool_test.go\n\nimport { sleep } from 'as-sleep/assembly/index';\nimport { getSecretString } from '../boilerplate/vendor/aws_secrets_manager';\nimport { events, plugin } from '../boilerplate/vendor/teleport/teleport';\n\nexport declare function goMethod():void;\nexport declare function failingGoMethod():void;\n\nexport function ok():i32 {\n    return 1;\n}\n\nexport function throwError():void {\n    throw new Error(\"Failure\");\n}\n\nexport function getStringReturnString(key: string): string {\n    assert(key == \"foo\", \"getStringReturnString string is not 'foo'\")\n    return \"bar\"\n}\n\nexport function infiniteLoop():void {\n    while(1);\n}\n\nexport function delay100ms():void {\n    sleep(100);\n}\n\nexport function goMethodEntryPoint():void {\n    goMethod();\n}\n\nexport function failingGoMethodEntryPoint():void {\n    failingGoMethod();\n}\n\nexport function getEventIndex(view: ArrayBuffer):i64 {\n    const event = events.OneOf.decode(view)\n    if (event.UserCreate == null) {\n        return 0\n    }\n    const userCreate = event.UserCreate as events.UserCreate;\n    return userCreate.Metadata.Index\n}\n\nexport function handleEvent(view: ArrayBuffer): ArrayBuffer {\n    const request = plugin.HandleEventRequest.decode(view)\n    const response = new plugin.HandleEventResponse()\n\n    // On UserCreate return error\n    if (request.Event.type == \"UserCreate\") {\n        throw new Error(\"Abort!\")\n    } \n\n    // On UserLogin return success, modified event\n    if (request.Event.type == \"UserLogin\") {    \n        response.Event = request.Event;\n\n        const userLogin = response.Event.UserLogin as events.UserLogin\n        userLogin.Metadata.Index = 999;\n    }\n\n    // On UserDelete return success, no event\n    if (request.Event.type == \"UserDelete\") {\n        response.Event = new events.OneOf();\n    }\n\n    return response.encode();\n}\n\nexport function getSecret(name: string): string {\n    return getSecretString(name)\n}","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  var b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  var base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = value >>> 31;\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = u32(value >>> 63);\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy var _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp, exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n\n  var p1 = u32(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var size = dtoa_core(dtoa_buf, value) << 1;\n  var result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  var sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      value = changetype<T>(-value);\n      store<u16>(buffer, CharCode.MINUS);\n    }\n  }\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  var decimals = sign;\n  if (sizeof<T>() <= 4) {\n    decimals += decimalCount32(value);\n    utoa32_dec_core(buffer, value, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals += decimalCount32(val32);\n      utoa32_dec_core(buffer, val32, decimals);\n    } else {\n      decimals += decimalCount64High(value);\n      utoa64_dec_core(buffer, value, decimals);\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  var kd = xd + shift;\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  var z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  var kd = <f64>(z + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = z - (kd - shift);\n  var s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  var top  = tmp & 0xFF800000;\n  var iz   = ux - top;\n  var k    = <i32>tmp >> 23;\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y  = A1 * r + A2;\n  var p  = A3 * r + y0;\n  var r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ux - 0x3F330000;\n  var i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  var k   = <i32>tmp >> 23;\n  var iz  = ux - (tmp & 0x1FF << 23);\n\n  var invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  var z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  var r = z * invc - 1;\n  var y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  var r2 = r * r;\n  var y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  var e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = <usize>((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  var top  = tmp & 0xFF800000;\n  var uz   = ux - top;\n  var k    = <i32>(<i32>top >> 23);\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y = A0 * r + A1;\n  var p = A2 * r + A3;\n  var q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  var kd = <f64>(xd + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  var signBias: u32 = 0;\n  var ix = reinterpret<u32>(x);\n  var iy = reinterpret<u32>(y);\n  var ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return iy >> 31 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (ix >> 31) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  var logx = log2f_inline(ix);\n  var ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  var scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  var y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7FF);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      return select<f64>(0, Infinity, ux >> 63);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  var z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // var kd = z + shift;\n  // var ki = reinterpret<u64>(kd) >> 16;\n  // var kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  var kd = z + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  var r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  var scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  var y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7ff);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (!(ux >> 63)) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  var kd = x + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  var r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\n  //            invc                  ,                logc\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\n  //              chi                 ,                 clo\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  var top = <u32>(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & 0xFFF0000000000000);\n\n  var invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n  var kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  var chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  var clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  var r   = (z - chi - clo) * invc;\n  var rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  var rlo = r - rhi;\n  var t1  = rhi * InvLn2hi;\n  var t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  var t3 = kd + logc;\n  var hi = t3 + t1;\n  var lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  var p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\n  //              invc                ,                 logc\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\n  //               chi                ,                  clo\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  var top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  var invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  var r = (z - chi - clo) * invc;\n  // #endif\n  var kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  var w  = kd * Ln2hi + logc;\n  var hi = w + r;\n  var lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\n  //             invc                 ,pad,               logc                 ,               logctail\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  var e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy var log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ix - 0x3fE6955500000000;\n  var i   = <usize>((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  var k   = <i64>tmp >> 52;\n  var iz  = ix - (tmp & u64(0xFFF) << 52);\n  var z   = reinterpret<f64>(iz);\n  var kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  var invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  var logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  var logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  var zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  var zlo = z - zhi;\n  var rhi = zhi * invc - 1.0;\n  var rlo = zlo * invc;\n  var r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  var t1  = kd * Ln2hi + logc;\n  var t2  = t1 + r;\n  var lo1 = kd * Ln2lo + logctail;\n  var lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var ar  = A0 * r; // A[0] = -0.5\n  var ar2 = r * ar;\n  var ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  var arhi  = A0  * rhi;\n  var arhi2 = rhi * arhi;\n  var hi    = t2  + arhi2;\n  var lo3   = rlo * (ar + arhi);\n  var lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  var p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  var lo = lo1 + lo2 + lo3 + lo4 + p;\n  var y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var abstop: u32;\n  var ki: u64, top: u64, sbits: u64;\n  var idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  var kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  var ux = reinterpret<u64>(x);\n  abstop = <u32>(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return ux >> 63 ? uflow(sign_bias) : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = <usize>((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var sign_bias: u32 = 0;\n  var ix = reinterpret<u64>(x);\n  var iy = reinterpret<u64>(y);\n  var topx = ix >> 52;\n  var topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return iy >> 63 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (ix >> 63) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  var hi = log_inline(ix);\n  var lo = log_tail;\n  var ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  var yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  var ylo = y - yhi;\n  var lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  var llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa, itoa_buffered, dtoa_buffered, MAX_DOUBLE_LENGTH } from \"./number\";\nimport { ipow32 } from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  var found = false;\n  var pos = index;\n  var minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  var maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  var c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  var sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  var initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  var len = str.length;\n  if (!len) return NaN;\n\n  var ptr  = changetype<usize>(str);\n  var code = <u32>load<u16>(ptr);\n\n  var sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  var savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0;\n  const capacity = 19; // int(64 * 0.3010)\n  var pointed = false;\n  var consumed = 0;\n  var position = 0;\n  var x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  var sepLen = separator.length;\n  var valueLen = 5; // max possible length of element len(\"false\")\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  var sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  var sepLen = separator.length;\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  var estLen = 0;\n  var value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  var offset = 0;\n  var sepLen = separator.length;\n  var result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  var value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  var result = \"\";\n  var sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  var significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  var shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  var b = <u64>ipow32(5, -exp);\n  var q = significand / b;\n  var r = significand % b;\n  var s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  var shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  var sign = 1, magnitude = 0;\n  var code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy var __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  var low  = (a & 0xFFFFFFFF) * b;\n  var high = (a >> 32) * b + (low >> 32);\n  var overflow = <u32>(high >> 32);\n  var space = clz(overflow);\n  var revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        var ia = reinterpret<i32>(f32(a));\n        var ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        var ia = reinterpret<i64>(f64(a));\n        var ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (changetype<usize>(a) == changetype<usize>(b) || changetype<usize>(a) == 0 || changetype<usize>(b) == 0) return 0;\n      var alen = changetype<string>(a).length;\n      var blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  var lgPlus2         = log2u(len) + 2;\n  var lgPlus2Size     = lgPlus2 << alignof<u32>();\n  var leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  var leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  var buffer = __alloc(len << alignof<T>());\n\n  var hi   = len - 1;\n  var endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  var lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  var top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  var n: u64 = right - left + 1;\n  var s = startB - (left << 1);\n  var l = startA + s;\n  var r = endB   + s + 1;\n  var a = (<u64>l << 30) / n;\n  var b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  var j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  var i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    var hasSur = surr > 0;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    var length = units.length;\n    var out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    var ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    var hasSur = <u32>code > 0xFFFF;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    var len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    var len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    var leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return false;\n    var rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    var len: isize = this.length;\n    var otherLen: isize = other.length;\n    if (otherLen != len) return select(1, -1, len > otherLen);\n    if (!otherLen) return 0; // \"\" == \"\"\n    // @ts-ignore: string <-> String\n    return compareImpl(this, 0, other, 0, otherLen);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    var size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    var size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    var len = this.length;\n    var size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var thisLen: usize = this.length;\n    var searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    var replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    var out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    var length: isize = this.length;\n    var sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    var result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // 'Σ'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    var specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    var specialsLen = SPECIALS_UPPER.length;\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      var bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      var strEnd = str + (<usize>len << 1);\n      var bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      var strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      var size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      var str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","import { E_INVALIDDATE } from \"util/error\";\nimport { Date as Date_binding } from \"./bindings/dom\";\n\n// @ts-ignore: decorator\n@inline const\n  MILLIS_PER_DAY    = 1000 * 60 * 60 * 24,\n  MILLIS_PER_HOUR   = 1000 * 60 * 60,\n  MILLIS_PER_MINUTE = 1000 * 60,\n  MILLIS_PER_SECOND = 1000;\n\n// ymdFromEpochDays returns values via globals to avoid allocations\n// @ts-ignore: decorator\n@lazy let _month: i32, _day: i32;\n\nexport class Date {\n  private year: i32 = 0;\n  private month: i32 = 0;\n  private day: i32 = 0;\n\n  @inline static UTC(\n    year: i32,\n    month: i32 = 0,\n    day: i32 = 1,\n    hour: i32 = 0,\n    minute: i32 = 0,\n    second: i32 = 0,\n    millisecond: i32 = 0\n  ): i64 {\n    if (year >= 0 && year <= 99) year += 1900;\n    var ms = epochMillis(year, month + 1, day, hour, minute, second, millisecond);\n    if (invalidDate(ms)) throw new RangeError(E_INVALIDDATE);\n    return ms;\n  }\n\n  @inline static now(): i64 {\n    return <i64>Date_binding.now();\n  }\n\n  // It can parse only ISO 8601 inputs like YYYY-MM-DDTHH:MM:SS.000Z\n  @inline static parse(dateString: string): Date {\n    return this.fromString(dateString);\n  }\n\n  static fromString(dateTimeString: string): Date {\n    if (!dateTimeString.length) throw new RangeError(E_INVALIDDATE);\n    var\n      hour: i32 = 0,\n      min: i32 = 0,\n      sec: i32 = 0,\n      ms: i32 = 0;\n\n    var dateString = dateTimeString;\n    var posT = dateTimeString.indexOf(\"T\");\n    if (~posT) {\n      // includes a time component\n      let timeString: string;\n      dateString = dateTimeString.substring(0, posT);\n      timeString = dateTimeString.substring(posT + 1);\n      // parse the HH-MM-SS component\n      let timeParts = timeString.split(\":\");\n      let len = timeParts.length;\n      if (len <= 1) throw new RangeError(E_INVALIDDATE);\n\n      hour = I32.parseInt(timeParts[0]);\n      min  = I32.parseInt(timeParts[1]);\n      if (len >= 3) {\n        let secAndMs = timeParts[2];\n        let posDot = secAndMs.indexOf(\".\");\n        if (~posDot) {\n          // includes milliseconds\n          sec = I32.parseInt(secAndMs.substring(0, posDot));\n          ms  = I32.parseInt(secAndMs.substring(posDot + 1));\n        } else {\n          sec = I32.parseInt(secAndMs);\n        }\n      }\n    }\n    // parse the YYYY-MM-DD component\n    var parts = dateString.split(\"-\");\n    var year = I32.parseInt(parts[0]);\n    var month = 1, day = 1;\n    var len = parts.length;\n    if (len >= 2) {\n      month = I32.parseInt(parts[1]);\n      if (len >= 3) {\n        day = I32.parseInt(parts[2]);\n      }\n    }\n    return new Date(epochMillis(year, month, day, hour, min, sec, ms));\n  }\n\n  constructor(private epochMillis: i64) {\n    // this differs from JavaScript which prefer return NaN or \"Invalid Date\" string\n    // instead throwing exception.\n    if (invalidDate(epochMillis)) throw new RangeError(E_INVALIDDATE);\n\n    this.year = ymdFromEpochDays(i32(floorDiv(epochMillis, MILLIS_PER_DAY)));\n    this.month = _month;\n    this.day = _day;\n  }\n\n  @inline getTime(): i64 {\n    return this.epochMillis;\n  }\n\n  setTime(time: i64): i64 {\n    if (invalidDate(time)) throw new RangeError(E_INVALIDDATE);\n\n    this.epochMillis = time;\n    this.year = ymdFromEpochDays(i32(floorDiv(time, MILLIS_PER_DAY)));\n    this.month = _month;\n    this.day = _day;\n\n    return time;\n  }\n\n  @inline getUTCFullYear(): i32 {\n    return this.year;\n  }\n\n  @inline getUTCMonth(): i32 {\n    return this.month - 1;\n  }\n\n  @inline getUTCDate(): i32 {\n    return this.day;\n  }\n\n  @inline getUTCDay(): i32 {\n    return dayOfWeek(this.year, this.month, this.day);\n  }\n\n  getUTCHours(): i32 {\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_DAY)) / MILLIS_PER_HOUR;\n  }\n\n  getUTCMinutes(): i32 {\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_HOUR)) / MILLIS_PER_MINUTE;\n  }\n\n  getUTCSeconds(): i32 {\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_MINUTE)) / MILLIS_PER_SECOND;\n  }\n\n  getUTCMilliseconds(): i32 {\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_SECOND));\n  }\n\n  setUTCMilliseconds(millis: i32): void {\n    this.setTime(this.epochMillis + (millis - this.getUTCMilliseconds()));\n  }\n\n  setUTCSeconds(seconds: i32): void {\n    this.setTime(this.epochMillis + (seconds - this.getUTCSeconds()) * MILLIS_PER_SECOND);\n  }\n\n  setUTCMinutes(minutes: i32): void {\n    this.setTime(this.epochMillis + (minutes - this.getUTCMinutes()) * MILLIS_PER_MINUTE);\n  }\n\n  setUTCHours(hours: i32): void {\n    this.setTime(this.epochMillis + (hours - this.getUTCHours()) * MILLIS_PER_HOUR);\n  }\n\n  setUTCDate(day: i32): void {\n    if (this.day == day) return;\n    var ms = euclidRem(this.epochMillis, MILLIS_PER_DAY);\n    this.setTime(i64(daysSinceEpoch(this.year, this.month, day)) * MILLIS_PER_DAY + ms);\n  }\n\n  setUTCMonth(month: i32, day: i32 = this.day): void {\n    if (this.month == month + 1) return;\n    var ms = euclidRem(this.epochMillis, MILLIS_PER_DAY);\n    this.setTime(i64(daysSinceEpoch(this.year, month + 1, day)) * MILLIS_PER_DAY + ms);\n  }\n\n  setUTCFullYear(year: i32): void {\n    if (this.year == year) return;\n    var ms = euclidRem(this.epochMillis, MILLIS_PER_DAY);\n    this.setTime(i64(daysSinceEpoch(year, this.month, this.day)) * MILLIS_PER_DAY + ms);\n  }\n\n  toISOString(): string {\n    // TODO: add more low-level helper which combine toString and padStart without extra allocation\n    var yearStr: string;\n    var year = this.year;\n    var isNeg = year < 0;\n    if (isNeg || year >= 10000) {\n      yearStr = (isNeg ? \"-\" : \"+\") + abs(year).toString().padStart(6, \"0\");\n    } else {\n      yearStr = year.toString().padStart(4, \"0\");\n    }\n\n    return (\n      yearStr +\n      \"-\" +\n      this.month.toString().padStart(2, \"0\") +\n      \"-\" +\n      this.day.toString().padStart(2, \"0\") +\n      \"T\" +\n      this.getUTCHours().toString().padStart(2, \"0\") +\n      \":\" +\n      this.getUTCMinutes().toString().padStart(2, \"0\") +\n      \":\" +\n      this.getUTCSeconds().toString().padStart(2, \"0\") +\n      \".\" +\n      this.getUTCMilliseconds().toString().padStart(3, \"0\") +\n      \"Z\"\n    );\n  }\n\n  toUTCString(): string {\n    const weeks: StaticArray<string> = [\n      \"Sun, \", \"Mon, \", \"Tue, \", \"Wed, \", \"Thu, \", \"Fri, \", \"Sat, \"\n    ];\n\n    const months: StaticArray<string> = [\n      \" Jan \", \" Feb \", \" Mar \", \" Apr \", \" May \", \" Jun \",\n      \" Jul \", \" Aug \", \" Sep \", \" Oct \", \" Nov \", \" Dec \"\n    ];\n\n    var mo = this.month;\n    var da = this.day;\n    var yr = this.year;\n    var wd = dayOfWeek(yr, mo, da);\n    var year = abs(yr).toString().padStart(4, \"0\");\n    if (yr < 0) year = \"-\" + year;\n\n    return (\n      unchecked(weeks[wd]) +\n      da.toString().padStart(2, \"0\") +\n      unchecked(months[mo - 1]) +\n      year +\n      \" \" +\n      this.getUTCHours().toString().padStart(2, \"0\") +\n      \":\" +\n      this.getUTCMinutes().toString().padStart(2, \"0\") +\n      \":\" +\n      this.getUTCSeconds().toString().padStart(2, \"0\") +\n      \" GMT\"\n    );\n  }\n\n  toDateString(): string {\n    // TODO: use u64 static data instead 4 chars\n    // also use stream itoa variants.\n    const weeks: StaticArray<string> = [\n      \"Sun \", \"Mon \", \"Tue \", \"Wed \", \"Thu \", \"Fri \", \"Sat \"\n    ];\n\n    const months: StaticArray<string> = [\n      \"Jan \", \"Feb \", \"Mar \", \"Apr \", \"May \", \"Jun \",\n      \"Jul \", \"Aug \", \"Sep \", \"Oct \", \"Nov \", \"Dec \"\n    ];\n\n    var mo = this.month;\n    var da = this.day;\n    var yr = this.year;\n    var wd = dayOfWeek(yr, mo, da);\n    var year = abs(yr).toString().padStart(4, \"0\");\n    if (yr < 0) year = \"-\" + year;\n\n    return (\n      unchecked(weeks[wd]) +\n      unchecked(months[mo - 1]) +\n      da.toString().padStart(2, \"0\") +\n      \" \" + year\n    );\n  }\n\n  // Note: it uses UTC time instead local time (without timezone offset)\n  toTimeString(): string {\n    // TODO: add timezone\n    return (\n      this.getUTCHours().toString().padStart(2, \"0\") +\n      \":\" +\n      this.getUTCMinutes().toString().padStart(2, \"0\") +\n      \":\" +\n      this.getUTCSeconds().toString().padStart(2, \"0\")\n    );\n  }\n\n  // Note: it uses UTC datetime instead local datetime (without timezone offset)\n  toString(): string {\n    return this.toDateString() + \" \" + this.toTimeString();\n  }\n}\n\nfunction epochMillis(\n  year: i32,\n  month: i32,\n  day: i32,\n  hour: i32,\n  minute: i32,\n  second: i32,\n  milliseconds: i32\n): i64 {\n  return (\n    i64(daysSinceEpoch(year, month, day)) * MILLIS_PER_DAY +\n    hour * MILLIS_PER_HOUR +\n    minute * MILLIS_PER_MINUTE +\n    second * MILLIS_PER_SECOND +\n    milliseconds\n  );\n}\n\n// @ts-ignore: decorator\n@inline function floorDiv<T extends number>(a: T, b: T): T {\n  return (a >= 0 ? a : a - b + 1) / b as T;\n}\n\n// @ts-ignore: decorator\n@inline function euclidRem<T extends number>(a: T, b: T): T {\n  var m = a % b;\n  return m + (m < 0 ? b : 0) as T;\n}\n\nfunction invalidDate(millis: i64): bool {\n  // @ts-ignore\n  return (millis < -8640000000000000) | (millis > 8640000000000000);\n}\n\n// see: http://howardhinnant.github.io/date_algorithms.html#civil_from_days\nfunction ymdFromEpochDays(z: i32): i32 {\n  z += 719468;\n  var era = <u32>floorDiv(z, 146097);\n  var doe = <u32>z - era * 146097; // [0, 146096]\n  var yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365; // [0, 399]\n  var year = yoe + era * 400;\n  var doy = doe - (365 * yoe + yoe / 4 - yoe / 100); // [0, 365]\n  var mo = (5 * doy + 2) / 153; // [0, 11]\n  _day = doy - (153 * mo + 2) / 5 + 1; // [1, 31]\n  mo += mo < 10 ? 3 : -9; // [1, 12]\n  _month = mo;\n  year += u32(mo <= 2);\n  return year;\n}\n\n// http://howardhinnant.github.io/date_algorithms.html#days_from_civil\nfunction daysSinceEpoch(y: i32, m: i32, d: i32): i32 {\n  y -= i32(m <= 2);\n  var era = <u32>floorDiv(y, 400);\n  var yoe = <u32>y - era * 400; // [0, 399]\n  var doy = <u32>(153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1; // [0, 365]\n  var doe = yoe * 365 + yoe / 4 - yoe / 100 + doy; // [0, 146096]\n  return era * 146097 + doe - 719468;\n}\n\n// TomohikoSakamoto algorithm from https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week\nfunction dayOfWeek(year: i32, month: i32, day: i32): i32 {\n  const tab = memory.data<u8>([0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]);\n\n  year -= i32(month < 3);\n  year += floorDiv(year, 4) - floorDiv(year, 100) + floorDiv(year, 400);\n  month = <i32>load<u8>(tab + month - 1);\n  return euclidRem(year + month + day, 7);\n}\n","//import { console } from 'as-console'\n\nexport function sleep(ms: i64): void {\n\n  const target = Date.now() + ms\n\n  while (target > Date.now()) { }\n\n}\n\nexport function sleepCallback(callback: () => void, ms: i64): void {\n\n  const target = Date.now() + ms\n\n  while (target > Date.now()) { }\n\n  callback()\n\n}\n/*\nexport function test(): void {\n\n  console.log('Starting sleep for one second.')\n\n  const start = Date.now()\n\n  const result = Date.now() - start\n\n  console.log('Slept for one second.')\n\n  console.log('Total Time: ' + result.toString() + 'ms')\n\n}*/","import { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { ArrayBuffer } from \"./arraybuffer\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from \"./util/error\";\n\n// TODO: there is probably a smarter way to check byteOffset for accesses larger than 1 byte\n\nexport class DataView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  constructor(\n    buffer: ArrayBuffer,\n    byteOffset: i32 = 0,\n    byteLength: i32 = buffer.byteLength\n  ) {\n    if (\n      i32(<u32>byteLength > <u32>BLOCK_MAXSIZE) |\n      i32(<u32>byteOffset + byteLength > <u32>buffer.byteLength)\n    ) throw new RangeError(E_INVALIDLENGTH);\n    this.buffer = buffer; // links\n    var dataStart = changetype<usize>(buffer) + <usize>byteOffset;\n    this.dataStart = dataStart;\n    this.byteLength = byteLength;\n  }\n\n  getFloat32(byteOffset: i32, littleEndian: bool = false): f32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    return littleEndian\n      ? load<f32>(this.dataStart + <usize>byteOffset)\n      : reinterpret<f32>(bswap<u32>(load<u32>(this.dataStart + <usize>byteOffset)));\n  }\n\n  getFloat64(byteOffset: i32, littleEndian: bool = false): f64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    return littleEndian\n      ? load<f64>(this.dataStart + <usize>byteOffset)\n      : reinterpret<f64>(bswap<u64>(load<u64>(this.dataStart + <usize>byteOffset)));\n  }\n\n  getInt8(byteOffset: i32): i8 {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>byteOffset);\n  }\n\n  getInt16(byteOffset: i32, littleEndian: bool = false): i16 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: i16 = load<i16>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u16>(result);\n  }\n\n  getInt32(byteOffset: i32, littleEndian: bool = false): i32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: i32 = load<i32>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u32>(result);\n  }\n\n  getUint8(byteOffset: i32): u8 {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>byteOffset);\n  }\n\n  getUint16(byteOffset: i32, littleEndian: bool = false): u16 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: u16 = load<u16>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u16>(result);\n  }\n\n  getUint32(byteOffset: i32, littleEndian: bool = false): u32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: u32 = load<u32>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u32>(result);\n  }\n\n  setFloat32(byteOffset: i32, value: f32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    if (littleEndian) store<f32>(this.dataStart + <usize>byteOffset, value);\n    else store<u32>(this.dataStart + <usize>byteOffset, bswap<u32>(reinterpret<u32>(value)));\n  }\n\n  setFloat64(byteOffset: i32, value: f64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    if (littleEndian) store<f64>(this.dataStart + <usize>byteOffset, value);\n    else store<u64>(this.dataStart + <usize>byteOffset, bswap<u64>(reinterpret<u64>(value)));\n  }\n\n  setInt8(byteOffset: i32, value: i8): void {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>byteOffset, value);\n  }\n\n  setInt16(byteOffset: i32, value: i16, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\n  }\n\n  setInt32(byteOffset: i32, value: i32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\n  }\n\n  setUint8(byteOffset: i32, value: u8): void {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>byteOffset, value);\n  }\n\n  setUint16(byteOffset: i32, value: u16, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\n  }\n\n  setUint32(byteOffset: i32, value: u32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\n  }\n\n  // Non-standard additions that make sense in WebAssembly, but won't work in JS:\n\n  getInt64(byteOffset: i32, littleEndian: bool = false): i64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: i64 = load<i64>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u64>(result);\n  }\n\n  getUint64(byteOffset: i32, littleEndian: bool = false): u64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result = load<u64>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u64>(result);\n  }\n\n  setInt64(byteOffset: i32, value: i64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\n  }\n\n  setUint64(byteOffset: i32, value: u64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\n  }\n\n  toString(): string {\n    return \"[object DataView]\";\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ILLEGALGENTYPE: string = \"Illegal generic type\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { OBJECT, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ptr: usize, classId: u32): bool { // keyword\n  var id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;\n  var rttiBase = __rtti_base;\n  if (id <= load<u32>(rttiBase)) {\n    do if (id == classId) return true;\n    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  var buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  var buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  var array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","/**\n * Decoder implements protobuf message decode interface.\n *\n * Useful references:\n *\n * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding\n * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128\n * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba\n */\nexport class Decoder {\n  public view: DataView;\n  public pos: i32;\n\n  constructor(view: DataView) {\n    this.view = view;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns true if current reader has reached the buffer end\n   * @returns True if current reader has reached the buffer end\n   */\n  @inline\n  eof(): bool {\n    return this.pos >= this.view.byteLength;\n  }\n\n  /**\n   * Returns current buffer length in bytes\n   * @returns Length in bytes\n   */\n  @inline\n  get byteLength(): i32 {\n    return this.view.byteLength;\n  }\n\n  /**\n   * An alias method to fetch tag from the reader. Supposed to return tuple of [field number, wire_type].\n   * TODO: Replace with return tuple when tuples become implemented in AS.\n   * @returns Message tag value\n   */\n  @inline\n  tag(): u32 {\n    return this.uint32();\n  }\n\n  /**\n   * Returns byte at offset, alias for getUint8\n   * @param byteOffset Offset\n   * @returns u8\n   */\n  @inline\n  private u8at(byteOffset: i32): u8 {\n    return this.view.getUint8(byteOffset);\n  }\n\n  /**\n   * Reads and returns varint number (128 + 10 bits max) from a current position.\n   * @returns Returns varint\n   */\n  varint(): u64 {\n    let value: u64;\n\n    // u32\n    value = (u64(u8(this.u8at(this.pos))) & 127) >>> 0;\n    if (u8(this.u8at(this.pos++)) < 128) return value;\n    value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 7)) >>> 0;\n    if (u8(this.u8at(this.pos++)) < 128) return value;\n    value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 14)) >>> 0;\n    if (u8(this.u8at(this.pos++)) < 128) return value;\n    value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 21)) >>> 0;\n    if (u8(this.u8at(this.pos++)) < 128) return value;\n    // u32 remainder or u64 byte\n    value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n    if (u8(this.u8at(this.pos++)) < 128) return value;\n    // u64\n    value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n    if (u8(this.u8at(this.pos++)) < 128) return value;\n    value =\n      (value | ((u64(u8(this.u8at(this.pos))) & 127) << 42)) /* 42!!! */ >>> 0;\n    if (u8(this.u8at(this.pos++)) < 128) return value;\n    value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 49)) >>> 0;\n    if (u8(this.u8at(this.pos++)) < 128) return value;\n    value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n    if (u8(this.u8at(this.pos++)) < 128) return value;\n    // u64 remainder\n    value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n    if (u8(this.u8at(this.pos++)) < 128) return value;\n\n    if (this.pos > this.byteLength) {\n      this.throwOutOfRange();\n    }\n\n    return value;\n  }\n\n  @inline\n  int32(): i32 {\n    return i32(this.varint());\n  }\n\n  @inline\n  int64(): i64 {\n    return i32(this.varint());\n  }\n\n  @inline\n  uint32(): u32 {\n    return u32(this.varint());\n  }\n\n  @inline\n  uint64(): u64 {\n    return u64(this.varint());\n  }\n\n  @inline\n  sint32(): i32 {\n    const n: u64 = this.varint();\n    return i32((n >>> 1) ^ -(n & 1));\n  }\n\n  @inline\n  sint64(): i64 {\n    const n: u64 = this.varint();\n    return i64((n >>> 1) ^ -(n & 1));\n  }\n\n  fixed32(): u32 {\n    this.pos += 4;\n    if (this.pos > this.byteLength) {\n      this.throwOutOfRange();\n    }\n\n    // u32(u8) ensures that u8(-1) becomes u32(4294967295) instead of u8(255)\n    return (\n      u32(u8(this.u8at(this.pos - 4))) |\n      (u32(u8(this.u8at(this.pos - 3))) << 8) |\n      (u32(u8(this.u8at(this.pos - 2))) << 16) |\n      (u32(u8(this.u8at(this.pos - 1))) << 24)\n    );\n  }\n\n  @inline\n  sfixed32(): i32 {\n    return i32(this.fixed32());\n  }\n\n  fixed64(): u64 {\n    this.pos += 8;\n    if (this.pos > this.byteLength) {\n      this.throwOutOfRange();\n    }\n\n    return (\n      u64(u8(this.u8at(this.pos - 8))) |\n      (u64(u8(this.u8at(this.pos - 7))) << 8) |\n      (u64(u8(this.u8at(this.pos - 6))) << 16) |\n      (u64(u8(this.u8at(this.pos - 5))) << 24) |\n      (u64(u8(this.u8at(this.pos - 4))) << 32) |\n      (u64(u8(this.u8at(this.pos - 3))) << 40) |\n      (u64(u8(this.u8at(this.pos - 2))) << 48) |\n      (u64(u8(this.u8at(this.pos - 1))) << 56)\n    );\n  }\n\n  @inline\n  sfixed64(): i64 {\n    return i64(this.fixed64());\n  }\n\n  @inline\n  float(): f32 {\n    return f32.reinterpret_i32(this.fixed32());\n  }\n\n  @inline\n  double(): f64 {\n    return f64.reinterpret_i64(this.fixed64());\n  }\n\n  @inline\n  bool(): boolean {\n    return this.uint32() > 0;\n  }\n\n  /**\n   * Reads and returns UTF8 string.\n   * @returns String\n   */\n  string(): string {\n    const length = this.uint32();\n    if (this.pos + length > this.byteLength) {\n      this.throwOutOfRange();\n    }\n\n    const p = this.pos + this.view.byteOffset;\n    const value = String.UTF8.decode(this.view.buffer.slice(p, p + length));\n    this.pos += length;\n    return value;\n  }\n\n  /**\n   * Reads and returns bytes array.\n   * @returns Array<u8> of bytes\n   */\n  bytes(): Array<u8> {\n    const len = this.uint32();\n    if (this.pos + len > this.byteLength) {\n      this.throwOutOfRange();\n    }\n\n    const a = new Array<u8>(len);\n    for (let i: u32 = 0; i < len; i++) {\n      a[i] = u8(this.u8at(this.pos++));\n    }\n\n    return a;\n  }\n\n  /**\n   * Skips a message field if it can'be recognized by an object's decode() method\n   * @param wireType Current wire type\n   */\n  skipType(wireType: u32): void {\n    switch (wireType) {\n      // int32, int64, uint32, uint64, sint32, sint64, bool, enum: varint, variable length\n      case 0:\n        this.varint(); // Just read a varint\n        break;\n      // fixed64, sfixed64, double: 8 bytes always\n      case 1:\n        this.skip(8);\n        break;\n      // length-delimited; length is determined by varint32; skip length bytes;\n      case 2:\n        this.skip(this.uint32());\n        break;\n      // tart group: skip till the end of the group, then skip group end marker\n      case 3:\n        while ((wireType = this.uint32() & 7) !== 4) {\n          this.skipType(wireType);\n        }\n        break;\n      // fixed32, sfixed32, float: 4 bytes always\n      case 5:\n        this.skip(4);\n        break;\n\n      // Something went beyond our capability to understand\n      default:\n        throw new Error(`Invalid wire type ${wireType} at offset ${this.pos}`);\n    }\n  }\n\n  /**\n   * Fast-forwards cursor by length with boundary check\n   * @param length Byte length\n   */\n  skip(length: u32): void {\n    if (this.pos + length > this.byteLength) {\n      this.throwOutOfRange();\n    }\n    this.pos += length;\n  }\n\n  /**\n   * OutOfRange check. Throws an exception if current position exceeds current buffer range\n   */\n  @inline\n  private throwOutOfRange(): void {\n    throw new Error(`Decoder position ${this.pos} is out of range!`);\n  }\n}\n\n/**\n * Encoder implements protobuf message encode interface. This is the simplest not very effective version, which uses\n * Array<u8>.\n *\n * Useful references:\n *\n * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding\n * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128\n * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba\n */\nexport class Encoder {\n  public buf: Array<u8>;\n\n  constructor(buf: Array<u8>) {\n    this.buf = buf;\n  }\n\n  /**\n   * Encodes varint at a current position\n   * @returns Returns varint\n   */\n  varint64(value: u64): void {\n    let v: u64 = value;\n\n    while (v > 127) {\n      this.buf.push(u8((v & 127) | 128));\n      v = v >> 7;\n    }\n\n    this.buf.push(u8(v));\n  }\n\n  @inline\n  int32(value: i32): void {\n    this.varint64(value);\n  }\n\n  @inline\n  int64(value: i64): void {\n    this.varint64(value);\n  }\n\n  @inline\n  uint32(value: u32): void {\n    this.varint64(value);\n  }\n\n  @inline\n  uint64(value: u64): void {\n    this.varint64(value);\n  }\n\n  @inline\n  sint32(value: i32): void {\n    this.varint64((value << 1) ^ (value >> 31));\n  }\n\n  @inline\n  sint64(value: i64): void {\n    this.varint64((value << 1) ^ (value >> 63));\n  }\n\n  @inline\n  fixed32(value: u32): void {\n    this.buf.push(u8(value & 255));\n    this.buf.push(u8((value >> 8) & 255));\n    this.buf.push(u8((value >> 16) & 255));\n    this.buf.push(u8(value >> 24));\n  }\n\n  @inline\n  sfixed32(value: i32): void {\n    this.fixed32(u32(value));\n  }\n\n  @inline\n  fixed64(value: u64): void {\n    this.buf.push(u8(value & 255));\n    this.buf.push(u8((value >> 8) & 255));\n    this.buf.push(u8((value >> 16) & 255));\n    this.buf.push(u8((value >> 24) & 255));\n    this.buf.push(u8((value >> 32) & 255));\n    this.buf.push(u8((value >> 40) & 255));\n    this.buf.push(u8((value >> 48) & 255));\n    this.buf.push(u8(value >> 56));\n  }\n\n  @inline\n  sfixed64(value: i64): void {\n    this.fixed64(u64(value));\n  }\n\n  @inline\n  float(value: f32): void {\n    this.fixed32(u32(i32.reinterpret_f32(value)));\n  }\n\n  @inline\n  double(value: f64): void {\n    this.fixed64(u64(i64.reinterpret_f64(value)));\n  }\n\n  @inline\n  bool(value: boolean): void {\n    this.buf.push(value ? 1 : 0);\n  }\n\n  string(value: string): void {\n    const utf8string = new DataView(String.UTF8.encode(value));\n\n    for (let i = 0; i < utf8string.byteLength; i++) {\n      this.buf.push(utf8string.getUint8(i));\n    }\n  }\n\n  @inline\n  bytes(value: Array<u8>): void {\n    for (let i = 0; i < value.length; i++) {\n      this.buf.push(value[i]);\n    }\n  }\n}\n\n/**\n * Returns byte size required to encode a value of a certain type\n */\nexport class Sizer {\n  static varint64(value: u64): u32 {\n    return value < 128\n      ? 1 // 2^7\n      : value < 16384\n      ? 2 // 2^14\n      : value < 2097152\n      ? 3 // 2^21\n      : value < 268435456\n      ? 4 // 2^28\n      : value < 34359738368\n      ? 5 // 2^35\n      : value < 4398046511104\n      ? 6 // 2^42\n      : value < 562949953421312\n      ? 7 // 2^49\n      : value < 72057594037927936\n      ? 8 // 2^56\n      : value < 9223372036854775808\n      ? 9 // 2^63\n      : 10;\n  }\n\n  @inline\n  static int32(value: i32): u32 {\n    return Sizer.varint64(u64(value));\n  }\n\n  @inline\n  static int64(value: i64): u32 {\n    return Sizer.varint64(u64(value));\n  }\n\n  @inline\n  static uint32(value: u32): u32 {\n    return Sizer.varint64(value);\n  }\n\n  @inline\n  static uint64(value: u64): u32 {\n    return Sizer.varint64(value);\n  }\n\n  @inline\n  static sint32(value: i32): u32 {\n    return Sizer.varint64((value << 1) ^ (value >> 31));\n  }\n\n  @inline\n  static sint64(value: i64): u32 {\n    return Sizer.varint64((value << 1) ^ (value >> 63));\n  }\n\n  @inline\n  static string(value: string): u32 {\n    return value.length;\n  }\n\n  @inline\n  static bytes(value: Array<u8>): u32 {\n    return value.length;\n  }\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    var length = source.length;\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    var sourceLen = source.length;\n    var otherLen = other.length;\n    var outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<StaticArray<T>>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n    var outStart = changetype<usize>(out);\n    var sourceSize = <usize>sourceLen << alignof<T>();\n    if (isManaged<T>()) {\n      for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(source) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += sourceSize;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(other) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(source), sourceSize);\n      memory.copy(outStart + sourceSize, changetype<usize>(other), <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    var length = source.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var sliceSize = <usize>length << alignof<T>();\n    var slice = changetype<StaticArray<T>>(__new(sliceSize, idof<StaticArray<T>>()));\n    var sourcePtr = changetype<usize>(source) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off: usize = 0;\n      while (off < sliceSize) {\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(slice) + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(changetype<usize>(slice), sourcePtr, sliceSize);\n    }\n    return slice;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    var len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var ptr = changetype<usize>(this);\n    var len = this.length;\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        store<usize>(ptr + (<usize>start << alignof<T>()), changetype<usize>(value));\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          ptr + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(ptr + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var ptr = changetype<usize>(this);\n    var len = this.length;\n\n    end = min<i32>(end, len);\n\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    var length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length;\n    var otherLen = other.length;\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = changetype<usize>(this);\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(this), thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = changetype<usize>(this) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    var len = this.length;\n    var out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    var outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): this {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_ILLEGALGENTYPE, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  var oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    var array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    var bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    var buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    var len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var ptr = this.dataStart;\n    var len = this.length_;\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        store<usize>(ptr + (<usize>start << alignof<T>()), changetype<usize>(value));\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          ptr + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(ptr + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    var ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    var len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    var ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    var oldLen = this.length_;\n    var len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = other.length_;\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var ptr = this.dataStart;\n    var len = this.length_;\n\n    end = min<i32>(end, len);\n\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    var len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    var val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var len = this.length_;\n    var out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    var outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    var len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    var base = this.dataStart;\n    var element = load<T>(base);\n    var lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    var len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    var ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    var result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    var resultStart = result.dataStart;\n    var thisStart = this.dataStart;\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): this {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var ptr = this.dataStart;\n    var len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      throw new TypeError(E_ILLEGALGENTYPE);\n    }\n    // Get the length and data start values\n    var ptr = this.dataStart;\n    var len = this.length_;\n\n    // calculate the end size with an initial pass\n    var size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    var byteLength = <usize>size << align;\n    var outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    var outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    var resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\n\n  var h: u32 = key.length << 1;\n  var len: usize = h;\n  var pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  var end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) != null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var keys = new Array<K>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        keys[length++] = entry.key;\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<V>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.value;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","import * as __proto from \"./__proto\";\n\n// StringValues is a list of strings.\nexport class StringValues {\n  public Values: Array<string> = new Array<string>();\n\n  // Decodes StringValues from an ArrayBuffer\n  static decode(buf: ArrayBuffer): StringValues {\n    return StringValues.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes StringValues from a DataView\n  static decodeDataView(view: DataView): StringValues {\n    const decoder = new __proto.Decoder(view);\n    const obj = new StringValues();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          obj.Values.push(decoder.string());\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode StringValues\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    size += __size_string_repeated(this.Values);\n\n    return size;\n  }\n\n  // Encodes StringValues to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes StringValues to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Values.length > 0) {\n      for (let n: i32 = 0; n < this.Values.length; n++) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.Values[n].length);\n        encoder.string(this.Values[n]);\n      }\n    }\n\n    return buf;\n  } // encode StringValues\n} // StringValues\n\n/**\n * LabelValues is a list of key value pairs, where key is a string\n *  and value is a list of string values.\n */\nexport class LabelValues {\n  // Values contains key value pairs.\n  public Values: Map<string, StringValues> = new Map<string, StringValues>();\n\n  // Decodes LabelValues from an ArrayBuffer\n  static decode(buf: ArrayBuffer): LabelValues {\n    return LabelValues.decodeDataView(new DataView(buf));\n  }\n\n  // Decodes LabelValues from a DataView\n  static decodeDataView(view: DataView): LabelValues {\n    const decoder = new __proto.Decoder(view);\n    const obj = new LabelValues();\n\n    while (!decoder.eof()) {\n      const tag = decoder.tag();\n      const number = tag >>> 3;\n\n      switch (number) {\n        case 1: {\n          const length = decoder.uint32();\n          __decodeMap_string_StringValues(decoder, length, obj.Values);\n          decoder.skip(length);\n\n          break;\n        }\n\n        default:\n          decoder.skipType(tag & 7);\n          break;\n      }\n    }\n    return obj;\n  } // decode LabelValues\n\n  public size(): u32 {\n    let size: u32 = 0;\n\n    if (this.Values.size > 0) {\n      const keys = this.Values.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Values.get(key);\n        const itemSize = __sizeMapEntry_string_StringValues(key, value);\n        if (itemSize > 0) {\n          size += 1 + __proto.Sizer.varint64(itemSize) + itemSize;\n        }\n      }\n    }\n\n    return size;\n  }\n\n  // Encodes LabelValues to the ArrayBuffer\n  encode(): ArrayBuffer {\n    return changetype<ArrayBuffer>(\n      StaticArray.fromArray<u8>(this.encodeU8Array())\n    );\n  }\n\n  // Encodes LabelValues to the Array<u8>\n  encodeU8Array(\n    encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n  ): Array<u8> {\n    const buf = encoder.buf;\n\n    if (this.Values.size > 0) {\n      const keys = this.Values.keys();\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this.Values.get(key);\n        const size = __sizeMapEntry_string_StringValues(key, value);\n        if (size > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(size);\n          if (key.length > 0) {\n            encoder.uint32(0xa);\n            encoder.uint32(key.length);\n            encoder.string(key);\n          }\n\n          const messageSize = value.size();\n\n          if (messageSize > 0) {\n            encoder.uint32(0x12);\n            encoder.uint32(messageSize);\n            value.encodeU8Array(encoder);\n          }\n        }\n      }\n    }\n\n    return buf;\n  } // encode LabelValues\n} // LabelValues\n\n// __size_string_repeated\n\nfunction __size_string_repeated(value: Array<string>): u32 {\n  let size: u32 = 0;\n\n  for (let n: i32 = 0; n < value.length; n++) {\n    size += 1 + __proto.Sizer.varint64(value[n].length) + value[n].length;\n  }\n\n  return size;\n}\n\n// __decodeMap_string_StringValues\n\nfunction __decodeMap_string_StringValues(\n  parentDecoder: __proto.Decoder,\n  length: i32,\n  map: Map<string, StringValues>\n): void {\n  const decoder = new __proto.Decoder(\n    new DataView(\n      parentDecoder.view.buffer,\n      parentDecoder.pos + parentDecoder.view.byteOffset,\n      length\n    )\n  );\n\n  let key: string = \"\";\n  let value: StringValues = new StringValues();\n\n  while (!decoder.eof()) {\n    const tag = decoder.tag();\n    const number = tag >>> 3;\n\n    switch (number) {\n      case 1: {\n        key = decoder.string();\n        break;\n      }\n\n      case 2: {\n        const length = decoder.uint32();\n        value = StringValues.decodeDataView(\n          new DataView(\n            decoder.view.buffer,\n            decoder.pos + decoder.view.byteOffset,\n            length\n          )\n        );\n        decoder.skip(length);\n\n        break;\n      }\n\n      default:\n        decoder.skipType(tag & 7);\n        break;\n    }\n  }\n  map.set(key as string, value as StringValues);\n}\n\n// __sizeMapEntry_string_StringValues\n\nfunction __sizeMapEntry_string_StringValues(\n  key: string,\n  value: StringValues\n): u32 {\n  const keySize =\n    key.length > 0 ? 1 + __proto.Sizer.varint64(key.length) + key.length : 0;\n  const valueSize = value.size();\n\n  if (valueSize == 0) {\n    return keySize;\n  }\n\n  return keySize + 1 + __proto.Sizer.varint64(valueSize) + valueSize;\n}\n"]}